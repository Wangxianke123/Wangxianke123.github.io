<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangxianke123.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="System Verilog语法的学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="System Verilog Notes">
<meta property="og:url" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/index.html">
<meta property="og:site_name" content="花间一壶酒">
<meta property="og:description" content="System Verilog语法的学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_14-08-17.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_15-23-40.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_15-24-38.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-37.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-38.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-39.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-41.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-42.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-44.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-5.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-6.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-45.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-46.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-47.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-48.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-7.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-8.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-9.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-10.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-21.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-50.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-12.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-13.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-14.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-51.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-52.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-16.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-17.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-55.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-18.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-19.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-20.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-56.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-57.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-22.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-23.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-24.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-25.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-58.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-59.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-28.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-63.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-62.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-64.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-65.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-66.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-67.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-68.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-69.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-26.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-60.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-70.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-61.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-27.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-31.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-32.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-33.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-34.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-35.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-36.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-71.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-74.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-72.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/image-73.png">
<meta property="article:published_time" content="2024-02-12T04:13:05.000Z">
<meta property="article:modified_time" content="2024-04-19T02:57:23.876Z">
<meta property="article:author" content="Wang xianke">
<meta property="article:tag" content="ICer">
<meta property="article:tag" content="Programming Language">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_14-08-17.png">

<link rel="canonical" href="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>System Verilog Notes | 花间一壶酒</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">花间一壶酒</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">举杯邀明月，对影成三人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wangxianke123.github.io/2024/02/12/System-Verilog-Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang xianke">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花间一壶酒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          System Verilog Notes
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-12 12:13:05" itemprop="dateCreated datePublished" datetime="2024-02-12T12:13:05+08:00">2024-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-19 10:57:23" itemprop="dateModified" datetime="2024-04-19T10:57:23+08:00">2024-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">notes</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>47k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:25</span>
            </span>
            <div class="post-description">System Verilog语法的学习笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="System-Verilog期末复习"><a href="#System-Verilog期末复习" class="headerlink" title="System Verilog期末复习"></a>System Verilog期末复习</h1><p><strong>题型：<br>简答（填空、代码解析、电路图、波形）<br>编程<br>共20题</strong></p>
<h2 id="SV中的数据类型"><a href="#SV中的数据类型" class="headerlink" title="SV中的数据类型"></a>SV中的数据类型</h2><p><strong>线网</strong>：<code>net tpye</code>  与verilog类似</p>
<p><strong>变量</strong> <code>variable</code><br>大多数变量本身不用来描述电路，只用于更高抽象层面的验证</p>
<p>Reg&#x2F;<strong>logic&#x2F;Bit</strong>&#x2F;byte&#x2F;shortint&#x2F;int&#x2F;longint</p>
<p><strong>增加了2值数据类型</strong></p>
<p><code>logic</code>: <strong>4值数据类型</strong><br>用来代替verilog中的reg和wire<br>（<strong>其中reg被logic完全代替，但logic不能被多驱动</strong>）<br>举例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> a;</span><br><span class="line"><span class="keyword">assign</span> a = xxx; <span class="comment">///wrong</span></span><br><span class="line"><span class="keyword">logic</span> a;</span><br><span class="line"><span class="keyword">assign</span> a = xxx;  <span class="comment">//  acceptable</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> LDT(<span class="keyword">input</span> <span class="keyword">logic</span> res);</span><br><span class="line"><span class="keyword">logic</span> q, qn, d, clk, resl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">forever</span> #<span class="number">5</span> clk=~clk;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> resl=~res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">not</span> a(qn,q);</span><br><span class="line">DFF D(q, d, clk, resl);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>logic的使用更加自由，用作端口连接信号时不受限制。</p>
<p><strong>2值数据类型</strong>  （用于testbench）<br>Bit<br>• 1 bit, 2 state integer, scalable to vector</p>
<p>byte<br>• 8 bit, 2 state integer (similar to char in C)  </p>
<p>shortint<br>• 16 bit, 2 state integer (similar to short in C)  </p>
<p>int<br>• 32 bit, 2 state integer (similar to int in C)  </p>
<p>longint<br>• 64 bit, 2 state integer (similar to longlong in C)  </p>
<p>注意区分<code>logic[7:0] x</code> 与 <code>byte x</code> 的区别</p>
<p>1.byte是有符号的，并且只有2值(0和1)</p>
<p><img src="/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_14-08-17.png"><br>4值和2值类型之间如何相互转化？<br>4值的x和z都被转化为2值的0（导致信息丢失）</p>
<p>使用<code>$isunknown</code>来判断x和z</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">$isunknown</span>(iport)==<span class="number">1</span>)</span><br><span class="line"><span class="built_in">$display</span> (“ <span class="number">4</span>-state variable detected”);</span><br></pre></td></tr></table></figure>


<h3 id="Array-Dynamic-arrays-Associative-arrays-Queues"><a href="#Array-Dynamic-arrays-Associative-arrays-Queues" class="headerlink" title="Array&#x2F; Dynamic arrays&#x2F;Associative arrays&#x2F;Queues"></a>Array&#x2F; Dynamic arrays&#x2F;Associative arrays&#x2F;Queues</h3><p>verilog中的向量：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>[msb:lsb] data;</span><br><span class="line"><span class="comment">//msb 和lsb为常数，二者之间的大小关系没有要求</span></span><br><span class="line"><span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] data_in;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] data_out;<span class="comment">//recommend grammar</span></span><br></pre></td></tr></table></figure>

<p>寄存器组可以用来建模 ROM,RAM（6个晶体管实现1位存储）,RF(register file，26个晶体管实现1位存储)。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>[msb:lsb] memory[upper:lower];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] memory1 [<span class="number">0</span>:<span class="number">63</span>]; <span class="comment">//64个8位的存储器</span></span><br><span class="line"><span class="keyword">reg</span> mema [<span class="number">1</span>:<span class="number">5</span>]; <span class="comment">//5个一位的存储器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">5</span>] rega; <span class="comment">//1个5位的寄存器</span></span><br><span class="line"><span class="comment">//区别：对于存储器的访问须指定地址，不能实现同时的所有地址访问。</span></span><br><span class="line">rega = <span class="number">0</span>; <span class="comment">// Legal syntax</span></span><br><span class="line">mema = <span class="number">0</span>; <span class="comment">// illegal syntax，不能同时读</span></span><br><span class="line">mema[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//Assigns 0 to the first element of mema。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> arrayb[<span class="number">7</span>:<span class="number">0</span>][<span class="number">0</span>:<span class="number">255</span>]; <span class="comment">// declare a two-dimensional array of one bit registers 不推荐的写法(找不到对应的硬件)</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，初始化操作mema&#x3D;0不合法，同时对硬件(SRAM)来说,初始化同样没有实现机制。</p>
<p>在设计中，对memeory的单比特访问同样不推荐(mem[a][b])，因为对硬件来说一般会直接读整个字。</p>
<p><strong>对向量的赋值</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test_vector();</span><br><span class="line"><span class="keyword">parameter</span> SIZE=<span class="number">64</span>;</span><br><span class="line"><span class="keyword">reg</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] data1;</span><br><span class="line"><span class="keyword">logic</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] data2;</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">data1=<span class="number">0</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br><span class="line">data1=<span class="number">&#x27;bz</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br><span class="line">data1=<span class="number">&#x27;bx</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br><span class="line">data1=<span class="number">64&#x27;hFFFFFFFFFFFFFFFF</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br></pre></td></tr></table></figure>

<p><strong>packed和unpacked Array：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] c1; <span class="comment">// packed array of scalar bit types</span></span><br><span class="line"><span class="keyword">real</span> u [<span class="number">7</span>:<span class="number">0</span>]; <span class="comment">// unpacked array of real types</span></span><br></pre></td></tr></table></figure>

<p>一维的packed Array相当于vector</p>
<p>Packed Array只能被声明为单比特的数据类型。<br>packed: 存储的时候被打包在一起，可以被当作一个一元变量处理（直接整体赋值）。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>]bytes;</span><br><span class="line">bytes=<span class="number">32</span>’habcd_efab;</span><br><span class="line"><span class="built_in">$displayh</span>(bytes</span><br><span class="line">        bytes[<span class="number">3</span>]</span><br><span class="line">        bytes[<span class="number">3</span>][<span class="number">7</span>]);</span><br></pre></td></tr></table></figure>

<p>Unpacked Array可以被声明为任何数据类型,一般用于一些比较复杂的数据结构。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lo_hi[<span class="number">0</span>:<span class="number">15</span>]; <span class="comment">//16 ints [0]..[15], Verilog style</span></span><br><span class="line"><span class="keyword">int</span> lo_hi[<span class="number">16</span>]; <span class="comment">//16 ints [0]..[15]，SV style (C’s style)</span></span><br></pre></td></tr></table></figure>

<p>读写问题：<br>越界写被忽略，越界读则得到：（x for 4-state,0 for 2 state）</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test_outboundry();</span><br><span class="line"><span class="keyword">byte</span> array1 [<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] array2 [<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">array1[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">255</span>;</span><br><span class="line">array2[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">255</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%d&quot;</span>,array1[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// -1 for byte is signed</span></span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%d&quot;</span>,array2[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 255</span></span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,array1[<span class="number">3</span>][<span class="number">3</span>]); <span class="comment">// 8&#x27;b00000000</span></span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,array2[<span class="number">3</span>][<span class="number">3</span>]);<span class="comment">// 8&#x27;bxxxxxxxxx</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>Unpacked Array 的初始化</p>
<p><img src="/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_15-23-40.png"></p>
<p>顺序为：从左往右从低到高<br><img src="/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_15-24-38.png"></p>
<p><strong>混合使用： mixed Array</strong></p>
<p>举例：<br><img src="/2024/02/12/System-Verilog-Notes/image-37.png" alt="内存布局"></p>
<p>理解，每一行(连续的内存空间)，是一个[3:0][7:0]的packed array，而纵向是unpacked 的。<br>索引方式： unpacked 在前，packed在后。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-38.png" alt="Alt text"></p>
<p><strong>Packed Array 和Unpacked Array比较</strong>：</p>
<ol>
<li><p>Packed Array：</p>
<ol>
<li>紧凑存储：Packed array 的所有元素都是紧密排列的，没有间隙。这意味着整个数组可以被视为一个单一的、连续的位向量。</li>
<li><strong>位级操作</strong>：由于其连续的存储方式，可以对整个 packed array 进行位级操作，如位移、逻辑运算等。</li>
<li>定义方式：在声明数组时，packed 维度紧随数据类型之后。例如：bit [3:0] packedArray; 表示一个4位的 packed array。</li>
<li>应用场景：通常用于硬件建模，如总线接口、寄存器等，因为它们可以映射到硬件中的连续位。</li>
</ol>
</li>
<li><p>Unpacked Array：</p>
<ol>
<li>分散存储：Unpacked array 的元素在内存中可能是分散存储的，每个元素可以独立寻址。</li>
<li><strong>元素级操作</strong>：通常对 unpacked array 的操作是在元素级别进行的，如数组的遍历和单个元素的访问。</li>
<li>定义方式：在声明数组时，unpacked 维度跟在变量名之后。例如：int unpackedArray [10]; 表示一个有10个整数的 unpacked array。</li>
<li>应用场景：常用于表示复杂的数据结构，如队列、堆栈、记录等，以及在验证和建模过程中处理大量数据。</li>
</ol>
</li>
</ol>
<h3 id="quiz"><a href="#quiz" class="headerlink" title="quiz"></a>quiz</h3><ol>
<li><p>What is the basic difference between logic and reg?<br> logic的功能几乎完全取代reg和wire.因此区别主要在于，logic可以被连续赋值，而reg不行。</p>
</li>
<li><p>What is the difference between logic and bit?<br> 四值逻辑和二值逻辑的区别。</p>
</li>
<li><p>Should the 2-state variable be used with the DUT?<br>不行，二值逻辑不可综合，无法用于电路的建模</p>
</li>
</ol>
<h3 id="动态数组-Dynamic-Array"><a href="#动态数组-Dynamic-Array" class="headerlink" title="动态数组 Dynamic Array"></a>动态数组 Dynamic Array</h3><p>定义方式：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] nibble[]; <span class="comment">// Dynamic array of 4-bit vectors</span></span><br><span class="line"><span class="keyword">integer</span> mem[<span class="number">2</span>][]; <span class="comment">// Fixed-size unpacked array composed</span></span><br><span class="line"><span class="comment">// of 2 dynamic subarrays of integers</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Dynamic Array是unpacked的。</p>
<p>用法：本质是一个内置的对象类型，具有new,size,delete等方法。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test_da();</span><br><span class="line">    <span class="keyword">int</span> dyn[], d2[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    dyn=<span class="keyword">new</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (dyn[j]) dyn[j]=j;<span class="comment">//[0,1,2,3,4]</span></span><br><span class="line"></span><br><span class="line">    d2=dyn;</span><br><span class="line">    d2[<span class="number">0</span>]=<span class="number">5</span>; [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">$display</span>(dyn[<span class="number">0</span>],d2[<span class="number">0</span>]); <span class="comment">//0,5</span></span><br><span class="line">    dyn=<span class="keyword">new</span>[<span class="number">10</span>](dyn);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%p&quot;</span>,dyn);<span class="comment">//[0,1,2,3,4,0,0,0,0,0]  </span></span><br><span class="line">    dyn=<span class="keyword">new</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%p&quot;</span>,dyn);<span class="comment">//[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span></span><br><span class="line">    dyn<span class="variable">.delete</span>();</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot; %d&quot;</span>,dyn<span class="variable">.size</span>());  <span class="comment">//0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意以上2中new的区别，是用原来的array初始化还是重新初始化。</p>
<h3 id="关联数组-Associate-Array"><a href="#关联数组-Associate-Array" class="headerlink" title="关联数组 Associate Array"></a>关联数组 Associate Array</h3><p>语法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> name [*];</span><br></pre></td></tr></table></figure>

<p>用一个星号进行声明。</p>
<p>与动态数组的比较：<br><img src="/2024/02/12/System-Verilog-Notes/image-39.png" alt="Alt text"><br>可以分配稀疏的存储空间(本质是哈希表)，且索引形式更自由，支持任何形式数据类型的索引。</p>
<p>应用场景：</p>
<ol>
<li>存储稀疏数据：当数据集是非连续的或稀疏的，关联数组是一个理想的选择。</li>
<li>查找表：在需要快速查找的场景下，如实现映射或字典功能。</li>
<li>动态数据处理：在验证环境中，经常需要处理动态变化的数据集，关联数组在这方面非常有用。</li>
</ol>
<h3 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h3><p>语法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> name[$]</span><br></pre></td></tr></table></figure>

<p>参考C++的vector.<br>基础操作：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Size()</span><br><span class="line">Insert()</span><br><span class="line">Delete()</span><br><span class="line">Pop_front()</span><br><span class="line">Pop_back()</span><br><span class="line">Push_front()</span><br><span class="line">Push_back()</span><br></pre></td></tr></table></figure>

<h3 id="Array-Methods"><a href="#Array-Methods" class="headerlink" title="Array Methods:"></a>Array Methods:</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$left</span></span><br><span class="line"><span class="built_in">$right</span></span><br><span class="line"><span class="built_in">$low</span></span><br><span class="line"><span class="built_in">$high</span></span><br><span class="line"><span class="built_in">$increment</span></span><br><span class="line"><span class="built_in">$size</span></span><br><span class="line"><span class="built_in">$dimensions</span></span><br><span class="line"><span class="built_in">$unpacked_dimensions</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举-enumerated"><a href="#枚举-enumerated" class="headerlink" title="枚举 enumerated"></a>枚举 enumerated</h3><p>语法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;red, green, blue&#125; RGB</span><br></pre></td></tr></table></figure>
<p>枚举类型的特性：枚举中的每个变量是默认自增的，当人为定义各类型的值时，需要注意不能违背自增原则。<br><img src="/2024/02/12/System-Verilog-Notes/image-41.png" alt="Alt text"></p>
<h3 id="结构体-Structure"><a href="#结构体-Structure" class="headerlink" title="结构体 Structure"></a>结构体 Structure</h3><p>语法：类似C</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">    <span class="keyword">bit</span> error;</span><br><span class="line">&#125; Instruction_Word</span><br></pre></td></tr></table></figure>

<p>同时还有一种 packed的定义方式：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> valid;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] tag;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; data_word</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-42.png" alt="Alt text"></p>
<p>packed定义的结构体在内存上是连续的。<br>同时Packed 支持成员索引和按位索引：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_word<span class="variable">.tag</span> = <span class="number">8</span>’hf0;</span><br><span class="line">data_word [<span class="number">39</span>:<span class="number">32</span>]=<span class="number">8</span>’hf0;</span><br></pre></td></tr></table></figure>

<h2 id="System-Verilog-Programming-Basic-I"><a href="#System-Verilog-Programming-Basic-I" class="headerlink" title="System Verilog Programming Basic I"></a>System Verilog Programming Basic I</h2><h3 id="verilog-style"><a href="#verilog-style" class="headerlink" title="verilog style"></a>verilog style</h3><p>一个常见的状态机的写法：  </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fsm1a (ds, rd, go, ws, clk, rst_n);</span><br><span class="line"><span class="keyword">output</span> ds, rd;</span><br><span class="line"><span class="keyword">input</span> go, ws,clk, rst_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">1</span>:<span class="number">0</span>] IDLE = <span class="number">2&#x27;b00</span>,READ = <span class="number">2&#x27;b01</span>,DLY =<span class="number">2&#x27;b10</span>,DONE = <span class="number">2&#x27;b11</span>;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] state, next;<span class="comment">//reg也可用于描述组合逻辑</span></span><br><span class="line"><span class="keyword">wire</span> rd, ds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) </span><br><span class="line">        state &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        state &lt;= next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(state <span class="keyword">or</span> go <span class="keyword">or</span> ws) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (state)</span><br><span class="line">        IDLE: <span class="keyword">if</span> (go) next = READ;</span><br><span class="line">            <span class="keyword">else</span> next = IDLE;</span><br><span class="line">        READ: next = DLY;</span><br><span class="line">        DLY: <span class="keyword">if</span> (ws) next = READ;</span><br><span class="line">            <span class="keyword">else</span> next = DONE;</span><br><span class="line">        DONE: next = IDLE;</span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> rd = (state==READ || state==DLY);</span><br><span class="line"><span class="keyword">assign</span> ds = (state==DONE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>SV中对端口的数据类型不做限制</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p><code>== !=</code>逻辑判断<br>当x或z参与比较时，返回x</p>
<p><code>=== !==</code><br>将x或z当成独立的状态进行比较</p>
<p><code>==?  !=?</code><br>通配操作，对右边的操作数放宽比较的限制。在通配中，右边的x和z会被忽略。左边有x或z则结果直接变成x。<br><img src="/2024/02/12/System-Verilog-Notes/image-44.png" alt="Alt text"><br>example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test_wildcard();</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] a, b,c;</span><br><span class="line">    <span class="keyword">logic</span> le1,le2,ce1,ce2,we1,we2,we3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    a=<span class="number">4&#x27;b010z</span>;</span><br><span class="line">    b=<span class="number">4&#x27;b0101</span>;</span><br><span class="line">    c=<span class="number">4&#x27;b010z</span>;</span><br><span class="line"></span><br><span class="line">    le1=(a==b);</span><br><span class="line">    le2=(a==c);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%b,%b&quot;</span>,le1,le2); <span class="comment">//#x,x</span></span><br><span class="line"></span><br><span class="line">    ce1=(a===b);</span><br><span class="line">    ce2=(a===c);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%b,%b&quot;</span>,ce1,ce2);<span class="comment">//#0,1</span></span><br><span class="line"></span><br><span class="line">    we1=(a==?b);</span><br><span class="line">    we2=(b==?a);</span><br><span class="line">    we3=(a==?c);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%b,%b,%b&quot;</span>,we1,we2,we3);<span class="comment">//#x,1,1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h4 id="递增、递减"><a href="#递增、递减" class="headerlink" title="递增、递减"></a>递增、递减</h4><p><code>++  --</code></p>
<p><code>+=  -=</code></p>
<p>注意：+&#x3D;是一种阻塞赋值。</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> test();</span><br><span class="line"><span class="keyword">int</span> dat0,dat1,dat00,dat01,dat02,dat10,dat11,dat12;<span class="comment">//默认值为0</span></span><br><span class="line"><span class="keyword">bit</span> tik=<span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">bit</span> clk;</span><br><span class="line"><span class="keyword">always</span> #<span class="number">1</span> clk=!clk;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat00 &lt;= dat0 + tik; <span class="comment">// 1</span></span><br><span class="line">    dat0 = dat0 + tik; <span class="comment">// 1  (阻塞语句优先执行)</span></span><br><span class="line">    dat01 &lt;= dat0 + tik; <span class="comment">// 2</span></span><br><span class="line">    dat02 &lt;= dat01 + tik; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat10 &lt;= dat1 + tik; <span class="comment">// 1</span></span><br><span class="line">    dat1 += tik; <span class="comment">// 1</span></span><br><span class="line">    dat11 &lt;= dat1 + tik; <span class="comment">// 2</span></span><br><span class="line">    dat12 &lt;= dat11 + tik; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>即 <code>a+=b</code>和<code>a = a+b</code>的效果完全相同。</p>
<p>example</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> test();</span><br><span class="line"><span class="keyword">int</span> dat0,dat1,dat3,dat30,dat31;</span><br><span class="line"><span class="keyword">int</span> tik0,tik1,tik3;</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat0 =tik0++;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;dat0=%d,tik0=%d&quot;</span>,dat0,tik0); <span class="comment">//0, 1</span></span><br><span class="line">    dat1=++tik1;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;dat1=%d,tik1=%d&quot;</span>,dat1,tik1); <span class="comment">//1, 1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat30&lt;=tik3;</span><br><span class="line">    dat3 =++tik3;</span><br><span class="line">    dat31&lt;=tik3;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;dat30=%d,dat3=%d,dat31=%d,tik3=%d&quot;</span>,</span><br><span class="line">    dat30,dat3,dat31,tik3); <span class="comment">// 0,  1,  0(实际上是1),   1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="comment">//display语句比非阻塞赋值的执行要早。</span></span><br></pre></td></tr></table></figure>

<h4 id="inside"><a href="#inside" class="headerlink" title="inside"></a>inside</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] a;</span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">inside</span> &#123;<span class="number">3</span>’b001, <span class="number">3</span>’b010, <span class="number">3</span>’b100&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//与下面的写法等价：</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] a;</span><br><span class="line"><span class="keyword">if</span> ((a==?<span class="number">3</span>’b001)||(a==?<span class="number">3</span>’b010)||(a==?<span class="number">3</span>’b100))</span><br></pre></td></tr></table></figure>
<p>顾名思义，inside用于检查一个变量是否在一个集合中。<br>inside可用于随机数生成。</p>
<p>同时, inside 可以用作通配操作：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> r;</span><br><span class="line"><span class="keyword">assign</span> r=<span class="number">3&#x27;bz11</span> <span class="keyword">inside</span> &#123;<span class="number">3&#x27;b1</span>?<span class="number">1</span>, <span class="number">3&#x27;b011</span>&#125;; <span class="comment">// r = 1&#x27;bx</span></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> r = (<span class="number">3&#x27;bz11</span>==?<span class="number">3&#x27;b1</span>?<span class="number">1</span> || <span class="number">3&#x27;bz11</span>==?<span class="number">3&#x27;b011</span> )</span><br></pre></td></tr></table></figure>

<h4 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h4><p>产生某种统计分布</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> distribution ();</span><br><span class="line">    <span class="keyword">class</span> frame_t;</span><br><span class="line">        <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">constraint</span> len &#123;</span><br><span class="line">        length <span class="keyword">dist</span> &#123;</span><br><span class="line">        [<span class="number">0</span>:<span class="number">7</span>] := <span class="number">8</span>,</span><br><span class="line">        [<span class="number">8</span>:<span class="number">15</span>] := <span class="number">8</span>,</span><br><span class="line">        [<span class="number">16</span>:<span class="number">31</span>] := <span class="number">16</span>&#125;;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="keyword">void</span> post_randomize();</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;length : %d&quot;</span>,length);</span><br><span class="line">        <span class="keyword">endfunction</span> </span><br><span class="line">    <span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    frame_t frame = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">integer</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j &lt; <span class="number">32</span>; j++)</span><br><span class="line">        i = frame<span class="variable">.randomize</span>();</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-5.png" alt="Alt text"></p>
<h4 id="streaming"><a href="#streaming" class="headerlink" title="streaming"></a>streaming</h4><p><code>&#123;&lt;&lt;&#123;&#125;&#125;     &#123;&gt;&gt;&#123;&#125;&#125;</code></p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> streaming();</span><br><span class="line"><span class="keyword">int</span> j = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Value of j %0x&quot;</span>,j);</span><br><span class="line">    <span class="built_in">$monitor</span>(<span class="string">&quot;@%0dns stream value is %x&quot;</span>,<span class="built_in">$time</span>, stream);</span><br><span class="line">    #<span class="number">1</span> stream = &#123; &gt;&gt; &#123;j&#125;&#125;; <span class="comment">// generates stream &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot;</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="keyword">byte</span> &#123;j&#125;&#125;; <span class="comment">// generates stream &quot;D&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; (little endian)</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="number">16</span> &#123;j&#125;&#125;; <span class="comment">// generates stream &quot;C&quot; &quot;D&quot; &quot;A&quot; &quot;B&quot;</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; &#123; <span class="number">8&#x27;b0011_0101</span> &#125;&#125;; <span class="comment">// generates stream &#x27;b1010_1100 (bit reverse)</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="number">4</span> &#123; <span class="number">6&#x27;b11_0101</span> &#125;&#125;; <span class="comment">// generates stream &#x27;b0101_11</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &gt;&gt; <span class="number">4</span> &#123; <span class="number">6&#x27;b11_0101</span> &#125;&#125;; <span class="comment">// generates stream &#x27;b1101_01</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="number">2</span> &#123; &#123; &lt;&lt; &#123; <span class="number">4&#x27;b1101</span> &#125;&#125; &#125;&#125;; <span class="comment">// generates stream &#x27;b1110</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-6.png" alt="Alt text"></p>
<h4 id="casting-固定-强制类型转换"><a href="#casting-固定-强制类型转换" class="headerlink" title="casting  固定(强制类型转换)"></a>casting  固定(强制类型转换)</h4><p>具体操作：</p>
<p><code>type’ (expression)</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">longint</span> a,y;</span><br><span class="line"><span class="keyword">real</span> r;</span><br><span class="line">y=a+<span class="keyword">longint</span>’(r**<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>宽度、符号位等也可以进行固定。</p>
<h4 id="Assignment-赋值"><a href="#Assignment-赋值" class="headerlink" title="Assignment 赋值"></a>Assignment 赋值</h4><p>阻塞赋值、非阻塞赋值</p>
<p>不同的电路描述方式会产生不同的电路：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline1(clk,d,q);</span><br><span class="line">    <span class="keyword">input</span> clk,d;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span> q1,q2,q3;</span><br><span class="line">    <span class="keyword">wire</span> clk,d,q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        q1=d;</span><br><span class="line">        q2=q1;</span><br><span class="line">        q3=q2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> q=q3;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>对应的电路：<br><img src="/2024/02/12/System-Verilog-Notes/image-45.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline1(clk,d,q);</span><br><span class="line">    <span class="keyword">input</span> clk,d;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span> q1,q2,q3;</span><br><span class="line">    <span class="keyword">wire</span> clk,d,q;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        q1&lt;=d;</span><br><span class="line">        q2&lt;=q1;</span><br><span class="line">        q3&lt;=q2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> q=q3;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-46.png" alt="Alt text"></p>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p><code>if else</code>    </p>
<p>注意<strong>if else要讨论清楚所有情况。</strong></p>
<p><code>case</code></p>
<p><code>casez</code><br>忽略z状态</p>
<p><code>casex</code><br>忽略x和z状态</p>
<p>当多个分支同时满足条件时，case只选择第一个分支。(即case存在优先级)</p>
<p><code>unique</code> 和 <code>priority</code>用在分支语句之前</p>
<p><strong>unique</strong>会对分支条件有重叠（overlap）或分支不全的情况进行报警。unique 用于 if-else 或 case 语句，以指示只有一个条件或分支应该为真。如果多个条件或分支同时为真，这通常被视为编码错误，可能会在仿真时产生警告或错误。</p>
<p><strong>priority</strong>确保了条件或分支的评估顺序，即使有多个条件或分支为真，也只有第一个为真的会被执行。<br>priority 有助于防止条件重叠时的不确定行为。</p>
<p>举例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> unique_if;</span><br><span class="line"><span class="comment">//variables declaration</span></span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//initialization</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    b=<span class="number">20</span>;</span><br><span class="line">    c=<span class="number">40</span>;</span><br><span class="line">    <span class="keyword">unique</span> <span class="keyword">if</span> ( a &lt; b ) <span class="built_in">$display</span>(<span class="string">&quot;\t a is less than b&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( a &lt; c ) <span class="built_in">$display</span>(<span class="string">&quot;\t a is less than c&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">$display</span>(<span class="string">&quot;\t a is greater than b and c&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-47.png" alt="Alt text"><br>仿真时报错。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test_priority();</span><br><span class="line"><span class="keyword">initial</span> </span><br><span class="line">    <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>;a&lt;<span class="number">4</span>;a++) </span><br><span class="line">    <span class="keyword">priority</span> <span class="keyword">casez</span>(a) <span class="comment">// values 4,5,6,7 </span></span><br><span class="line">        cause a warning </span><br><span class="line">        <span class="number">3&#x27;b00</span>?: <span class="built_in">$display</span>(<span class="string">&quot;0 or 1&quot;</span>); </span><br><span class="line">        <span class="number">3&#x27;b0</span>??: <span class="built_in">$display</span>(<span class="string">&quot;2 or 3&quot;</span>); </span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-48.png" alt="Alt text"></p>
<h4 id="过程块-procedural-statements"><a href="#过程块-procedural-statements" class="headerlink" title="过程块 procedural statements"></a>过程块 procedural statements</h4><p><strong>initial</strong><br>    用途： 指示仿真的开始。可以同时存在多个initial并行。</p>
<p><strong>final</strong><br>类似initial，其中定义的行为在仿真结束后执行，用于在仿真结束后收集信息。同时，<strong>final中不能定义延迟。</strong></p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">begin</span></span><br><span class="line"><span class="built_in">$display</span> (“Final value of Data = %h <span class="string">&quot;, data);</span></span><br><span class="line"><span class="string">data = 1; // even assignments can be done</span></span><br><span class="line"><span class="string">$display (&quot;</span> Final value of Data = %h <span class="string">&quot;, data);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">final $display (&quot;</span>display <span class="keyword">final</span> block <span class="number">1</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">final $display (&quot;</span>display <span class="keyword">final</span> block <span class="number">2</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">final $display (&quot;</span>display <span class="keyword">final</span> block <span class="number">3</span> <span class="string">&quot;);</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-7.png" alt="Alt text"></p>
<p>区别在于，final中不能添加任何delay语句(#delay)   </p>
<p><strong>always</strong><br>在verilog中：<br> always @(*)<br> always @(posedge clk)<br> always @(clk)<br> always  </p>
<p>sv 新增：always_ff&#x2F;always_comb&#x2F;always_latch</p>
<p>SV将组合逻辑、时序逻辑和latch严格区分。  </p>
<p>数字设计时，需要避免latch和组合逻辑环。</p>
<h4 id="Loop-循环"><a href="#Loop-循环" class="headerlink" title="Loop 循环"></a>Loop 循环</h4><p><strong>forever</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">clock1 &lt;= <span class="number">0</span>;</span><br><span class="line">clock2 &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">fork</span></span><br><span class="line">    <span class="keyword">forever</span> #<span class="number">10</span> clock1 = ~clock1;</span><br><span class="line">    #<span class="number">5</span> <span class="keyword">forever</span> #<span class="number">10</span> clock2 = ~clock2;</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>for 循环</strong>：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">1024</span>; i=i+<span class="number">1</span>)</span><br><span class="line">…</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>sv和verilog的区别在于，sv可以运行循环控制变量i在循环内部定义(接近c语言的风格)</p>
<p><strong>foreach</strong><br>sv新增，面向对象特性。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">string</span> words [<span class="number">2</span>] = &#x27;&#123; <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> prod [<span class="number">1</span>:<span class="number">8</span>] [<span class="number">1</span>:<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">foreach</span>( words [ j ] )</span><br><span class="line"><span class="built_in">$display</span>( j , words[j] ); <span class="comment">// print each index and value</span></span><br><span class="line">    <span class="keyword">foreach</span>( prod[ k, m ] )</span><br><span class="line">    prod[k][m] = k * m; <span class="comment">// initializ</span></span><br></pre></td></tr></table></figure>

<p>很灵活，可以直接用索引代指变量</p>
<p><strong>while&#x2F;do while</strong></p>
<p><strong>break</strong></p>
<p><strong>repeat</strong></p>
<h4 id="functions-and-tasks-SV的重点"><a href="#functions-and-tasks-SV的重点" class="headerlink" title="functions and tasks(SV的重点)"></a>functions and tasks(SV的重点)</h4><p>task:执行需要时间</p>
<p>function: 被看作瞬时完成，不能有延时操作。</p>
<p>task可以调用function,task不能调用function</p>
<p>function只能有1个返回值，task可以通过output产生多个返回值。task不能写return.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> foo(loo);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] loo;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] goo = zero_count(loo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> [<span class="number">3</span>:<span class="number">0</span>] zero_count;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] in_bus;</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            zero_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i= i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (!in_bus[i])</span><br><span class="line">            zero_count = zero_count +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add_and_inc (<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a,b);</span><br><span class="line">    add_and_inc=a+b+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> add ( <span class="keyword">byte</span> a , b );</span><br><span class="line">    val = a + b ;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    add (<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">$display</span> (val); <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>函数值被看作默认的返回值。</p>
<h4 id="变量的静态和动态-static-automatic"><a href="#变量的静态和动态-static-automatic" class="headerlink" title="变量的静态和动态(static&#x2F;automatic)"></a>变量的静态和动态(static&#x2F;automatic)</h4><p>动态：局部的变量<br>静态：全局共享</p>
<p>task 和 function默认是静态的。</p>
<h4 id="SV-的参数传递"><a href="#SV-的参数传递" class="headerlink" title="SV 的参数传递"></a>SV 的参数传递</h4><p>1.<strong>传值</strong><br>    例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add (<span class="keyword">byte</span> a , b );</span><br><span class="line"><span class="keyword">return</span> a + b ;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>2.<strong>传引用</strong><br>    被传递的参数可以在函数中修改（类似C语言的&amp;augment)  </p>
<p>在变量名前面加上关键字<code>ref</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> argument_passing1;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> sum(<span class="keyword">ref</span> <span class="keyword">int</span> x,y);</span><br><span class="line">    x = x+y;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    y = <span class="number">30</span>;</span><br><span class="line">    z = sum(x,y);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;\tValue of x = %0d&quot;</span>,x);<span class="comment">//50</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;\tValue of y = %0d&quot;</span>,y);<span class="comment">//30</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;\tValue of z = %0d&quot;</span>,z);<span class="comment">//80</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>3.<strong>默认参数</strong></p>
<p>例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> add ( <span class="keyword">int</span> a =<span class="number">1</span>; <span class="keyword">int</span> b; <span class="keyword">int</span> c=<span class="number">3</span>);</span><br><span class="line">… …</span><br><span class="line">    add ( ,<span class="number">2</span>, ); <span class="comment">//equivalent to add (1,2,3);</span></span><br><span class="line">    add ( <span class="number">4</span>,<span class="number">2</span>, ); <span class="comment">//equivalent to add (4,2,3);</span></span><br><span class="line">    add ( ); <span class="comment">//error ; b value missing !</span></span><br></pre></td></tr></table></figure>


<h3 id="quiz-1"><a href="#quiz-1" class="headerlink" title="quiz"></a>quiz</h3><ol>
<li>Why a function cannot call a task?</li>
</ol>
<p>• Because of the timing delays allowed in task; Non-Zero time !</p>
<ol start="2">
<li><p>Tasks not synthesizable ?<br>• Timing delays ! However THEY ARE SYNTHESIZABLE if no timing<br>delays inferred</p>
</li>
<li><p>A function should return a value?<br>• Not necessarily !</p>
</li>
<li><p>Why a task cannot return a value?<br>• Same reason, Timing Delays.</p>
</li>
<li><p>Why a function cannot have delays?<br>• Function caller is waiting for a Zero time event</p>
</li>
<li><p>Why disable statements are not allowed in functions?<br>• A prior disable statement may by-pass return statements at the end of<br>function</p>
</li>
</ol>
<h2 id="System-Verilog-Programming-Basic-II"><a href="#System-Verilog-Programming-Basic-II" class="headerlink" title="System Verilog Programming Basic II"></a>System Verilog Programming Basic II</h2><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>主要用途：用作端口通信。可以在其中实现一些比较复杂的通信协议。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-8.png" alt="Alt text"></p>
<p>driver:驱动端，负责数据的产生</p>
<p>传统方法:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> arb_port (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] grant,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] request,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> reset,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk</span><br><span class="line">    );</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] grant,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] request,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> reset,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk</span><br><span class="line">    );</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] grant,request;</span><br><span class="line">    <span class="keyword">logic</span> clk, reset;</span><br><span class="line">    arb_port a1(<span class="variable">.grant</span>(grant), <span class="variable">.request</span>(request), <span class="variable">.reset</span>(reset), <span class="variable">.clk</span>(clk));</span><br><span class="line">    test t1(<span class="variable">.grant</span>(grant), <span class="variable">.request</span>(request), <span class="variable">.reset</span>(reset), <span class="variable">.clk</span>(clk));</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>


<h3 id="使用interface"><a href="#使用interface" class="headerlink" title="使用interface:"></a>使用interface:</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> simple_bus;</span><br><span class="line">    <span class="keyword">logic</span> req,gnt,start,rdy ;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] mode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] addr,data;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mem_mod ( <span class="keyword">input</span> <span class="keyword">bit</span> clk,simple_bus busa);</span><br><span class="line"><span class="comment">//注意，此时module的输入不止是单一的信号，而是可以包含整个interface</span></span><br><span class="line">    <span class="keyword">logic</span> sel_mem = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        busa<span class="variable">.gnt</span> &lt;= busa<span class="variable">.req</span> &amp; sel_mem;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cpu_mod ( <span class="keyword">input</span> <span class="keyword">bit</span> clk,simple_bus busa);</span><br><span class="line">    <span class="keyword">logic</span> sel_cpu;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        busa<span class="variable">.mode</span> &lt;= &#123;busa<span class="variable">.gnt</span>, busa<span class="variable">.gnt</span>&#125;;</span><br><span class="line">        busa<span class="variable">.req</span> &lt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top_mod1;</span><br><span class="line">    <span class="keyword">logic</span> clk = <span class="number">0</span>;</span><br><span class="line">    simple_bus sb( );</span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line">    cpu_mod1 cpu (clk, sb);</span><br><span class="line">    mem_mod1 mem (clk, sb);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Interface-可以包含端口。"><a href="#Interface-可以包含端口。" class="headerlink" title="Interface 可以包含端口。"></a>Interface 可以包含端口。</h3><h3 id="Modport-对Interface的端口方向进行限制"><a href="#Modport-对Interface的端口方向进行限制" class="headerlink" title="Modport:对Interface的端口方向进行限制"></a>Modport:对Interface的端口方向进行限制</h3><p>modport 同时还可以对信号进行分组。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> simple_bus (<span class="keyword">input</span> <span class="keyword">bit</span> clk) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> req, gnt, start, rdy ; <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] mode;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] addr; <span class="keyword">logic</span> [<span class="number">16</span>:<span class="number">0</span>] data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">modport</span> master ( <span class="keyword">input</span>,req,gnt,clk,mode,addr,<span class="keyword">output</span> data, start,</span><br><span class="line">rdy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">modport</span> slave (<span class="keyword">output</span> req,gnt,mode,addr,<span class="keyword">input</span> data, start, rdy);</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mem (simple_bus mbus);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cpu (simple_bus sbus);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top;</span><br><span class="line">    simple_bus busa();</span><br><span class="line">    mem mem_i (<span class="variable">.mbus</span> (busa<span class="variable">.master</span>));</span><br><span class="line">    cpu cpu_i (<span class="variable">.sbus</span> (busa<span class="variable">.slave</span>));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>


<h3 id="Interface中可以申明或调用task-和-function"><a href="#Interface中可以申明或调用task-和-function" class="headerlink" title="Interface中可以申明或调用task 和 function"></a>Interface中可以申明或调用task 和 function</h3><p>使用<code>import</code>,<code>export</code>来调用task。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-9.png" alt="Alt text"></p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-10.png" alt="Alt text"></p>
<p>区分：<br>import: module调用Interface中的task;<br>export: Interface中调用module中的task.  </p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tlm_sender (tlm_intf<span class="variable">.sender_mp</span> send_port);</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    send_port<span class="variable">.put</span>(<span class="string">&quot;n&quot;</span>);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tlm_receiver (tlm_intf<span class="variable">.receiver_mp</span> receive_port);</span><br><span class="line">    <span class="keyword">task</span> receive_port<span class="variable">.put</span>(<span class="keyword">input</span> <span class="keyword">byte</span> b);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;i got data =%0d&quot;</span>,b);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> tlm_intf();</span><br><span class="line">    <span class="keyword">modport</span> sender_mp(<span class="keyword">import</span> <span class="keyword">task</span> put(<span class="keyword">input</span> <span class="keyword">byte</span> b));<span class="comment">//注意import和export的用法。</span></span><br><span class="line">    <span class="keyword">modport</span> receiver_mp(<span class="keyword">export</span> <span class="keyword">task</span> put(<span class="keyword">input</span> <span class="keyword">byte</span> b));</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line">tlm_intf tlm_int0();</span><br><span class="line">tlm_sender tlm_sender0(tlm_int0<span class="variable">.sender_mp</span>);</span><br><span class="line">tlm_receiver tlm_receiver0(tlm_int0<span class="variable">.receiver_mp</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="带参数的Interface"><a href="#带参数的Interface" class="headerlink" title="带参数的Interface"></a>带参数的Interface</h3><p>Interface中可包含参数，用法和module中的参数一样。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> simple_bus <span class="variable">#(dwidth =32, awidth = 8) ( input bit clk )</span>;</span><br><span class="line">    <span class="keyword">logic</span> req,gnt,start,rdy ;</span><br><span class="line">    <span class="keyword">logic</span> [dwidth :<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">logic</span> [awidth:<span class="number">0</span>] addr;</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>


<h3 id="Virtual-Interface"><a href="#Virtual-Interface" class="headerlink" title="Virtual Interface"></a>Virtual Interface</h3><p>Interface作为一个特殊的类，无法在其他类的定义中进行例化。当在一个类中使用interface时，该interface必须被申明为virtual。<br><img src="/2024/02/12/System-Verilog-Notes/image-21.png" alt="Alt text"><br>virtual interface可以看作指向模块中实例化的interface的一个指针。</p>
<p>用法举例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个interface</span></span><br><span class="line"><span class="keyword">interface</span> my_if(<span class="keyword">input</span> clk, <span class="keyword">input</span> rst_n);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line">   <span class="keyword">logic</span> valid;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个UVM driver.</span></span><br><span class="line"><span class="keyword">class</span> my_driver <span class="keyword">extends</span> uvm_driver;</span><br><span class="line">    <span class="comment">//申明一个virtual interface</span></span><br><span class="line">   <span class="keyword">virtual</span> my_if vif;</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_driver)</span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">      `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;new is called&quot;</span>, UVM_LOW);</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">      `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;build_phase is called&quot;</span>, UVM_LOW);</span><br><span class="line">      <span class="comment">//virtual interface使用前必须被设置，类似指针必须赋值后使用</span></span><br><span class="line">      <span class="comment">//使用get函数，进程在调用时，将&quot;vif&quot;的值赋值给vif。</span></span><br><span class="line">      <span class="keyword">if</span>(!uvm_config_db<span class="variable">#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span></span><br><span class="line">         `uvm_fatal(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;virtual interface must be set for vif!!!&quot;</span>)</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> main_phase(uvm_phase phase);</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   phase<span class="variable">.raise_objection</span>(<span class="keyword">this</span>);</span><br><span class="line">   `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;main_phase is called&quot;</span>, UVM_LOW);</span><br><span class="line">   vif<span class="variable">.data</span> &lt;= <span class="number">8&#x27;b0</span>; </span><br><span class="line">   vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!vif<span class="variable">.rst_n</span>)</span><br><span class="line">      @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)<span class="keyword">begin</span></span><br><span class="line">      @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">      vif<span class="variable">.data</span> &lt;= $urandom_range(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">      vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">      `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;data is drived&quot;</span>, UVM_LOW);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">   vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">   phase<span class="variable">.drop_objection</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_if.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_driver.sv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top_tb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"><span class="keyword">reg</span> rst_n;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] rxd;</span><br><span class="line"><span class="keyword">reg</span> rx_dv;</span><br><span class="line"><span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] txd;</span><br><span class="line"><span class="keyword">wire</span> tx_en;</span><br><span class="line"><span class="comment">//例化两个interface</span></span><br><span class="line">my_if input_if(clk, rst_n);</span><br><span class="line">my_if output_if(clk, rst_n);</span><br><span class="line"></span><br><span class="line">dut my_dut(<span class="variable">.clk</span>(clk),</span><br><span class="line">           <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">           <span class="variable">.rxd</span>(input_if<span class="variable">.data</span>),</span><br><span class="line">           <span class="variable">.rx_dv</span>(input_if<span class="variable">.valid</span>),</span><br><span class="line">           <span class="variable">.txd</span>(output_if<span class="variable">.data</span>),</span><br><span class="line">           <span class="variable">.tx_en</span>(output_if<span class="variable">.valid</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">   clk = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">      #<span class="number">100</span> clk = ~clk;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">   rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">   #<span class="number">1000</span>;</span><br><span class="line">   rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//通过run_test例化了一个&quot;my driver&quot;</span></span><br><span class="line">   run_test(<span class="string">&quot;my_driver&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//设置虚拟端口的指向。使用的是UMV中的config_db操作，通过进程间通信的方式，将&quot;vif&quot;指向input_if</span></span><br><span class="line">   uvm_config_db<span class="variable">#(virtual my_if)::set(null, &quot;uvm_test_top&quot;, &quot;vif&quot;, input_if)</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h3><p>在设计中，顶层模块是一个module,在验证中，为了构建某种仿真环境，设计出program。program的目的是将testbench与DUT独立开来。</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> test (<span class="keyword">input</span> clk, <span class="keyword">input</span> [<span class="number">16</span>:<span class="number">1</span>]</span><br><span class="line">    addr, <span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data);</span><br><span class="line">    <span class="keyword">initial</span> ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p>program与module的关系：<br>module中可以例化program,反之program不能例化module</p>
<p>program中不需要always块，例化module，申明interface,或申明其他program。只有initial和methods是允许的。</p>
<h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h3><p>目的：通过Package在不同module之间来共享代码。</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pack;</span><br><span class="line">    <span class="keyword">integer</span> global_counter ;</span><br><span class="line">    <span class="keyword">task</span> incr ;</span><br><span class="line">    … …</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endpackage</span> : pack</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mod1;</span><br><span class="line">    <span class="keyword">import</span> pack::* ;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    global_counter = <span class="number">567</span> ;</span><br><span class="line">    incr(); <span class="comment">// use as if it is locally</span></span><br><span class="line">    declared</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> : mod1</span><br></pre></td></tr></table></figure>

<h3 id="Clocking-block"><a href="#Clocking-block" class="headerlink" title="Clocking block"></a>Clocking block</h3><p>目的：调整数据和时钟的关系，使其满足建立时间和保持时间</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">clocking</span> cb1 @(<span class="keyword">posedge</span> clk); <span class="comment">// clocking block with clocking event</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">10</span>ns <span class="comment">//输入信号在翻转前10ns进行采样</span></span><br><span class="line">    <span class="keyword">output</span> #<span class="number">2</span>ns ; <span class="comment">// default timing skew for input/output，</span></span><br><span class="line">    <span class="comment">//输出信号在翻转后2ns开始输出</span></span><br><span class="line">    <span class="keyword">output</span> data; <span class="comment">// output from the clocking block</span></span><br><span class="line">    <span class="keyword">output</span> sel;</span><br><span class="line"><span class="keyword">endclocking</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-50.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] a0,a2, a3, a4; <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] a1;</span><br><span class="line"><span class="keyword">logic</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">clk=<span class="number">0</span>; <span class="keyword">for</span>( <span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) clk = #<span class="number">5</span> ~clk;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">for</span>( <span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) a1 = #<span class="number">2</span> ~a1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clocking</span> cb @(<span class="keyword">posedge</span> clk);</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">2</span> <span class="keyword">output</span> #<span class="number">3</span>;</span><br><span class="line"><span class="keyword">input</span> #<span class="number">2</span> a1;</span><br><span class="line"><span class="keyword">output</span> a0,a2 , a3 ;</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">negedge</span> a4;</span><br><span class="line"><span class="keyword">endclocking</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    @(cb);</span><br><span class="line">    cb<span class="variable">.a2</span> &lt;= <span class="number">3&#x27;b11</span>;</span><br><span class="line">    cb<span class="variable">.a4</span> &lt;= <span class="number">3&#x27;b10</span>;</span><br><span class="line">    cb<span class="variable">.a3</span> &lt;= a1;</span><br><span class="line">    cb<span class="variable">.a0</span> &lt;= cb<span class="variable">.a1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Race"><a href="#Race" class="headerlink" title="Race"></a>Race</h3><p>Two expressions scheduled to execute at same time, if order<br>of the execution is not determined, race condition occurs !</p>
<p>使用串行仿真器处理并行语言时遇到的困境。</p>
<p>想要避免race,需要理解仿真器对不同操作的<strong>调度顺序</strong></p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-12.png" alt="Alt text"></p>
<h2 id="LEC-8-面向对象设计"><a href="#LEC-8-面向对象设计" class="headerlink" title="LEC 8 面向对象设计"></a>LEC 8 面向对象设计</h2><p>为什么采用面向对象来构建testbench？</p>
<p>1.用于集成一些不同的数据类型。<br>2.提高可重用性，提升效率。<br>3.UVM&#x2F;OVM是基于OOP的。</p>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>类：包含一组数据类型和对应的操作方法(task和function)<br>对象：对象是类的一个例化。</p>
<p>类在定义时不占用内存。当对应的对象被例化时才占用。</p>
<h4 id="HDL与OOP的比较："><a href="#HDL与OOP的比较：" class="headerlink" title="HDL与OOP的比较："></a>HDL与OOP的比较：</h4><p><img src="/2024/02/12/System-Verilog-Notes/image-13.png" alt="Alt text"></p>
<h4 id="一个class的例子："><a href="#一个class的例子：" class="headerlink" title="一个class的例子："></a>一个class的例子：</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet ;</span><br><span class="line"><span class="comment">//data or class properties</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] command;</span><br><span class="line">    <span class="keyword">integer</span> time_requested;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; ERR_OVERFLOW= <span class="number">10</span>, ERR_UNDERFLOW = <span class="number">1123</span>&#125; PCKT_TYPE;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">integer</span> buffer_size = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        command = <span class="number">4&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="comment">// methods</span></span><br><span class="line">    <span class="keyword">task</span> clean();</span><br><span class="line">        command = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> issue_request( <span class="keyword">int</span> delay );</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">integer</span> current_status();</span><br><span class="line">        current_status = status;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h4 id="null类型"><a href="#null类型" class="headerlink" title="null类型"></a>null类型</h4><p>未被初始化的类型默认为null值(类似C++)</p>
<p>对象名被看作是对所分配内存的指针(或句柄(handle))</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BusTran;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, crc, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">function</span> calc_crc;</span><br><span class="line">        calc_crc=addr^data;</span><br><span class="line">        endfuntion: calc_crc</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> display;</span><br><span class="line">        <span class="built_in">$display</span>(“BusTran: %h”, addr);</span><br><span class="line">    <span class="keyword">endfunction</span>:  display</span><br><span class="line"><span class="keyword">endclass</span>: BusTran</span><br><span class="line"></span><br><span class="line">BusTran b1,b2;</span><br><span class="line">    b1= <span class="keyword">new</span>();<span class="comment">//开辟新的空间</span></span><br><span class="line">    b2=b1;  <span class="comment">//b2指向上一步开辟的空间</span></span><br><span class="line">    b1 = <span class="keyword">new</span>(); <span class="comment">//b1指向新的空间</span></span><br><span class="line">    b1<span class="variable">.addr</span>=<span class="number">32</span>’h42;</span><br><span class="line">    b1<span class="variable">.display</span>();</span><br><span class="line">b2 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>


<p>class 中的方法只有<strong>function</strong>和<strong>task</strong></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line"><span class="keyword">integer</span> command;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">    command = IDLE;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>内建的构造函数命名为new。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> my_class;</span><br><span class="line">    <span class="keyword">integer</span> count ;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span> ();</span><br><span class="line">        count = <span class="number">5</span> ;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">my_class c1 = <span class="keyword">new</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my_class;</span><br><span class="line">    <span class="keyword">integer</span> count ;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">input</span> <span class="keyword">int</span> temp);</span><br><span class="line">        count = temp ;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line">my_class c1 = <span class="keyword">new</span> (<span class="number">44</span>) ;</span><br></pre></td></tr></table></figure>
<p>区分new()和new[]:<br>分别用于类和数组。</p>
<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>用途：在不同对象之间建立联系。相当于class中的公共空间。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        id = count++;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction b1,b2;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    b1=<span class="keyword">new</span>; <span class="comment">//first instance, id=0</span></span><br><span class="line">    b2=<span class="keyword">new</span>; <span class="comment">//second instance, id=1</span></span><br><span class="line">    <span class="built_in">$display</span>(b2<span class="variable">.id</span>, b2<span class="variable">.count</span>);<span class="comment">//1,2;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>也可以定义 static的方法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">function</span> <span class="keyword">int</span> next_id();</span><br><span class="line">        next_id = ++current; <span class="comment">// OK to access static class property</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>对static方法的每次调用都会独立的执行一次该方法。example:</p>
<p>static 方法中的变量仍然是动态的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A ;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">task</span> incr();</span><br><span class="line">        <span class="keyword">int</span> j; <span class="comment">//automatic variable</span></span><br><span class="line">        j++;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;J is %d&quot;</span>,j);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> main ;</span><br><span class="line">    A obj_1;</span><br><span class="line">    A obj_2;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;static task with automatic variables&quot;</span>);</span><br><span class="line">        obj_1 = <span class="keyword">new</span>();</span><br><span class="line">        obj_2 = <span class="keyword">new</span>();</span><br><span class="line">        obj_1<span class="variable">.incr</span>();</span><br><span class="line">        obj_2<span class="variable">.incr</span>();</span><br><span class="line">        obj_1<span class="variable">.incr</span>();</span><br><span class="line">        obj_2<span class="variable">.incr</span>();</span><br><span class="line">        A::incr();</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Each call to task will create a separate</span></span><br><span class="line"><span class="string">        copy of &#x27;j&#x27; and increment it&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p>result：<img src="/2024/02/12/System-Verilog-Notes/image-14.png" alt="Alt text">  </p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>内建语句，用于表示当前的对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>使用关键词 <code>extends</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">1024</span>], crc;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BadTr <span class="keyword">extends</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> bad_crc;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">BadTr bt;</span><br><span class="line">bt = <span class="keyword">new</span>;</span><br><span class="line">bt<span class="variable">.src</span> = <span class="number">42</span>;</span><br><span class="line">bt<span class="variable">.bad_crc</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>继承使得一个类可以在父类的基础特性上增加新的特性。<br><img src="/2024/02/12/System-Verilog-Notes/image-51.png" alt="Alt text"></p>
<p>使用关键词<code>super</code>调用父类的方法。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data[<span class="number">1024</span>], crc;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> calc_crc();</span><br><span class="line">        crc = src ^ dst ^ data<span class="variable">.xor</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BadTr <span class="keyword">extends</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> bad_crc;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> calc_crc();</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.calc_crc</span>();</span><br><span class="line">    <span class="keyword">if</span> (bad_crc) crc = ~crc;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h3 id="虚函数和虚方法-virtual"><a href="#虚函数和虚方法-virtual" class="headerlink" title="虚函数和虚方法(virtual)"></a>虚函数和虚方法(virtual)</h3><p>用途:用于构建模板，只有被继承时才可以例化。</p>
<p>虚函数在被重构后产生多态，不同继承对象调用同一函数时，产生不同的效果。</p>
<p>使用虚函数的好处</p>
<ol>
<li>灵活性：允许在运行时根据对象的实际类型调用正确的方法。</li>
<li>可扩展性：可以在不修改现有代码的情况下，通过添加新的派生类来扩展功能。</li>
<li>封装：允许派生类修改或扩展基类的行为，而不影响使用基类引用的代码。</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BasePacket;</span><br><span class="line">    <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> B = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> printA;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;BasePacket::A is %d&quot;</span>, A);</span><br><span class="line">    <span class="keyword">endfunction</span> : printA</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> printB;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;BasePacket::B is %d&quot;</span>, B);</span><br><span class="line">    <span class="keyword">endfunction</span> : printB</span><br><span class="line"><span class="keyword">endclass</span> : BasePacket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> My_Packet <span class="keyword">extends</span> BasePacket;</span><br><span class="line">    <span class="keyword">int</span> A = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> B = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> printA;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;My_Packet::A is %d&quot;</span>, A);</span><br><span class="line">    <span class="keyword">endfunction</span>: printA</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> printB;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;My_Packet::B is %d&quot;</span>, B);</span><br><span class="line">    <span class="keyword">endfunction</span> : printB</span><br><span class="line"><span class="keyword">endclass</span> : My_Packet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Program test_virtual_method()</span><br><span class="line"></span><br><span class="line">BasePacket P1 = <span class="keyword">new</span>;</span><br><span class="line">My_Packet P2 = <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    P1<span class="variable">.printA</span>; <span class="comment">// displays &#x27;BasePacket::A is 1&#x27;</span></span><br><span class="line">    P1<span class="variable">.printB</span>; <span class="comment">// displays &#x27;BasePacket::B is 2&#x27;</span></span><br><span class="line">    P1 = P2; <span class="comment">// P1 has a handle to a My_packet object ，一个upcasting操作</span></span><br><span class="line">    P1<span class="variable">.printA</span>; <span class="comment">// displays &#x27;BasePacket::A is 1&#x27;</span></span><br><span class="line">    P1<span class="variable">.printB</span>; <span class="comment">// displays &#x27;My_Packet::B is 4&#x27; – latest derived method</span></span><br><span class="line">    P2<span class="variable">.printA</span>; <span class="comment">// displays &#x27;My_Packet::A is 3&#x27;</span></span><br><span class="line">    P2<span class="variable">.printB</span>; <span class="comment">// displays &#x27;My_Packet::B is 4&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理解：虚函数运行多态，当基类被upcasting给派生类后，可以调用派生类的方法。相反，如果不是虚函数，则还是调用原来自己有的方法。</p>
<h3 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h3><p>upcasting: 将子类的对象赋值给父类</p>
<p>downcasting: 不合法的操作。子类被看作是独立于父类的对象。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> father_class;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] fsrc=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">input</span> <span class="keyword">string</span> prefix=<span class="string">&quot;f* &quot;</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%sfather_class:fsrc=%d&quot;</span>,prefix,fsrc);</span><br><span class="line">    <span class="keyword">endfunction</span> </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> child_class <span class="keyword">extends</span> father_class;</span><br><span class="line">    <span class="keyword">bit</span> csrc=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">input</span> <span class="keyword">string</span> prefix=<span class="string">&quot;c* &quot;</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%schild_class:csrc=%b&quot;</span>,prefix,csrc);</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.display</span>(prefix);</span><br><span class="line">    <span class="keyword">endfunction</span> </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> test_cast();</span><br><span class="line">    father_class fhandler;</span><br><span class="line">    child_class chandler;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//Construct childclass extended object</span></span><br><span class="line">        chandler=<span class="keyword">new</span>(); </span><br><span class="line">        <span class="comment">//Base handle points to extended obj </span></span><br><span class="line">        fhandler=chandler;  <span class="comment">//父给子是合法的。</span></span><br><span class="line">        <span class="comment">// Display variable in base classCalls</span></span><br><span class="line">        <span class="built_in">$display</span>(fhandler<span class="variable">.fsrc</span>); </span><br><span class="line">        fhandler<span class="variable">.display</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> test_cast();</span><br><span class="line">    father_class fhandler;</span><br><span class="line">    child_class chandler;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//Construct childclass extended object</span></span><br><span class="line">        fhandler =<span class="keyword">new</span>(); </span><br><span class="line">        <span class="comment">//Base handle points to extended obj </span></span><br><span class="line">        Chandler= fhandler; </span><br><span class="line">        <span class="comment">// Display variable in base classCalls</span></span><br><span class="line">        <span class="built_in">$display</span>(fhandler<span class="variable">.fsrc</span>); </span><br><span class="line">        fhandler<span class="variable">.display</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>产生编译错误：</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-52.png" alt="Alt text"></p>
<h2 id="LEC9-跨进程同步与通信"><a href="#LEC9-跨进程同步与通信" class="headerlink" title="LEC9 跨进程同步与通信"></a>LEC9 跨进程同步与通信</h2><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>与进程类似，不同之处在于线程是进程的一个更小单位。线程共享内存资源。</p>
<h3 id="SV中的过程："><a href="#SV中的过程：" class="headerlink" title="SV中的过程："></a>SV中的过程：</h3><p>一个过程块中的代码可以被独立看作一个线程。<br>如：</p>
<p>initial<br>always<br>final<br>fork … join  (创建并行语句)<br>task&#x2F;function<br>assign </p>
<h4 id="begin-…-end"><a href="#begin-…-end" class="headerlink" title="begin … end"></a>begin … end</h4><p> 两种赋值方式：阻塞赋值和非阻塞赋值。非阻塞赋值可以看作是并行的。</p>
<h4 id="fork-join"><a href="#fork-join" class="headerlink" title="fork join"></a>fork join</h4><p> example:<br> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">module</span> inline_ tb;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>: <span class="number">0</span>] data_ bus;</span><br><span class="line"><span class="comment">// instance of DUT</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">        data_bus = <span class="number">8&#x27;b00</span>;</span><br><span class="line">        #<span class="number">10</span> data_bus = <span class="number">8&#x27;h45</span>;</span><br><span class="line">        #<span class="number">20</span> <span class="keyword">repeat</span> (<span class="number">10</span>) #<span class="number">10</span> data_bus = data_bus + <span class="number">1</span>;</span><br><span class="line">        #<span class="number">25</span> <span class="keyword">repeat</span> (<span class="number">5</span>) #<span class="number">20</span> data_bus = data_bus &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        #<span class="number">140</span> data_bus = <span class="number">8&#x27;h0f</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>SV中新增的特性：<br>fork join_any 和 fork join_none<br><img src="/2024/02/12/System-Verilog-Notes/image-16.png" alt="Alt text"></p>
<p>join_any:父进程阻塞，直到fork中的任意一个线程结束(exit(0));</p>
<p>join_none:父进程不管子进程是否结束，继续执行。<br>需要注意的是：fork join_none创建的子进程只会被调度，而不会被执行。除非下一个事件发生。</p>
<p>如:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> test_fork_joinnone;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;First Block \n&quot;</span>);<span class="comment">//不会被执行</span></span><br><span class="line">    # <span class="number">20</span>ns;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Second Block \n&quot;</span>);<span class="comment">//不会被执行</span></span><br><span class="line">    # <span class="number">30</span>ns;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join_none</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;continue main process&quot;</span>);</span><br><span class="line">    <span class="comment">//#0 $display(&quot;finish for_join&quot;); 除非加上这句。</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p>使用fork join创建多线程时，需要注意变量的值的变化：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> test_join_none_var;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; <span class="number">3</span>;j++ )</span><br><span class="line">        <span class="comment">//automatic int k=j;</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">automatic</span> <span class="keyword">int</span> k=j;</span><br><span class="line">            <span class="built_in">$display</span>(k);</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">        #<span class="number">0</span> <span class="built_in">$display</span>(<span class="string">&quot;finish_forjoin&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-17.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> test_join_none_var;</span><br><span class="line">    <span class="keyword">int</span> k,j;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; <span class="number">3</span>;j++ ) <span class="keyword">begin</span></span><br><span class="line">            k=j;</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="built_in">$display</span>(k);</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">0</span> <span class="built_in">$display</span>(<span class="string">&quot;finish_forjoin&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-55.png" alt="Alt text"><br>    二者的区别在于automic关键字</p>
<p>辨析：任务或函数被声明为 automatic 时，每次调用都会在堆栈上创建新的存储空间。这意味着每个调用都有自己的局部变量副本，这些变量在调用之间是独立的。这种行为对于递归调用和在并发进程中调用任务或函数非常重要，因为它防止了不同调用之间的数据冲突。</p>
<p>SV中，线程是被动态构造出来的。</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="wait-事件触发。"><a href="#wait-事件触发。" class="headerlink" title="wait: 事件触发。"></a>wait: 事件触发。</h4><p>使用<strong>wait fork</strong>确保所有的子进程都被执行完毕:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> do_test;</span><br><span class="line"><span class="comment">//begin</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        exec1();</span><br><span class="line">        exec2();</span><br><span class="line">        <span class="keyword">join_any</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        exec3();</span><br><span class="line">        exec4();</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    <span class="keyword">wait</span> <span class="keyword">fork</span>;</span><br><span class="line"><span class="comment">//end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>


<p><strong>wait_order()</strong>:指定事件的发生顺序。</p>
<h4 id="disable"><a href="#disable" class="headerlink" title="disable"></a>disable</h4><p>使用disable结束特定的线程。</p>
<h4 id="EVENTS"><a href="#EVENTS" class="headerlink" title="EVENTS"></a>EVENTS</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">event</span> e1;</span><br></pre></td></tr></table></figure>
<p>event被看作是一种<strong>数据类型</strong>，但其本身没有数据值，仅用作同步信号。可以用作进程或线程之间通信的手段。一个进程可以<strong>等待（wait）</strong>一个事件，而另一个进程可以<strong>触发（trigger）</strong>这个事件。</p>
<p><code>@</code>操作符用于<strong>等待</strong>某个事件发生，当使用<code>@</code>操作符后的进程被阻塞，直到相应的event被触发。</p>
<p><code>-&gt;</code>和<code>-&gt;&gt;</code>用于触发事件，其区别在于前者是阻塞的，后者是非阻塞的。<br>使用 <code>-&gt; </code>触发事件时，事件会立即被触发。这意味着在当前时间点，所有等待该事件的进程都会被唤醒。<br>使用 <code>-&gt;&gt;</code> 时，事件的触发会被安排在当前时间点之后的最近的未来时间点。这是一种非阻塞触发，它允许当前进程继续执行，而不是立即切换到等待该事件的进程。</p>
<p>需要注意的是，某个事件的触发必须在等待之后，而不是之前。否则对应的进程无法被调度。</p>
<h5 id="example"><a href="#example" class="headerlink" title="example:"></a>example:</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> p_event;</span><br><span class="line"><span class="keyword">event</span> ev;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">fork</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">wait</span>(ev<span class="variable">.triggered</span>)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            @(ev)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block2&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            -&gt;ev;</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;trigger ev&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            @(ev)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block3&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">wait</span>(ev<span class="variable">.triggered</span>)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block4&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">join</span> </span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-18.png" alt="Alt text"></p>
<h5 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h5><p>block2触发但是1没触发。说明@的机制是串行的，虽然写在fork中，但是并不能真的并行。实际上，同一个fork制造的并行语句<code>@(ev)</code>和<code>-&gt;ev;</code>构成了一种竞争(race)，同一个时刻内事件到底是先触发还是先观测，构成了一种<strong>冲突</strong>。</p>
<p>在 SystemVerilog 或任何并发编程环境中，”race condition”（竞争条件）是指两个或多个进程（或线程）在访问共享资源时，最终结果依赖于进程执行的精确时序或顺序。当进程以不可预测的方式相互干扰时，就会发生竞争条件，这可能导致不一致或错误的行为。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享变量</span></span><br><span class="line"><span class="keyword">int</span> shared_var;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 1</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    shared_var = shared_var + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 2</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    shared_var = shared_var + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，最终 shared_var 的值取决于两个进程执行的相对时序，这就是一个竞争条件。使用同步机制（如信号量）可以解决这个问题。(见下节)</p>
<h5 id="triggered机制"><a href="#triggered机制" class="headerlink" title="triggered机制"></a>triggered机制</h5><p> SystemVerilog 中，每个 event 类型的对象都有一个名为 triggered 的内置属性。这个属性用于检查事件是否已经被触发。</p>
<p>triggered 属性的作用：</p>
<ol>
<li>状态检查：triggered 属性返回一个布尔值，指示自上次检查以来事件是否被触发。如果事件被触发，它返回 true；否则返回 false。</li>
<li>重置行为：一旦 triggered 属性被读取，事件的触发状态就会被重置。这意味着如果你再次检查 triggered 属性，除非事件在此期间再次被触发，否则它将返回 false。</li>
</ol>
<h5 id="event之间可以相互赋值。"><a href="#event之间可以相互赋值。" class="headerlink" title="event之间可以相互赋值。"></a>event之间可以相互赋值。</h5><p>当一个事件被赋值给另一个时，原来的事件不会再被触发执行。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> test_merge_event;</span><br><span class="line">    <span class="keyword">event</span> E1,E2,E3;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        E2 = E1;</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            T1: <span class="keyword">begin</span></span><br><span class="line">                @ E1;</span><br><span class="line">                <span class="built_in">$display</span>(“unblock T1”);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            T2: <span class="keyword">begin</span></span><br><span class="line">                @ E2;</span><br><span class="line">                <span class="built_in">$display</span>(“unblock T2”);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            T3: <span class="keyword">begin</span> </span><br><span class="line">                @ E3;</span><br><span class="line">                <span class="built_in">$display</span>(“unblock T3”);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            T4: <span class="keyword">begin</span> </span><br><span class="line">                E2 = E3;</span><br><span class="line">                -&gt; E3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>理解：当一个进程被阻塞，等待某个event被触发时，如果原本的envent被赋值给了另一个event，则原来的envent永远不会被触发，对应的进程一直处于阻塞状态。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-19.png" alt="Alt text"></p>
<h4 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore  信号量"></a>Semaphore  信号量</h4><p>信号量（semaphores）是一种同步机制，用于控制对共享资源的访问，特别是在并发环境中。信号量主要用于解决竞争条件，确保在任何给定时间只有一个特定数量的进程可以访问共享资源。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>互斥访问：信号量可以确保对共享资源的互斥访问，防止多个进程同时修改同一资源。<br>控制资源访问：可以限制同时访问某个资源的进程数量，这对于管理有限资源（如内存、文件句柄等）非常有用。</p>
<h5 id="SV中信号量的定义："><a href="#SV中信号量的定义：" class="headerlink" title="SV中信号量的定义："></a>SV中信号量的定义：</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> semaphore;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> keyCount = <span class="number">0</span>);</span><br><span class="line"><span class="comment">//keycount specifies number of keys initially allocated</span></span><br><span class="line"><span class="comment">//default 0</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> put(<span class="keyword">int</span> keyCount = <span class="number">1</span>);</span><br><span class="line"><span class="comment">//returns specified number of keys to semaphore waiting</span></span><br><span class="line"><span class="comment">//process can grab these keys,</span></span><br><span class="line"><span class="comment">//default 1</span></span><br><span class="line"><span class="keyword">task</span> get(<span class="keyword">int</span> keyCount = <span class="number">1</span>);</span><br><span class="line"><span class="comment">//if specified number of keys are not available, process blocks !</span></span><br><span class="line"><span class="comment">//default 1</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> try_get(<span class="keyword">int</span> keyCount = <span class="number">1</span>);</span><br><span class="line"><span class="comment">//if specified number of keys available, method returns 1 and</span></span><br><span class="line"><span class="comment">//execution continues, if not, method returns 0.</span></span><br><span class="line"><span class="comment">//default 1</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>new用于构造一个新的信号量。<br>get相当于C语言中的semwait()<br>put相当于C语言中的semsignal()</p>
<h5 id="example-1"><a href="#example-1" class="headerlink" title="example:"></a>example:</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> semaphore_ex;</span><br><span class="line">    semaphore semBus = <span class="keyword">new</span>(<span class="number">1</span>);<span class="comment">//构造一个新的信号量，初始值为1，代表只有一个资源。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">fork</span></span><br><span class="line">                agent(<span class="string">&quot;AGENT 0&quot;</span>,<span class="number">5</span>);</span><br><span class="line">                agent(<span class="string">&quot;AGENT 1&quot;</span>,<span class="number">20</span>);</span><br><span class="line">            <span class="comment">// 使用fork 构造并行，使2个函数抢占同一个资源。</span></span><br><span class="line">            <span class="keyword">join</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> <span class="keyword">automatic</span> agent(<span class="keyword">string</span> name, <span class="keyword">integer</span> nwait);</span><br><span class="line">        <span class="keyword">integer</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">4</span>; i ++ ) <span class="keyword">begin</span></span><br><span class="line">            semBus<span class="variable">.get</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;[%0d] Lock semBus for %s&quot;</span>, <span class="built_in">$time</span>,name);</span><br><span class="line">            <span class="variable">#(nwait)</span>;</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;[%0d] Release semBus for %s&quot;</span>, <span class="built_in">$time</span>,name);</span><br><span class="line">            semBus<span class="variable">.put</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="variable">#(nwait)</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-20.png" alt="Alt text"></p>
<h4 id="Mailbox"><a href="#Mailbox" class="headerlink" title="Mailbox"></a>Mailbox</h4><p>邮箱，用于进行进程中的数据通信。相当于C中的pipe。  邮箱（Mailbox）是一种用于进程间通信的同步机制。它允许一个进程向邮箱发送（put）消息，而另一个或多个进程可以从邮箱接收（get）这些消息。邮箱在并发编程中非常有用，特别是当需要在不同进程间安全地传递数据时。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-56.png" alt="Alt text"><br>可以看作是一个FIFO。</p>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> mailbox <span class="variable">#(type T = dynamic_singular_type)</span> ;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> bound = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// mail box constructor, optionally specifies the max size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> num();</span><br><span class="line">    <span class="comment">// returns the number of messages currently in mailbox</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> put( T message);</span><br><span class="line">    <span class="comment">// places a message in mailbox; blocks if mailbox full</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> try_put( T message);</span><br><span class="line">    <span class="comment">// places a message in mailbox; returns 0 if mailbox full</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> get( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">// retrieves message from mailbox; blocks if mailbox empty; error if type mismatch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> try_get( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">// retrieves message from mailbox; returns 0/+1/-1; empty/success/type mismatch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> peek( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">// copies message from mailbox; blocks if mailbox empty; error if type mismatch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> try_peek( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">//copies message from mailbox; returns 0/+1/-1; empty/success/type mismatch</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h5 id="example-2"><a href="#example-2" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> test_mailbox1 ;</span><br><span class="line">    mailbox <span class="variable">#(string) my_mailbox = new(4)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (my_mailbox) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">fork</span></span><br><span class="line">                put_data();</span><br><span class="line">                get_data();</span><br><span class="line">            <span class="keyword">join</span> </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> get_data();</span><br><span class="line">        <span class="keyword">string</span> rdata;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) <span class="keyword">begin</span></span><br><span class="line">                #<span class="number">2</span>;</span><br><span class="line">                my_mailbox<span class="variable">.get</span> (rdata);</span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">&quot;Reading Data %s @time %d&quot;</span>,rdata, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> put_data();</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">string</span> t;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) <span class="keyword">begin</span></span><br><span class="line">                #<span class="number">2</span>;</span><br><span class="line">                <span class="built_in">$sformat</span>(t,<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">                my_mailbox<span class="variable">.put</span>(t);</span><br><span class="line">                my_mailbox<span class="variable">.put</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;Writing Data %d @time %d&quot;</span>,i, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-57.png" alt="Alt text"></p>
<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><ol>
<li>阻塞行为：get 方法在等待消息时会阻塞进程。如果需要非阻塞行为，可以使用 try_get 或 get_nb 方法。</li>
<li>数据类型：邮箱可以传递任何类型的数据，但发送者和接收者必须对如何解释数据达成一致。</li>
<li>同步和异步：邮箱提供了一种同步机制，但它也可以用于异步通信，取决于如何使用 get 和 put 方法。</li>
</ol>
<h4 id="Semaphore和Mailbox的比较"><a href="#Semaphore和Mailbox的比较" class="headerlink" title="Semaphore和Mailbox的比较"></a>Semaphore和Mailbox的比较</h4><pre><code>1. 目的：信号量用于控制资源访问（主要是互斥），而邮箱用于数据传递。
2. 机制：信号量通过计数来控制资源访问，邮箱通过存储和传递消息来实现通信。
3. 数据处理：信号量不处理数据，邮箱则用于具体的数据传递。
4. 阻塞条件：在信号量中，进程阻塞是因为没有可用资源；在邮箱中，进程阻塞是因为没有消息可读。
</code></pre>
<h2 id="Assertions-断言"><a href="#Assertions-断言" class="headerlink" title="Assertions 断言"></a>Assertions 断言</h2><h3 id="什么是assertion"><a href="#什么是assertion" class="headerlink" title="什么是assertion?"></a>什么是assertion?</h3><p>一些检查性的代码，可以用于检测代码的功能覆盖率，做形式化验证等。assertion用于验证设计的行为是否符合预期。断言主要用于动态验证，即在仿真运行时检查特定的条件或属性。它们是确保设计符合其规范的关键组成部分，特别是在复杂的硬件设计和验证过程中。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-22.png" alt="Alt text"></p>
<h4 id="断言的用途"><a href="#断言的用途" class="headerlink" title="断言的用途"></a>断言的用途</h4><pre><code>1. 检测错误：在设计早期发现错误，如逻辑错误、时序问题。例如FIFO的读空写满，FSM一些非法状态的跳转，协议的握手等。
2.文档化设计意图：断言可以作为设计意图的一部分，帮助其他工程师理解代码的预期行为。
2. 提高验证覆盖率：使用断言可以更全面地验证设计，确保覆盖各种边缘情况。
3. 减少调试时间：当断言失败时，它们提供了关于错误位置和原因的即时反馈。
</code></pre>
<h4 id="example-3"><a href="#example-3" class="headerlink" title="example:"></a>example:</h4><p>检查a的上升沿的3个时钟周期内，b是否到达上升沿。<br><strong>verilog 的写法：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> a) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">repeat</span> (<span class="number">1</span>) @(<span class="keyword">posedge</span> clk);</span><br><span class="line">    <span class="keyword">fork</span>： a_to_b</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> b)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;SUCCESS： b arrived in time\n&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">disable</span> a_to_b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">repeat</span> (<span class="number">3</span>) @(<span class="keyword">posedge</span> clk);</span><br><span class="line">            <span class="built_in">$display</span></span><br><span class="line">            (<span class="string">&quot;ERROR：b did not arrive in time\n&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">disable</span> a_to_b;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">join</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>assertion的写法：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_to_b_chk：</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span></span><br><span class="line">@(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(a) |-&gt; ##[<span class="number">1</span>：<span class="number">3</span>] <span class="built_in">$rose</span>(b);</span><br></pre></td></tr></table></figure>

<h3 id="Assertion-Based-Verification"><a href="#Assertion-Based-Verification" class="headerlink" title="Assertion Based Verification"></a>Assertion Based Verification</h3><p>对于时序检查很有用 ，同时可以检查功能覆盖率</p>
<p>例，宏定义</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test();</span><br><span class="line">…</span><br><span class="line"><span class="meta">`<span class="keyword">ifndef</span> NO_INLINED_ASSERTION</span></span><br><span class="line">    st_hold: <span class="keyword">assert</span> <span class="keyword">property</span>( @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    (!reset &amp;&amp; (!st_in &amp;&amp; ready_in))</span><br><span class="line">    |-&gt; ##<span class="number">1</span> (st_in [*<span class="number">1</span>:$]) ##<span class="number">0</span> accepted_in)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">$display</span>(“st_in did <span class="keyword">not</span> hold till accepted_in”);</span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Assertion-库"><a href="#Assertion-库" class="headerlink" title="Assertion 库"></a>Assertion 库</h3><p>Open Verification Library (OVL)<br>Formal Property Language Sugar<br>OpenVera<br>SystemVerilog Assertions  </p>
<p>Assertion优缺点：</p>
<p>1.更容易DEBUG<br>2.可以和C联用<br>3.设计意图可以更好体现</p>
<p>会降低仿真速度。</p>
<h3 id="Assertion的分类："><a href="#Assertion的分类：" class="headerlink" title="Assertion的分类："></a>Assertion的分类：</h3><p><strong>即时断言（Immediate Assertions）：</strong><br>    类似组合逻辑<br>    在表达式求值后立即检查条件。<br>    如果条件为假，则断言失败。<br>    通常用于检查在特定代码点必须为真的条件。</p>
<p><strong>并发断言（Concurrent Assertions）:</strong><br>    类似时序逻辑<br>    在仿真过程中连续检查条件。<br>    使用序列（sequence）和属性（property）来描述复杂的时序行为。<br>    适用于验证设计的时序特性。<br><img src="/2024/02/12/System-Verilog-Notes/image-23.png" alt="Alt text"></p>
<h4 id="Immediate-Assertions举例："><a href="#Immediate-Assertions举例：" class="headerlink" title="Immediate Assertions举例："></a>Immediate Assertions举例：</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assertion_label : <span class="keyword">assert</span> (expression)</span><br><span class="line">    pass block code;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fail block code;<span class="comment">//0,x,z</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> assert_immediate();</span><br><span class="line">    <span class="keyword">reg</span> clk, grant, request;</span><br><span class="line">    <span class="keyword">time</span> current_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        grant = <span class="number">0</span>;</span><br><span class="line">        request = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">4</span> request = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">4</span> grant = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">4</span> request = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">4</span> <span class="built_in">$finish</span>; </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">1</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (grant == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            CHECK_REQ_WHEN_GNT : <span class="keyword">assert</span> (grant &amp;&amp; request) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">&quot;Seems to be working as expected&quot;</span>);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                current_time = <span class="built_in">$time</span>;</span><br><span class="line">                #<span class="number">1</span> <span class="built_in">$error</span>(<span class="string">&quot;assert failed at time %0t&quot;</span>, current_time);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-24.png" alt="Alt text"><br>绿色三角：assertion通过<br>红色三角：assertion失败</p>
<h5 id="SV的调度顺序"><a href="#SV的调度顺序" class="headerlink" title="SV的调度顺序"></a>SV的调度顺序</h5><p><img src="/2024/02/12/System-Verilog-Notes/image-25.png" alt="Alt text">  </p>
<p><strong>preponed</strong>: 这个阶段发生在仿真时间步的最开始，进行变量的取值。<br><strong>observed</strong>:在这个阶段，可以观察到所有信号和变量的状态，但不应该产生任何新的活动或更改状态。这主要用于监控和检查目的。<br><strong>reactive</strong>:在这个阶段，可以根据之前阶段的观察结果做出反应。(pass&#x2F;fail)</p>
<p><strong>Active Phase</strong>：在这个阶段执行大部分代码，包括非阻塞赋值的右侧表达式和大多数程序语句。</p>
<p><strong>Inactive Phase</strong>：在这个阶段，非阻塞赋值的左侧被更新。</p>
<p><strong>NBA (Non-Blocking Assignment) Update Phase</strong>：在这个阶段，所有非阻塞赋值的更新发生。</p>
<p><strong>Preponed Phase</strong>：这是一个特殊的阶段，用于处理一些特殊的建模需求，如在所有其他活动之前读取信号的最终值。</p>
<p><strong>Observed Phase</strong>：在这个阶段，可以观察到所有赋值的结果，但不允许更改任何状态。</p>
<p><strong>Reactive Phase</strong>：在这个阶段，可以根据之前阶段的观察结果来做出反应，如调整内部状态或发出新的输出。</p>
<p><strong>Postponed Phase</strong>：这是仿真时间步的最后阶段，通常用于处理仿真结束等特殊情况。</p>
<h4 id="并发断言-Concurrent-assertions："><a href="#并发断言-Concurrent-assertions：" class="headerlink" title="并发断言 Concurrent assertions："></a>并发断言 Concurrent assertions：</h4><h5 id="example-4"><a href="#example-4" class="headerlink" title="example:"></a>example:</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sequence</span> request</span><br><span class="line">    Req;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> acknowledge</span><br><span class="line">    ##[<span class="number">1</span>:<span class="number">2</span>] Ack;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> handshake;</span><br><span class="line">    @(<span class="keyword">posedge</span> Clock) request |-&gt; acknowledge;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span> (handshake);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-58.png" alt="Alt text"><br>构造sequence和property,之后用assert来检查。</p>
<h3 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sequence</span> name_of_sequence;</span><br><span class="line">    &lt;test expression&gt;;</span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>
<p>sequence 用于描述一系列事件发生的顺序。它定义了一组在时间上相关的条件，这些条件必须按特定的顺序发生。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sequence</span> seq_A_before_B;</span><br><span class="line">    A ##<span class="number">1</span> B;</span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>

<h4 id="时序检查"><a href="#时序检查" class="headerlink" title="时序检查"></a>时序检查</h4><p>两个井号代表一个时钟周期。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##<span class="number">3</span> <span class="comment">//3个clock</span></span><br><span class="line"></span><br><span class="line">req ##<span class="number">1</span> gnt ##<span class="number">1</span> !req</span><br><span class="line"><span class="comment">//req should be trueon the current clock tick</span></span><br><span class="line"><span class="comment">//gnt should be true on the subsequent clock tick,</span></span><br><span class="line"><span class="comment">//req shall be false on the next clock tick after that</span></span><br></pre></td></tr></table></figure>

<h5 id="example-5"><a href="#example-5" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test_clk_dly;</span><br><span class="line">    <span class="keyword">reg</span> a,b,clk;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">        clk=<span class="number">1&#x27;b0</span>; a=<span class="number">1&#x27;b0</span>;b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">1</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">3</span> <span class="keyword">begin</span></span><br><span class="line">            a=<span class="number">1&#x27;b0</span>; b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        #<span class="number">5</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">7</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">9</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">11</span> b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">13</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">15</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">17</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">21</span> b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">23</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">25</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">27</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">29</span> b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">31</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">1</span> clk=!clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sequence</span> s1;</span><br><span class="line">        @(<span class="keyword">posedge</span> clk) a ##<span class="number">2</span> b;</span><br><span class="line">    <span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">property</span> p1;</span><br><span class="line">        s1;</span><br><span class="line">    <span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">    assertion1: <span class="keyword">assert</span> <span class="keyword">property</span>(p1);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-59.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:<span class="number">3</span>] c;</span><br><span class="line">    <span class="comment">//The sequence requires that c occurs 0,1,2 or 3 cycles after b</span></span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:$] c;</span><br><span class="line">    <span class="comment">//The sequence requires that c occurs 0,1,2… or infinite cycles after b</span></span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>

<h4 id="重复-repetition"><a href="#重复-repetition" class="headerlink" title="重复(repetition)"></a>重复(repetition)</h4><h5 id="consecutive-repetition"><a href="#consecutive-repetition" class="headerlink" title="consecutive repetition"></a>consecutive repetition</h5><p>consecutive 重复指的是事件必须连续发生，没有间隔。<br>用法：使用简单的重复操作符（如 [*n]）表示连续重复。</p>
<h6 id="example-6"><a href="#example-6" class="headerlink" title="example"></a>example</h6><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a ##<span class="number">1</span> b ##<span class="number">1</span> b ##<span class="number">1</span> b ##<span class="number">1</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment">//can be writen as:</span></span><br><span class="line">a ##<span class="number">1</span> b[*<span class="number">3</span>] ##<span class="number">1</span> c</span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property</span> p21;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(start) |-&gt; ##<span class="number">2</span> (a[*<span class="number">3</span>]) ##<span class="number">2</span> stop ##<span class="number">1</span> !stop;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a21:<span class="keyword">assert</span> <span class="keyword">property</span>(p21);</span><br></pre></td></tr></table></figure>
<h5 id="Goto-Repetition"><a href="#Goto-Repetition" class="headerlink" title="Goto Repetition"></a>Goto Repetition</h5><p>goto 重复允许在重复的事件之间有间隔，但一旦开始，后续事件必须连续发生。<br>用法：使用 -&gt; 操作符表示 goto 重复。<br><img src="/2024/02/12/System-Verilog-Notes/image-28.png" alt="Alt text"><br>中间会有2到10个b的高电平，但不要求这些电平连续。但b的最后一个高电平一定和c连续。</p>
<h6 id="example-7"><a href="#example-7" class="headerlink" title="example"></a>example</h6><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property</span> p25;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(start) |-&gt; ##<span class="number">2</span> (a[-&gt;<span class="number">3</span>]) ##<span class="number">1</span> stop;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a25: <span class="keyword">assert</span> <span class="keyword">property</span>(p25);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-63.png" alt="Alt text"><br>a的3个上升沿后，stop没有在下一个周期立刻上升，故断言失败。</p>
<h5 id="Nonconsecutive-Repetition"><a href="#Nonconsecutive-Repetition" class="headerlink" title="Nonconsecutive Repetition"></a>Nonconsecutive Repetition</h5><p>nonconsecutive 重复允许事件之间有任意数量的时钟周期间隔。相当于Goto Repetition最后一个重复周期与后面的信号序列不用连续。<br><img src="/2024/02/12/System-Verilog-Notes/image-62.png" alt="Alt text"><br>用法：使用 &#x3D; 操作符表示 nonconsecutive 重复。</p>
<h6 id="example-8"><a href="#example-8" class="headerlink" title="example"></a>example</h6><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property</span> p26;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(start) |-&gt; ##<span class="number">2</span> (a[=<span class="number">3</span>]) ##<span class="number">1</span> stop ##<span class="number">1</span> !stop;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a26:<span class="keyword">assert</span> <span class="keyword">property</span>(p26);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-64.png" alt="Alt text"><br>与p25一样的信号，使用Nonconsecutive Repetition可以断言成功。</p>
<h4 id="throughout-持续"><a href="#throughout-持续" class="headerlink" title="throughout 持续"></a>throughout 持续</h4><p>在 SystemVerilog 的序列（sequence）中，throughout 是一个关键字，用于描述一种强制性的关系，即一个事件在另一个事件发生的整个持续时间内必须为真。这种构造在描述复杂的时序关系时非常有用，特别是当一个条件必须在另一个条件的整个持续期间内持续成立时。</p>
<h5 id="example-9"><a href="#example-9" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sequence</span> burst_rule1;</span><br><span class="line">    @(<span class="keyword">posedge</span> mclk)</span><br><span class="line">        <span class="built_in">$fell</span>(burst_mode) ##<span class="number">0</span>(!burst_mode) <span class="keyword">throughout</span> (##<span class="number">2</span> ((trdy==<span class="number">0</span>)&amp;&amp;(irdy==<span class="number">0</span>)) [*<span class="number">7</span>]);</span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-65.png" alt="Alt text"></p>
<h4 id="within"><a href="#within" class="headerlink" title="within"></a>within</h4><p>在 SystemVerilog 的序列（sequence）中，within 是一个关键字，用于描述一个序列必须完全发生在另一个序列的持续时间内的关系。(注意和throughout的区别)</p>
<h5 id="example-10"><a href="#example-10" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s32a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        ((!a&amp;&amp;!b) ##<span class="number">1</span> (c[-&gt;<span class="number">3</span>]) ##<span class="number">1</span> (a&amp;&amp;b));</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s32b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        <span class="built_in">$fell</span>(start) ##[<span class="number">5</span>:<span class="number">10</span>] <span class="built_in">$rose</span>(start);</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s32;</span><br><span class="line">@(<span class="keyword">posedge</span> clk) s32a <span class="keyword">within</span> s32b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p32;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$fell</span>(start) |-&gt; s32;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">a32: <span class="keyword">assert</span> <span class="keyword">property</span>(p32);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-66.png" alt="Alt text"></p>
<h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p>在 SystemVerilog 的序列（sequence）中，and 关键字用于描述两个或多个序列必须同时发生的关系。两个seq必须同时开始,但不必同时结束。</p>
<h5 id="example-11"><a href="#example-11" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s27a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##[<span class="number">1</span>:<span class="number">2</span>] b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s27b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c ##[<span class="number">2</span>:<span class="number">3</span>] d;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p27;</span><br><span class="line">    s27a <span class="keyword">and</span> s27b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a27: <span class="keyword">assert</span> <span class="keyword">property</span>(p27);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-67.png" alt="Alt text"></p>
<h4 id="intersect-交集"><a href="#intersect-交集" class="headerlink" title="intersect 交集"></a>intersect 交集</h4><p>在 SystemVerilog 的序列（sequence）中，intersect 关键字用于描述两个序列在某个时间点上有重叠的关系。intersect 用于指定两个序列在某个时间点上必须有重叠。这意味着这些序列中的事件或条件必须在某个时刻同时为真，它们的开始和结束时间相同。</p>
<h5 id="example-12"><a href="#example-12" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s28a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a##[<span class="number">1</span>:<span class="number">2</span>] b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s28b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c##[<span class="number">2</span>:<span class="number">3</span>] d;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p28;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) s28a <span class="keyword">intersect</span> s28b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a28:<span class="keyword">assert</span> <span class="keyword">property</span>(p28);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-68.png" alt="Alt text"></p>
<h5 id="和throughout的区别"><a href="#和throughout的区别" class="headerlink" title="和throughout的区别"></a>和throughout的区别</h5><p>throughout 要求一个序列在另一个序列的整个时间范围内持续为真。<br>intersect 只要求两个序列在某个时间点上有重叠，而不需要覆盖整个时间范围。</p>
<h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p>在 SystemVerilog 的序列（sequence）中，or 关键字用于描述两个或多个序列中的任意一个满足条件即可的关系。</p>
<h5 id="example-13"><a href="#example-13" class="headerlink" title="example"></a>example</h5><p><img src="/2024/02/12/System-Verilog-Notes/image-69.png" alt="Alt text"></p>
<h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>property 用于表达更复杂的断言条件，它可以包含一个或多个 sequence，并支持逻辑运算（如 AND、OR、NOT）和其他控制结构（如 if-then-else）。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property</span> name_of_property;</span><br><span class="line">    &lt;test expression&gt;;</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">    &lt;complex <span class="keyword">sequence</span> expressions&gt;;</span><br><span class="line"><span class="keyword">endproperty</span></span><br></pre></td></tr></table></figure>


<h4 id="example-14"><a href="#example-14" class="headerlink" title="example:"></a>example:</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test_sequence1;</span><br><span class="line">    <span class="keyword">reg</span> a,clk;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">        clk=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">1</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">13</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">15</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">19</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">21</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">25</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">27</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">29</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">31</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">33</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">35</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> #<span class="number">1</span> clk=!clk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断每个时钟上升沿，a是否为1</span></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p1;</span><br><span class="line">    s1;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">assertion1: <span class="keyword">assert</span> <span class="keyword">property</span>(p1);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-26.png" alt="Alt text"></p>
<h4 id="系统函数："><a href="#系统函数：" class="headerlink" title="系统函数："></a>系统函数：</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$rose</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否从低到高跳变（0到1）。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$fell</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否从高到低跳变（1到0）。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$stable</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否保持不变。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$changed</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否发生了变化。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$past</span>(signal[, n])<span class="comment">//返回 n 个时钟周期之前 signal 的值。如果 n 省略，默认为1。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$countones</span>(expression)<span class="comment">//计算表达式中值为1的位数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$onehot</span>(expression)<span class="comment">//检测表达式是否恰好只有一个位为1（独热编码）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$onehot0</span>(expression)<span class="comment">//检测表达式是否为零或恰好只有一个位为1。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">first_match</span>()<span class="comment">//用于在一系列可能的事件中识别第一个匹配特定条件的事件。</span></span><br></pre></td></tr></table></figure>

<h4 id="property-的否定"><a href="#property-的否定" class="headerlink" title="property 的否定"></a>property 的否定</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s6;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">2</span> b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p6;</span><br><span class="line">    <span class="keyword">not</span> s6;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a6 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p6);</span><br></pre></td></tr></table></figure>


<h4 id="蕴含操作："><a href="#蕴含操作：" class="headerlink" title="蕴含操作："></a>蕴含操作：</h4><p>等同于逻辑学中的蕴含。真值表：</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>a-&gt;b</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>a|-&gt;b &#x3D; a&amp;b | ~a</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property</span> p8;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; b;<span class="comment">//a发生后b也发生</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">a8 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p8);</span><br></pre></td></tr></table></figure>




<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property</span> p9;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |=&gt; b;<span class="comment">//a发生一个周期后b发生</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a9 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p9);</span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property</span> p10;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; ##<span class="number">2</span> b;<span class="comment">//a发生2个周期后b发生</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a10 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p10);</span><br></pre></td></tr></table></figure>


<h4 id="ended关键词控制断言检查的时间"><a href="#ended关键词控制断言检查的时间" class="headerlink" title="ended关键词控制断言检查的时间"></a>ended关键词控制断言检查的时间</h4><p>ended 关键词用于检测一个序列是否已经到达了其结束点。这对于确定某个特定的时序模式是否已经完整地发生非常有用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sequence</span> sl5a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> sl5b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c ##<span class="number">1</span> d;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> pl5a;</span><br><span class="line">    sl5a |=&gt; sl5b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> pl5b;</span><br><span class="line">    sl5a<span class="variable">.ended</span> |-&gt; ##<span class="number">2</span> sl5b<span class="variable">.ended</span>; <span class="comment">//终点的对齐，p15a与p15b起点不同，结果一致</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">al5a: <span class="keyword">assert</span> <span class="keyword">property</span>(@(<span class="keyword">posedge</span> clk) pl5a);</span><br><span class="line">al5b: <span class="keyword">assert</span> <span class="keyword">property</span>(@(<span class="keyword">posedge</span> clk) pl5b);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-60.png" alt="Alt text"></p>
<h4 id="disable-iff"><a href="#disable-iff" class="headerlink" title="disable iff"></a>disable iff</h4><p>iff:if and only if<br>disable iff（如果…则禁用）是一个关键的构造，用于定义在某些特定条件下断言不应该被评估或应该被禁用的情况。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property</span> p34;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">disable</span> <span class="keyword">iff</span> (reset) </span><br><span class="line">        <span class="built_in">$rose</span>(start) |=&gt; a[=<span class="number">2</span>] ##<span class="number">1</span> b[=<span class="number">2</span>] ##<span class="number">1</span> !start ;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a34： <span class="keyword">assert</span> <span class="keyword">property</span>(p34);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-70.png" alt="Alt text"></p>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>assert 语句用于实际应用断言。它将 property 应用于设计中的特定点，以验证在那个点上 property 是否为真。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span> (prop_X_implies_Y) <span class="keyword">else</span> <span class="built_in">$error</span>(<span class="string">&quot;Assertion failed&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="sequence-property-assert的关系："><a href="#sequence-property-assert的关系：" class="headerlink" title="sequence,property,assert的关系："></a>sequence,property,assert的关系：</h4><pre><code>sequence 提供了描述事件顺序的基础。
property 利用 sequence（可能是多个）来表达更复杂的逻辑条件。
assert 将 property 应用于实际的硬件设计，以确保在运行时满足这些条件。
</code></pre>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>理解以下sequence,property和assert的作用：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s4;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">2</span> b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s2;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(a);</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s3_lib (a，b);</span><br><span class="line">    a || b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##<span class="number">1</span> c;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:<span class="number">3</span>] c;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:$] c;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p6;</span><br><span class="line">    <span class="keyword">not</span> s6;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p8;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a8 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p9;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |=&gt; b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a9 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p9);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p12;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) (a &amp;&amp; b) |-&gt; ##[<span class="number">1</span>:<span class="number">3</span>] c;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a12 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p12);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p10;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; ##<span class="number">2</span> b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a10 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p10);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p13;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) (a &amp;&amp; b) |-&gt; ##[<span class="number">0</span>：<span class="number">2</span>] c;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a13 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p13);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p14;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; ##[<span class="number">1</span>：$] b ##[<span class="number">0</span>：$] c;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a14 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p14);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p17;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c ? d == a：d == b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a17： <span class="keyword">assert</span> <span class="keyword">property</span>(p17);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p19;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) (c &amp;&amp; d) |-&gt; (<span class="built_in">$past</span>((a&amp;&amp;b)，<span class="number">2</span>) == <span class="number">1&#x27;b1</span>);</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a19： <span class="keyword">assert</span> <span class="keyword">property</span>(p19);</span><br></pre></td></tr></table></figure>


<h3 id="如何在仿真中加入assertion"><a href="#如何在仿真中加入assertion" class="headerlink" title="如何在仿真中加入assertion"></a>如何在仿真中加入assertion</h3><p>命令行：<br><img src="/2024/02/12/System-Verilog-Notes/image-61.png" alt="Alt text"><br>gui界面：<br><img src="/2024/02/12/System-Verilog-Notes/image-27.png" alt="Alt text"></p>
<h3 id="如何在testbench中绑定assertion模块"><a href="#如何在testbench中绑定assertion模块" class="headerlink" title="如何在testbench中绑定assertion模块"></a>如何在testbench中绑定assertion模块</h3><h2 id="Random-coverage"><a href="#Random-coverage" class="headerlink" title="Random coverage"></a>Random coverage</h2><h3 id="使用ramdom的原因"><a href="#使用ramdom的原因" class="headerlink" title="使用ramdom的原因"></a>使用ramdom的原因</h3><p>传统的directed test case无法覆盖所有情况，同时，directed test case只能验证设计时的预期功能。</p>
<p>因此需要引入随机。</p>
<p>random应用场景：<br>1.devices configuration<br>2.sequence order<br>3.environment config<br>4.delays within a constrained range<br>5.dynamic config<br>6.protocol exceptions,error and violations<br>…</p>
<h3 id="sv-中的random"><a href="#sv-中的random" class="headerlink" title="sv 中的random"></a>sv 中的random</h3><h4 id="关键字rand"><a href="#关键字rand" class="headerlink" title="关键字rand"></a>关键字rand</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> [<span class="number">3</span>:<span class="number">0</span>]  data</span><br></pre></td></tr></table></figure>

<h4 id="randc-random-cycle"><a href="#randc-random-cycle" class="headerlink" title="randc (random cycle)"></a>randc (random cycle)</h4><p><img src="/2024/02/12/System-Verilog-Notes/image-31.png" alt="Alt text"></p>
<p>每个循环调用时，自动变更为与上一个值不同的随机数，并且遍历取值范围。</p>
<h4 id="constraint-block"><a href="#constraint-block" class="headerlink" title="constraint block"></a>constraint block</h4><p>在 SystemVerilog 中，约束块（Constraint Block）是一种用于随机化测试中的强大机制，它允许你为类的成员变量指定特定的约束条件。这些约束用于控制随机生成的数据，以满足特定的测试需求或设计规范。</p>
<p>constraint 可以定义在class 之外。例：  </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> XYPair;</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="comment">// external constraint body declaration</span></span><br><span class="line"><span class="keyword">constraint</span> XYPair::c &#123; x &lt; y; &#125;</span><br></pre></td></tr></table></figure>

<p>constraint 可以被继承，例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">integer</span> x;</span><br><span class="line">    <span class="keyword">constraint</span> c &#123; x &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">class</span> B <span class="keyword">extends</span> A;</span><br><span class="line">    <span class="keyword">constraint</span> c &#123; x &gt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h4 id="求解器randomize"><a href="#求解器randomize" class="headerlink" title="求解器randomize()"></a>求解器randomize()</h4><p>randomize() 方法用于随机化类中标记为 rand 或 randc 的成员变量。它根据定义在类中的约束（如果有的话）生成随机值。</p>
<p>randomize()是一个虚函数，每当constraint被继承时，原函数被重载。</p>
<h4 id="pre-randomize-和post-randomize"><a href="#pre-randomize-和post-randomize" class="headerlink" title="pre_randomize()和post_randomize()"></a>pre_randomize()和post_randomize()</h4><p>如其名，是在randomize()前后执行的2个函数。可以被重载。<br>pre_randomize() 方法在每次调用 randomize() 方法之前自动执行。<br>用途：它用于设置随机化操作之前需要的任何状态或条件，比如初始化变量、清除状态、设置默认值等。</p>
<p>post_randomize() 方法在每次调用 randomize() 方法之后自动执行。<br>用途：它用于在随机化之后执行任何必要的操作，比如校验或调整随机化结果、更新依赖于随机值的状态等。</p>
<p>在被重载时，pre_randomize()和post_randomize()都会先执行父类的方法，然后执行重载的内容。<br>The pre_randomize() and post_randomize() methods are not virtual. However, because they are automatically called by the randomize() method, which is virtual, they appear to behave as virtual method.</p>
<h4 id="inside-指定表达式的范围"><a href="#inside-指定表达式的范围" class="headerlink" title="inside 指定表达式的范围"></a>inside 指定表达式的范围</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Bus</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">15</span>:<span class="number">0</span>] addr;</span><br><span class="line"><span class="keyword">randc</span> <span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line"><span class="keyword">constraint</span> range1</span><br><span class="line">&#123;</span><br><span class="line">    addr <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">100</span>],[<span class="number">1024</span>:<span class="number">16384</span>]&#125;;</span><br><span class="line">    data &gt; <span class="number">1000</span>;</span><br><span class="line">    data &lt; <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h4 id="dist-指定权重分布"><a href="#dist-指定权重分布" class="headerlink" title="dist 指定权重分布"></a>dist 指定权重分布</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">int</span> src, dst;</span><br><span class="line">costraint c1 &#123;</span><br><span class="line">    src <span class="keyword">dist</span> &#123;<span class="number">0</span>:=<span class="number">40</span>, [<span class="number">1</span>:<span class="number">3</span>]:=<span class="number">60</span>&#125;;</span><br><span class="line">    dst <span class="keyword">dist</span> &#123;<span class="number">0</span>:=<span class="number">40</span>, [<span class="number">1</span>:<span class="number">3</span>]:/<span class="number">60</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-32.png" alt="Alt text"></p>
<p>:&#x3D; 用于相同分布<br>:&#x2F;用于均匀分布</p>
<h4 id="多维约束"><a href="#多维约束" class="headerlink" title="多维约束"></a>多维约束</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] b,c,d;</span><br><span class="line">costraint c1 &#123;</span><br><span class="line">    b&lt;d;</span><br><span class="line">    c==b;</span><br><span class="line">    d&lt;<span class="number">30</span>;</span><br><span class="line">    c&gt;=<span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件约束"><a href="#条件约束" class="headerlink" title="条件约束"></a>条件约束</h4><p>可以包含蕴含操作：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] a,b;</span><br><span class="line"><span class="keyword">constraint</span> c &#123;(a==<span class="number">0</span>)-&gt;(b==<span class="number">1</span>);&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="约束的概率问题"><a href="#约束的概率问题" class="headerlink" title="约束的概率问题"></a>约束的概率问题</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Unconstrained;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> x;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] y;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-33.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Imp1;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> x;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] y;</span><br><span class="line">    <span class="keyword">constraint</span> c_xy &#123; (x==<span class="number">0</span>)-&gt;y==<span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-34.png" alt="Alt text"></p>
<h4 id="迭代约束"><a href="#迭代约束" class="headerlink" title="迭代约束"></a>迭代约束</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class C;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">byte</span> A[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">constraint</span> C1&#123; <span class="keyword">foreach</span> (A[i]) A[i]<span class="keyword">inside</span> &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>&#125;;&#125;</span><br><span class="line">    <span class="keyword">constraint</span> C2&#123; <span class="keyword">foreach</span> (A[j]) A[j]&gt; <span class="number">2</span>*j;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C1 constraints each element of an array to be in the set [2,4,8,16]</span></span><br><span class="line"><span class="comment">//C2 constraints each element of an array to be greater than twice its index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h4 id="solve-before-控制求解顺序"><a href="#solve-before-控制求解顺序" class="headerlink" title="solve before :控制求解顺序"></a>solve before :控制求解顺序</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> B;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> s;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] d;</span><br><span class="line">    <span class="keyword">constraint</span> c &#123; s -&gt; d == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">constraint</span> order &#123; <span class="keyword">solve</span> s <span class="keyword">before</span> d; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-35.png" alt="Alt text"></p>
<h4 id="function-in-constraints"><a href="#function-in-constraints" class="headerlink" title="function in constraints"></a>function in constraints</h4><p>用途：使用function来表示一些复杂的分布情况。<br>例：编码中1的个数。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> count_ones ( <span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>] w );</span><br><span class="line">    <span class="keyword">for</span>( count_ones = <span class="number">0</span>; w != <span class="number">0</span>; w = w &gt;&gt; <span class="number">1</span> )</span><br><span class="line">        count_ones += w &amp; <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> C1 &#123; length == count_ones( v ) ; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="constraint-mode-控制约束的开启和关闭"><a href="#constraint-mode-控制约束的开启和关闭" class="headerlink" title="constraint mode: 控制约束的开启和关闭"></a>constraint mode: 控制约束的开启和关闭</h4><p>内建函数：constraint_mode()，默认0 为inactive,1为activate</p>
<h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><p>2个方面：<strong>代码覆盖率</strong>和<strong>功能覆盖率</strong>。</p>
<p>代码覆盖率可以被自动收集量化。<br>功能覆盖率需要一定的方法学评估。<br><img src="/2024/02/12/System-Verilog-Notes/image-36.png" alt="Alt text"></p>
<h4 id="代码覆盖率的类型："><a href="#代码覆盖率的类型：" class="headerlink" title="代码覆盖率的类型："></a>代码覆盖率的类型：</h4><ol>
<li><p>行覆盖率（Line Coverage&#x2F;Statement Coverage）：<br> 测量测试用例是否执行了设计中的每一行代码。<br> 用于确保代码的每一行至少被执行一次。  </p>
</li>
<li><p>块覆盖率(Block Coverage)<br> 通常指的是测试用例是否执行了代码中的每个基本块。一个基本块是一个直线代码序列，没有分支，只有入口和出口。<br> 确保每个代码块至少被执行一次。</p>
</li>
<li><p>表达式覆盖率（Expression Coverage）：<br> 检查是否测试了代码中的每个表达式的所有可能结果。<br> 用于确保所有的逻辑表达式都被充分测试。</p>
</li>
<li><p>分支覆盖率（Branch Coverage）：<br> 测量是否测试了代码中的每个决策点（如 if、case 语句）的每个可能分支。<br> 用于确保每个决策点的每个分支都至少被执行一次。</p>
</li>
<li><p>条件覆盖率（Condition Coverage）：<br> 检查是否测试了决策点中每个单独条件的所有可能结果。<br> 用于确保复合条件（如逻辑与&#x2F;或）中的每个单独条件都被充分测试。</p>
</li>
<li><p>切换覆盖率（Toggle Coverage）：<br>测量是否测试了设计中每个数据位的翻转（从0到1和从1到0）。<br>用于确保寄存器、线网等的每个位至少翻转一次。</p>
</li>
<li><p>状态机覆盖率（FSM Coverage）：<br>检查是否测试了状态机的所有状态和转换。<br>用于确保状态机的每个状态和状态转换都被测试。</p>
</li>
<li><p>路径覆盖率（Path Coverage）：<br>测量是否测试了代码中所有可能的执行路径。<br>用于确保从函数入口到出口的每个可能路径都被执行。</p>
</li>
<li><p>断言覆盖率（Assertion Coverage）：<br>检查是否测试了代码中的每个断言。<br>用于确保设计中的每个断言都被验证。</p>
</li>
</ol>
<p>代码覆盖率不关心具体功能的实现。因此无法保证功能的正确性。</p>
<h4 id="功能覆盖率Functional-Coverage）："><a href="#功能覆盖率Functional-Coverage）：" class="headerlink" title="功能覆盖率Functional Coverage）："></a>功能覆盖率Functional Coverage）：</h4><p>功能覆盖率是衡量测试用例是否覆盖了设计的所有功能方面的度量。它关注于设计的功能需求是否得到了充分的测试。</p>
<p>功能覆盖率需要人工定义。根据对设计的理解设计不同的功能模块。Based on the DUT spec and test plan, define what needs to be covered.</p>
<p>步骤：<br>Define coverage group (sampling points)<br>Define when to sample</p>
<h4 id="cover-group"><a href="#cover-group" class="headerlink" title="cover group"></a>cover group</h4><p>覆盖组是一组相关的覆盖点和&#x2F;或交叉覆盖点的集合。它用于组织和封装相关的覆盖点，以便于管理和分析。<br>特点：覆盖组可以包含一个或多个覆盖点，以及可选的交叉覆盖点（cross coverage）。它还可以包含用于控制采样时机和条件的方法。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> cg;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line">cg cg_inst = <span class="keyword">new</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mem(simple_bus sb);</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data, addr;</span><br><span class="line"><span class="keyword">event</span> write_event;</span><br><span class="line">    <span class="keyword">cover</span> <span class="keyword">property</span></span><br><span class="line">        (@(<span class="keyword">posedge</span> sb<span class="variable">.clock</span>) sb<span class="variable">.write_ena</span>==<span class="number">1</span>)</span><br><span class="line">    -&gt; write_event;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 cover property 定义了一个覆盖属性，该属性监视 simple_bus 上的 write_ena 信号。当 write_ena 在时钟上升沿为 1 时，触发 write_event 事件。</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test(simple_bus sb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> Write_cg @($root<span class="variable">.top</span><span class="variable">.m1</span><span class="variable">.write_event</span>);</span><br><span class="line">        <span class="keyword">coverpoint</span> $root<span class="variable">.top</span><span class="variable">.m1</span><span class="variable">.data</span>;</span><br><span class="line">        <span class="keyword">coverpoint</span> $root<span class="variable">.top</span><span class="variable">.m1</span><span class="variable">.addr</span>;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    Write_cg wcg;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        wcg = <span class="keyword">new</span>;</span><br><span class="line">        sb<span class="variable">.write_ena</span> &lt;= <span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">        #<span class="number">10000</span> <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//est 是一个程序，它也接收一个名为 sb 的 simple_bus 类型的参数。</span></span><br><span class="line"><span class="comment">//覆盖组：定义了一个名为 Write_cg 的覆盖组，该覆盖组在 write_event 事件发生时被采样。</span></span><br><span class="line"><span class="comment">//覆盖点：覆盖组包含两个覆盖点，分别监视 mem 模块中的 data 和 addr 变量。</span></span><br><span class="line"><span class="comment">//覆盖组实例化：在初始块中创建了 Write_cg 的一个实例 wcg。</span></span><br><span class="line"><span class="comment">//测试逻辑：设置 simple_bus 的 write_ena 为 1，并执行一些未详细说明的测试操作。</span></span><br><span class="line"><span class="comment">//仿真结束：在 10000 个时间单位后结束仿真。</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<h4 id="coverage-point"><a href="#coverage-point" class="headerlink" title="coverage point"></a>coverage point</h4><p>覆盖点是对单个变量或表达式的覆盖度量。<br>用途：它用于捕捉和度量特定变量或表达式在测试中的行为。<br>特点：覆盖点可以定义为变量的特定值、范围或者是基于表达式的条件。它通常包含一组覆盖桶（bins），每个桶对应于特定的值或值范围。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-71.png" alt="Alt text"></p>
<h4 id="bin-：对功能点分组"><a href="#bin-：对功能点分组" class="headerlink" title="bin ：对功能点分组"></a>bin ：对功能点分组</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] y;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] values[$]= &#x27;&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">covergroup</span> cg;</span><br><span class="line">cover_point_y : <span class="keyword">coverpoint</span> y &#123;</span><br><span class="line">    <span class="keyword">bins</span> a = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">bins</span> b = &#123;<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">bins</span> c = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">bins</span> d = &#123;<span class="number">6</span>,<span class="number">7</span>&#125;; &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">foreach</span>(values[i])</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        y = values[i];</span><br><span class="line">        cg_inst<span class="variable">.sample</span>();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<h5 id="Transitional-functional-point-bin"><a href="#Transitional-functional-point-bin" class="headerlink" title="Transitional functional point bin"></a>Transitional functional point bin</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">3</span>] y;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] values[$]= &#x27;&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">    cover_point_y : <span class="keyword">coverpoint</span> y &#123;</span><br><span class="line">        <span class="keyword">bins</span> tran_34 = (<span class="number">3</span>=&gt;<span class="number">4</span>);<span class="comment">//捕捉从3到4的切换</span></span><br><span class="line">        <span class="keyword">bins</span> tran_56 = (<span class="number">5</span>=&gt;<span class="number">6</span>);<span class="comment">//捕捉从5到6的切换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">foreach</span>(values[i])<span class="keyword">begin</span></span><br><span class="line">            y = values[i];</span><br><span class="line">            cg_inst<span class="variable">.sample</span>();</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-74.png" alt="Alt text"></p>
<h5 id="wildcard-bin-通配分组"><a href="#wildcard-bin-通配分组" class="headerlink" title="wildcard bin:通配分组"></a>wildcard bin:通配分组</h5><p>分组中的x,z,?会和0,1产生通配。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">3</span>] y;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">3</span>] values[$]= &#x27;&#123; <span class="number">4&#x27;b1100</span>,<span class="number">4&#x27;b1101</span>,<span class="number">4&#x27;b1110</span>,<span class="number">4&#x27;b1111</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">        cover_point_y : <span class="keyword">coverpoint</span> y &#123;</span><br><span class="line">        <span class="keyword">wildcard</span> <span class="keyword">bins</span> g12_15 = &#123; <span class="number">4&#x27;b11</span>?? &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">foreach</span>(values[i])<span class="keyword">begin</span></span><br><span class="line">            y = values[i];</span><br><span class="line">            cg_inst<span class="variable">.sample</span>();</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-72.png" alt="Alt text"></p>
<h5 id="ignore-bin-忽略的分组"><a href="#ignore-bin-忽略的分组" class="headerlink" title="ignore_bin 忽略的分组"></a>ignore_bin 忽略的分组</h5><p>ignore_bin 用于在覆盖率分析中排除特定的值或值范围。它有助于简化覆盖模型，专注于关键的、有意义的值或状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] y;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] values[$]= &#x27;&#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">        cover_point_y : <span class="keyword">coverpoint</span> y &#123;<span class="comment">//0,1,2,3,4,5,6,7</span></span><br><span class="line">        <span class="keyword">ignore_bins</span> ig = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">foreach</span>(values[i])<span class="keyword">begin</span></span><br><span class="line">        y = values[i];</span><br><span class="line">        cg_inst<span class="variable">.sample</span>();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-73.png" alt="Alt text"><br>0没有被覆盖到。</p>
<h5 id="illegal-bins"><a href="#illegal-bins" class="headerlink" title="illegal_bins"></a>illegal_bins</h5><p>定义不合法的部分，如果出现这些值直接报错。</p>
<h5 id="cross"><a href="#cross" class="headerlink" title="cross"></a>cross</h5><p>在 SystemVerilog 的功能覆盖率（Functional Coverage）中，cross 关键字用于定义交叉覆盖（Cross Coverage）。交叉覆盖是一种分析技术，用于度量两个或多个覆盖点（coverpoints）之间的组合情况。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] y;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] y_values[$]= &#x27;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] z;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] z_values[$]= &#x27;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">        cover_point_y : <span class="keyword">coverpoint</span> y ;</span><br><span class="line">        cover_point_z : <span class="keyword">coverpoint</span> z ;</span><br><span class="line">        cross_yz : <span class="keyword">cross</span> cover_point_y,cover_point_z ;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">foreach</span>(y_values[i])<span class="keyword">begin</span></span><br><span class="line">            y = y_values[i];</span><br><span class="line">            z = z_values[i];</span><br><span class="line">            cg_inst<span class="variable">.sample</span>();</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<h5 id="conditional-Coverage"><a href="#conditional-Coverage" class="headerlink" title="conditional Coverage"></a>conditional Coverage</h5><p>条件覆盖</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> CoverPort;</span><br><span class="line">    <span class="keyword">coverpoint</span> port <span class="keyword">iff</span> (!bus_if<span class="variable">.reset</span>);</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>

<p>当且仅当满足某种条件时才收集sample.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ICer/" rel="tag"># ICer</a>
              <a href="/tags/Programming-Language/" rel="tag"># Programming Language</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2024/02/16/Computer-Architecture/" rel="next" title="Computer Architecture">
      Computer Architecture <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#System-Verilog%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">System Verilog期末复习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SV%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">SV中的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-Dynamic-arrays-Associative-arrays-Queues"><span class="nav-number">1.1.1.</span> <span class="nav-text">Array&#x2F; Dynamic arrays&#x2F;Associative arrays&#x2F;Queues</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quiz"><span class="nav-number">1.1.2.</span> <span class="nav-text">quiz</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-Dynamic-Array"><span class="nav-number">1.1.3.</span> <span class="nav-text">动态数组 Dynamic Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84-Associate-Array"><span class="nav-number">1.1.4.</span> <span class="nav-text">关联数组 Associate Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue-%E9%98%9F%E5%88%97"><span class="nav-number">1.1.5.</span> <span class="nav-text">Queue 队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-Methods"><span class="nav-number">1.1.6.</span> <span class="nav-text">Array Methods:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE-enumerated"><span class="nav-number">1.1.7.</span> <span class="nav-text">枚举 enumerated</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-Structure"><span class="nav-number">1.1.8.</span> <span class="nav-text">结构体 Structure</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-Verilog-Programming-Basic-I"><span class="nav-number">1.2.</span> <span class="nav-text">System Verilog Programming Basic I</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#verilog-style"><span class="nav-number">1.2.1.</span> <span class="nav-text">verilog style</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">1.2.2.</span> <span class="nav-text">操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E3%80%81%E9%80%92%E5%87%8F"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">递增、递减</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inside"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">inside</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dist"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">dist</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#streaming"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">streaming</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#casting-%E5%9B%BA%E5%AE%9A-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">casting  固定(强制类型转换)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Assignment-%E8%B5%8B%E5%80%BC"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">Assignment 赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF"><span class="nav-number">1.2.2.8.</span> <span class="nav-text">分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E5%9D%97-procedural-statements"><span class="nav-number">1.2.2.9.</span> <span class="nav-text">过程块 procedural statements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Loop-%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.2.2.10.</span> <span class="nav-text">Loop 循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#functions-and-tasks-SV%E7%9A%84%E9%87%8D%E7%82%B9"><span class="nav-number">1.2.2.11.</span> <span class="nav-text">functions and tasks(SV的重点)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81-static-automatic"><span class="nav-number">1.2.2.12.</span> <span class="nav-text">变量的静态和动态(static&#x2F;automatic)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SV-%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">1.2.2.13.</span> <span class="nav-text">SV 的参数传递</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quiz-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">quiz</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-Verilog-Programming-Basic-II"><span class="nav-number">1.3.</span> <span class="nav-text">System Verilog Programming Basic II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Interface"><span class="nav-number">1.3.1.</span> <span class="nav-text">Interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8interface"><span class="nav-number">1.3.2.</span> <span class="nav-text">使用interface:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interface-%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E7%AB%AF%E5%8F%A3%E3%80%82"><span class="nav-number">1.3.3.</span> <span class="nav-text">Interface 可以包含端口。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Modport-%E5%AF%B9Interface%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%96%B9%E5%90%91%E8%BF%9B%E8%A1%8C%E9%99%90%E5%88%B6"><span class="nav-number">1.3.4.</span> <span class="nav-text">Modport:对Interface的端口方向进行限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interface%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%94%B3%E6%98%8E%E6%88%96%E8%B0%83%E7%94%A8task-%E5%92%8C-function"><span class="nav-number">1.3.5.</span> <span class="nav-text">Interface中可以申明或调用task 和 function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84Interface"><span class="nav-number">1.3.6.</span> <span class="nav-text">带参数的Interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Virtual-Interface"><span class="nav-number">1.3.7.</span> <span class="nav-text">Virtual Interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Program"><span class="nav-number">1.3.8.</span> <span class="nav-text">Program</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Package"><span class="nav-number">1.3.9.</span> <span class="nav-text">Package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Clocking-block"><span class="nav-number">1.3.10.</span> <span class="nav-text">Clocking block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Race"><span class="nav-number">1.3.11.</span> <span class="nav-text">Race</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LEC-8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.4.</span> <span class="nav-text">LEC 8 面向对象设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.1.</span> <span class="nav-text">类与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HDL%E4%B8%8EOOP%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">HDL与OOP的比较：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AAclass%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">一个class的例子：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">null类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">静态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this"><span class="nav-number">1.4.1.6.</span> <span class="nav-text">this</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.4.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E6%96%B9%E6%B3%95-virtual"><span class="nav-number">1.4.3.</span> <span class="nav-text">虚函数和虚方法(virtual)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cast"><span class="nav-number">1.4.4.</span> <span class="nav-text">cast</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LEC9-%E8%B7%A8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1"><span class="nav-number">1.5.</span> <span class="nav-text">LEC9 跨进程同步与通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.5.1.</span> <span class="nav-text">线程的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SV%E4%B8%AD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.5.2.</span> <span class="nav-text">SV中的过程：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#begin-%E2%80%A6-end"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">begin … end</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fork-join"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">fork join</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">1.5.3.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E3%80%82"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">wait: 事件触发。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#disable"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">disable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EVENTS"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">EVENTS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">1.5.3.3.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#example"><span class="nav-number">1.5.3.3.2.</span> <span class="nav-text">example:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%90%86%E8%A7%A3"><span class="nav-number">1.5.3.3.3.</span> <span class="nav-text">理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#triggered%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.3.3.4.</span> <span class="nav-text">triggered机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#event%E4%B9%8B%E9%97%B4%E5%8F%AF%E4%BB%A5%E7%9B%B8%E4%BA%92%E8%B5%8B%E5%80%BC%E3%80%82"><span class="nav-number">1.5.3.3.5.</span> <span class="nav-text">event之间可以相互赋值。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">Semaphore  信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">1.5.3.4.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SV%E4%B8%AD%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">1.5.3.4.2.</span> <span class="nav-text">SV中信号量的定义：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#example-1"><span class="nav-number">1.5.3.4.3.</span> <span class="nav-text">example:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mailbox"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">Mailbox</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">1.5.3.5.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#example-2"><span class="nav-number">1.5.3.5.2.</span> <span class="nav-text">example</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">1.5.3.5.3.</span> <span class="nav-text">注意事项：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore%E5%92%8CMailbox%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.5.3.6.</span> <span class="nav-text">Semaphore和Mailbox的比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Assertions-%E6%96%AD%E8%A8%80"><span class="nav-number">1.6.</span> <span class="nav-text">Assertions 断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFassertion"><span class="nav-number">1.6.1.</span> <span class="nav-text">什么是assertion?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%AD%E8%A8%80%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">断言的用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#example-3"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">example:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assertion-Based-Verification"><span class="nav-number">1.6.2.</span> <span class="nav-text">Assertion Based Verification</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assertion-%E5%BA%93"><span class="nav-number">1.6.3.</span> <span class="nav-text">Assertion 库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assertion%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="nav-number">1.6.4.</span> <span class="nav-text">Assertion的分类：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Immediate-Assertions%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">Immediate Assertions举例：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SV%E7%9A%84%E8%B0%83%E5%BA%A6%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.6.4.1.1.</span> <span class="nav-text">SV的调度顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%96%AD%E8%A8%80-Concurrent-assertions%EF%BC%9A"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">并发断言 Concurrent assertions：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#example-4"><span class="nav-number">1.6.4.2.1.</span> <span class="nav-text">example:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sequence"><span class="nav-number">1.6.5.</span> <span class="nav-text">sequence</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E5%BA%8F%E6%A3%80%E6%9F%A5"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">时序检查</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#example-5"><span class="nav-number">1.6.5.1.1.</span> <span class="nav-text">example</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D-repetition"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">重复(repetition)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#consecutive-repetition"><span class="nav-number">1.6.5.2.1.</span> <span class="nav-text">consecutive repetition</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#example-6"><span class="nav-number">1.6.5.2.1.1.</span> <span class="nav-text">example</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Goto-Repetition"><span class="nav-number">1.6.5.2.2.</span> <span class="nav-text">Goto Repetition</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#example-7"><span class="nav-number">1.6.5.2.2.1.</span> <span class="nav-text">example</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Nonconsecutive-Repetition"><span class="nav-number">1.6.5.2.3.</span> <span class="nav-text">Nonconsecutive Repetition</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#example-8"><span class="nav-number">1.6.5.2.3.1.</span> <span class="nav-text">example</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#throughout-%E6%8C%81%E7%BB%AD"><span class="nav-number">1.6.5.3.</span> <span class="nav-text">throughout 持续</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#example-9"><span class="nav-number">1.6.5.3.1.</span> <span class="nav-text">example</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#within"><span class="nav-number">1.6.5.4.</span> <span class="nav-text">within</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#example-10"><span class="nav-number">1.6.5.4.1.</span> <span class="nav-text">example</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#and"><span class="nav-number">1.6.5.5.</span> <span class="nav-text">and</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#example-11"><span class="nav-number">1.6.5.5.1.</span> <span class="nav-text">example</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#intersect-%E4%BA%A4%E9%9B%86"><span class="nav-number">1.6.5.6.</span> <span class="nav-text">intersect 交集</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#example-12"><span class="nav-number">1.6.5.6.1.</span> <span class="nav-text">example</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%92%8Cthroughout%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.5.6.2.</span> <span class="nav-text">和throughout的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#or"><span class="nav-number">1.6.5.7.</span> <span class="nav-text">or</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#example-13"><span class="nav-number">1.6.5.7.1.</span> <span class="nav-text">example</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#property"><span class="nav-number">1.6.6.</span> <span class="nav-text">property</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#example-14"><span class="nav-number">1.6.6.1.</span> <span class="nav-text">example:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.6.6.2.</span> <span class="nav-text">系统函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#property-%E7%9A%84%E5%90%A6%E5%AE%9A"><span class="nav-number">1.6.6.3.</span> <span class="nav-text">property 的否定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%95%B4%E5%90%AB%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="nav-number">1.6.6.4.</span> <span class="nav-text">蕴含操作：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ended%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8E%A7%E5%88%B6%E6%96%AD%E8%A8%80%E6%A3%80%E6%9F%A5%E7%9A%84%E6%97%B6%E9%97%B4"><span class="nav-number">1.6.6.5.</span> <span class="nav-text">ended关键词控制断言检查的时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#disable-iff"><span class="nav-number">1.6.6.6.</span> <span class="nav-text">disable iff</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#assert"><span class="nav-number">1.6.7.</span> <span class="nav-text">assert</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sequence-property-assert%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="nav-number">1.6.7.1.</span> <span class="nav-text">sequence,property,assert的关系：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.6.7.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%BF%E7%9C%9F%E4%B8%AD%E5%8A%A0%E5%85%A5assertion"><span class="nav-number">1.6.8.</span> <span class="nav-text">如何在仿真中加入assertion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8testbench%E4%B8%AD%E7%BB%91%E5%AE%9Aassertion%E6%A8%A1%E5%9D%97"><span class="nav-number">1.6.9.</span> <span class="nav-text">如何在testbench中绑定assertion模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Random-coverage"><span class="nav-number">1.7.</span> <span class="nav-text">Random coverage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ramdom%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.7.1.</span> <span class="nav-text">使用ramdom的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sv-%E4%B8%AD%E7%9A%84random"><span class="nav-number">1.7.2.</span> <span class="nav-text">sv 中的random</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97rand"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">关键字rand</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#randc-random-cycle"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">randc (random cycle)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constraint-block"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">constraint block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3%E5%99%A8randomize"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">求解器randomize()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pre-randomize-%E5%92%8Cpost-randomize"><span class="nav-number">1.7.2.5.</span> <span class="nav-text">pre_randomize()和post_randomize()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inside-%E6%8C%87%E5%AE%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-number">1.7.2.6.</span> <span class="nav-text">inside 指定表达式的范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dist-%E6%8C%87%E5%AE%9A%E6%9D%83%E9%87%8D%E5%88%86%E5%B8%83"><span class="nav-number">1.7.2.7.</span> <span class="nav-text">dist 指定权重分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.7.2.8.</span> <span class="nav-text">多维约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.7.2.9.</span> <span class="nav-text">条件约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.2.10.</span> <span class="nav-text">约束的概率问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.7.2.11.</span> <span class="nav-text">迭代约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#solve-before-%E6%8E%A7%E5%88%B6%E6%B1%82%E8%A7%A3%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.7.2.12.</span> <span class="nav-text">solve before :控制求解顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#function-in-constraints"><span class="nav-number">1.7.2.13.</span> <span class="nav-text">function in constraints</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constraint-mode-%E6%8E%A7%E5%88%B6%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD"><span class="nav-number">1.7.2.14.</span> <span class="nav-text">constraint mode: 控制约束的开启和关闭</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%8E%87"><span class="nav-number">1.7.3.</span> <span class="nav-text">覆盖率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">代码覆盖率的类型：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87Functional-Coverage%EF%BC%89%EF%BC%9A"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">功能覆盖率Functional Coverage）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cover-group"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">cover group</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#coverage-point"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">coverage point</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bin-%EF%BC%9A%E5%AF%B9%E5%8A%9F%E8%83%BD%E7%82%B9%E5%88%86%E7%BB%84"><span class="nav-number">1.7.3.5.</span> <span class="nav-text">bin ：对功能点分组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Transitional-functional-point-bin"><span class="nav-number">1.7.3.5.1.</span> <span class="nav-text">Transitional functional point bin</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#wildcard-bin-%E9%80%9A%E9%85%8D%E5%88%86%E7%BB%84"><span class="nav-number">1.7.3.5.2.</span> <span class="nav-text">wildcard bin:通配分组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ignore-bin-%E5%BF%BD%E7%95%A5%E7%9A%84%E5%88%86%E7%BB%84"><span class="nav-number">1.7.3.5.3.</span> <span class="nav-text">ignore_bin 忽略的分组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#illegal-bins"><span class="nav-number">1.7.3.5.4.</span> <span class="nav-text">illegal_bins</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cross"><span class="nav-number">1.7.3.5.5.</span> <span class="nav-text">cross</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#conditional-Coverage"><span class="nav-number">1.7.3.5.6.</span> <span class="nav-text">conditional Coverage</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang xianke</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Wangxianke123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Wangxianke123" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang xianke</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">150k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:33</span>
</div>

        








      </div>
      <script src="https://Wangxianke123.github.io/live2d/autoload.js"></script>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>

</html>
