<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangxianke123.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="计算机体系结构的课程笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Computer Architecture">
<meta property="og:url" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/index.html">
<meta property="og:site_name" content="花间一壶酒">
<meta property="og:description" content="计算机体系结构的课程笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-2.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-3.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-4.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-5.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-6.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-7.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-9.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-8.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-10.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-11.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-12.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-13.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-14.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-15.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-16.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-17.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-18.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-19.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-20.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-21.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-22.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-24.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-25.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-26.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-27.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-29.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-33.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-30.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-31.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-32.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-34.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-40.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-41.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-36.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-37.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-38.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-39.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-42.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-43.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-44.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-45.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-46.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-47.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-48.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-49.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-50.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-51.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-52.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-53.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-54.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-55.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-56.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-57.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-58.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-60.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-59.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-61.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-62.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-63.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-64.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-65.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-67.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-68.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-69.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-70.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-71.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-72.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-73.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-74.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-75.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-76.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-77.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-78.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-79.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-80.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-81.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-82.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-83.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-84.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-85.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-86.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-87.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-88.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-89.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-90.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-91.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-92.png">
<meta property="og:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-93.png">
<meta property="article:published_time" content="2024-02-16T10:38:33.000Z">
<meta property="article:modified_time" content="2024-04-18T06:25:45.478Z">
<meta property="article:author" content="Wang xianke">
<meta property="article:tag" content="CA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/image-2.png">

<link rel="canonical" href="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Computer Architecture | 花间一壶酒</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">花间一壶酒</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">举杯邀明月，对影成三人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wangxianke123.github.io/2024/02/16/Computer-Architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang xianke">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花间一壶酒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Computer Architecture
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-16 18:38:33" itemprop="dateCreated datePublished" datetime="2024-02-16T18:38:33+08:00">2024-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-18 14:25:45" itemprop="dateModified" datetime="2024-04-18T14:25:45+08:00">2024-04-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">notes</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>43 分钟</span>
            </span>
            <div class="post-description">计算机体系结构的课程笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="高等计算机体系结构课程笔记"><a href="#高等计算机体系结构课程笔记" class="headerlink" title="高等计算机体系结构课程笔记"></a>高等计算机体系结构课程笔记</h1><h2 id="chapter1-Overview-and-Fundamental"><a href="#chapter1-Overview-and-Fundamental" class="headerlink" title="chapter1 Overview and Fundamental"></a>chapter1 Overview and Fundamental</h2><p>1.什么是计算机体系结构(Computer Architecture)?<br>    CA &#x3D; 指令集+微架构+硬件实现  (不单单是指令集设计)</p>
<p>1.指令集的概念：指令集是规定处理器外在行为的一系列内容的统称，是软件人员和硬件设计师之间的桥梁。同一个指令集体系会有多种硬件实现方式，称为微体系结构(microarchitecture)。</p>
<p>2.指令集的基本要素：<br>    指令集的分类(CISC or RISC)、<br>    内存地址分配（对齐方式、大端、小端）<br>    寻址模式（寄存器、立即数、etc）<br>    操作类型和码长<br>    操作内容（控制指令、存储指令、运算指令）<br>    控制流（jump、branch、return）、<br>    编码方式 (定长(MIPS)or变长(X86)) </p>
<p>3.CISC和RISC：</p>
<pre><code>CISC:(Complex Instruction Set Computer)复杂指令集计算机   代表：x86
RISC：(Reduced Instruction Set Computer)精简指令集计算机  代表：MIPS,ARM,RISCV
</code></pre>
<p>4:功耗墙与暗硅。功耗墙：芯片在工作时，如果功率超过某个临界值，就会使热量积累速度超过通过技术手段进行冷却的速度(风扇或水冷等),从而使局部温度不断升高，对芯片本身产生故障甚至永久损害。因此需要将芯片设计为在某个特定功率以下进行工作，即功耗墙。<br>暗硅：由于功耗墙的存在，一块芯片运行时，其上的所有晶体管并不在同一时间全部处于工作状态，这部分没有在工作的晶体管被称为暗硅。由于功耗墙和暗硅的存在，单纯依靠增大芯片面积或进行堆叠来提高芯片性能的做法是行不通的，必须同时考虑芯片的能效(energy efficiency)。<br>PS:集成电路的动态功耗正比于电压的平方x电容x频率。功耗墙的存在同时决定了单纯依靠提升频率来提升电路性能的做法是有极限的。</p>
<p>5:Thermal Design Power(TDP):热设计功耗。TDP 是一个指标，用于表示最大热输出，即一个芯片在运行最大负载时所产生的最大热量。这个值对于散热系统的设计至关重要，因为它帮助确保计算机的冷却系统能够有效地处理和散发这些热量，从而防止过热。</p>
<p>6.Dennard Scaling:随着晶体管尺寸缩小，它们的电压会等比例减小，在保持功耗密度不变的情况下，晶体管可以工作在更高的频率，从而提升了算力。然而随着功耗墙的出现，Dennard Scaling面临着终结。</p>
<p>7.计算机设计的2大原则：1.利用并行2.利用局部性原理</p>
<p>并行的相关术语：ILP（指令级并行）、DLP（数据级并行）、TLP（线程级并行）<br>SISD\SIMD\MISD\MIMD</p>
<p>局部性原理：局部性原理基于这样一个观察：程序在执行时倾向于从相对集中的内存位置重复访问数据和指令。局部性主要分为两种类型：</p>
<p>时间局部性（Temporal Locality）：这种类型的局部性指的是如果一个数据项被访问，那么它在不久的将来很可能会被再次访问。例如，程序中的循环可能多次访问相同的变量或指令。</p>
<p>空间局部性（Spatial Locality）：空间局部性指的是如果一个数据项被访问，那么它附近的数据项很快也可能被访问。这通常是由于数据结构的存储方式（如数组）或程序的顺序执行特性。</p>
<p>8.Amdahl’s Law: <img src="/2024/02/16/Computer-Architecture/image-2.png" alt="Alt text"><br>理解：某一部分的速度提升对总体速率提升的影响，需要考虑其在整体中占据的比例。<br>例：<br><img src="/2024/02/16/Computer-Architecture/image-3.png" alt="Alt text"><br><img src="/2024/02/16/Computer-Architecture/image-4.png" alt="Alt text"><br><img src="/2024/02/16/Computer-Architecture/image-5.png" alt="Alt text"></p>
<p>9.CPU Time和CPI计算：<br><img src="/2024/02/16/Computer-Architecture/image-6.png" alt="Alt text"></p>
<p>上式中，Instruction count由算法决定,Cycles per Instruction由体系结构决定，CLock cycle time由工艺决定。</p>
<p>CPI：clock cycles per instruction:<img src="/2024/02/16/Computer-Architecture/image-7.png" alt="Alt text"></p>
<h2 id="Chapter2-Memory-Hierarchy"><a href="#Chapter2-Memory-Hierarchy" class="headerlink" title="Chapter2 Memory Hierarchy"></a>Chapter2 Memory Hierarchy</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>为什么需要Memory Hierarchy?  <ol>
<li>存储墙的存在，运算单元的速度远远超过存储单元的速度（存储的发展主要是越来越大的容量或带宽，但速度的提升有限）。 导致计算机的性能瓶颈主要在于数据的搬运和存取，而非计算的速度。<br> <img src="/2024/02/16/Computer-Architecture/image-9.png" alt="Alt text"></li>
<li>同时高速存储(register、SRAM)的制造价格远远高于普通的低速存储(DRAM,FLASH),导致从成本的角度，无法做到在整个计算机系统中全部使用昂贵的高速存储。<br> <img src="/2024/02/16/Computer-Architecture/image-8.png" alt="Alt text"></li>
<li>但是，从程序运行的角度讲，我们总是希望能够用以足够大的，乃至近乎无限的存储空间。  </li>
<li>因为局部性原理的存在，使Memory Hierarchy成为可能。</li>
</ol>
</li>
</ol>
<p>2.什么是Memory Hierarchy?<br>    Memory hierarchy”（内存层次结构）是指一种组织和管理计算机内存系统的方式，它将不同类型的存储按照速度、成本和容量进行分层。所有的内存地址空间构建在一个最大的，同时也是最慢的内存结构上，而每一级的更快、更小的内存构成上一级的一个子集。</p>
<p>3.Cache的概念。<br>   缓存（Cache）是计算机体系结构中的一个关键组件，用于存储临时数据，以便快速访问。它位于处理器和主内存之间，旨在减少处理器访问主内存所需的平均时间。<br>   <strong>速度</strong>：缓存比主内存快得多，但比处理器内部的寄存器慢。<br>    <strong>大小</strong>：一般而言，缓存比主内存小得多，因此只能存储有限的数据。<br>    <strong>临时存储</strong>：缓存存储最近或最频繁使用的数据，以便快速访问。<br>    <strong>透明性</strong>：对于程序和用户来说，缓存的存在和操作通常是透明的。  </p>
<h3 id="Cache的原理及设计原则"><a href="#Cache的原理及设计原则" class="headerlink" title="Cache的原理及设计原则"></a>Cache的原理及设计原则</h3><ol>
<li><p>原理：本质上讲，Cache能够起效还是利用了程序的局部性原理。<br> 时间局部性：如果一个数据项最近被访问过，那么它在不久的将来可能会被再次访问。<br> 空间局部性：如果一个数据项被访问，那么它附近的数据项不久后也可能被访问。</p>
</li>
<li><p>Cache的设计主要需要考虑以下因素：  </p>
<ol>
<li>数据的摆放：什么样的数据可以从内存中放入Cache，以及按照什么样的规则摆放？ （<strong>全相联、直接映射、多路组相联</strong>）   </li>
<li>数据的寻找：数据摆放之后，如何寻找到想要的数据？（<strong>寻址策略，cache miss,hit</strong>）      </li>
<li>如何进行数据块的更换？（<strong>FIFO,LRU</strong>）  </li>
<li>对cache进行写操作时，采用何种写策略？(<strong>Write through、Write Back</strong>)</li>
</ol>
</li>
</ol>
<h4 id="数据块的摆放-Block-Placement"><a href="#数据块的摆放-Block-Placement" class="headerlink" title="数据块的摆放(Block Placement)"></a>数据块的摆放(Block Placement)</h4><p><img src="/2024/02/16/Computer-Architecture/image-10.png" alt="Alt text"></p>
<p><strong>全相联</strong>：任何一个数据块可以放在Cache的任何位置。<br>    优点：可以充分利用Cache的空间。缺点：数据寻址的开销增大  （一般不用这个）</p>
<p><strong>直接映射</strong>：数据块经过某种映射规则（通常是简单哈希，如编号 mod 8）后放入相应编号的Block.  (mod 几取决于cache中的block个数)<br>    优点：寻址方便  缺点，容易造成空间浪费，导致cache miss和频繁的数据换入换出</p>
<p><strong>多路组相联</strong>：是以上二者的折中，首先将cache中的block分路，一个数据块经过映射后，可以任何一个路的对应位置。（一个块有n个位置可放称作n路组相连，注意区分<strong>路</strong>和<strong>组</strong>）</p>
<h4 id="数据块的寻址"><a href="#数据块的寻址" class="headerlink" title="数据块的寻址"></a>数据块的寻址</h4><p>不同的摆放策略带来不同的寻址（或地址编码）方式：<br>以多路组相联为例：<br> <img src="/2024/02/16/Computer-Architecture/image-11.png" alt="Alt text"></p>
<p> 不同数据的作用： offset的作用是在block内进行索引，首先需要明确的是，计算机系统中的地址索引通常以字节Byte为单位，因此，如果一个Block的容量大于1个字节（通常是16B即4Words），则需要进行bolck内的偏移(offset)。<br> index的大小等于set中block的个数。(如每个set 拥有256个blocks，则index为8位)。<br> Tag作为地址的剩余位，一起写入cache中，用于作为标签比较，Tag一致则说明cache命中。</p>
<p> <img src="/2024/02/16/Computer-Architecture/image-12.png" alt="Alt text"></p>
<p>上述多路组相联的寻址策略，是直接根据index取出所有way中的对应数据，然后通过tag比对丢弃剩余的数据，只保留所需要的数据。<br>对于直接映射，地址编码中的offset用于块内的字索引。<br>对于全相联，地址编码中不存在index。  </p>
<p>例题：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-13.png" alt="Alt text"></p>
<p>解：4路,一共1KB,每路256B，缓存行32B,行数为256&#x2F;32 &#x3D; 8，index为3，offset为5，tag4位。</p>
<p><strong>（考试必考，为数不多可以出计算题的地方）</strong></p>
<h4 id="数据块替换策略"><a href="#数据块替换策略" class="headerlink" title="数据块替换策略"></a>数据块替换策略</h4><p>分情况讨论：  </p>
<ol>
<li>处理器在Cache中拿到了想要的数据(Tag比对正确，Valid有效)，称为Cache hit,皆大欢喜。</li>
<li>Tag比对失败，或Valid无效，需要对Cache进行Block的替换，称为Cache miss。<br> 对于直接映射的策略，则直接进行一次映射然后进行替换。<br> 对于全相联或多路组相联，则需要考虑具体替换哪一路中的数据。 具体策略可以有：完全随机，LRU(Least recently used),FIFO(First in First out)。</li>
</ol>
<h4 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h4><p>核心矛盾：对cache中的数据进行写操作，导致cache和主存中的数据产生不一致，此时有2种选择：</p>
<ol>
<li>立即更新主存中的数据(称为写穿透，write through)</li>
<li>额外增加一个dirty位，当一个被改写的数据块被从cache换出时，再将主存中的数据进行更新,称为(write back)</li>
</ol>
<p>一般都是用write back,因为write through开销太大。</p>
<p>一种解决写主存耗时过长的策略： write buffer。<br><img src="/2024/02/16/Computer-Architecture/image-14.png" alt="Alt text"></p>
<p>把要写的数据丢给buffer让它写，然后接着干自己的活。（write back 和write through都能用）</p>
<p>当写miss发生时，write through有2中选择，直接改写主存中的数据，而不把数据搬入cache,或者既写又搬。对应write back,一般而言需要先把数据搬入主存。</p>
<h4 id="Cache-性能对CPI的影响"><a href="#Cache-性能对CPI的影响" class="headerlink" title="Cache 性能对CPI的影响"></a>Cache 性能对CPI的影响</h4><p><img src="/2024/02/16/Computer-Architecture/image-15.png" alt="Alt text"></p>
<p>例题：<br><img src="/2024/02/16/Computer-Architecture/image-16.png" alt="Alt text"></p>
<p>解：一开始的CPI为1，每条指令耗时1个周期，4Ghz的处理器，每个周期时长为0.25ns，故每条指令的平均耗时为0.25ns。2%的Miss rate,每条指令的平均耗时变为：（$0.02\times 100ns+ 0.25ns &#x3D; 2.25ns$ ）</p>
<p>增加2级cache,每条指令的平均耗时变为：($0.005\times 100ns + 0.02\times 5 ns +  0.25ns &#x3D; 0.85ns$)</p>
<p>加速比： $2.25&#x2F;0.85 &#x3D; 2.6$</p>
<p>或从CPI角度进行计算：一级cache的失效代价为：$100ns&#x2F;0.25ns &#x3D; 400$个clock cycle,<br>因此平均CPI为：$1+0.02\times 400 &#x3D; 9$,</p>
<p>增加2级缓存后，cache2的访问或miss需要：<br>$5ns&#x2F;0.25ns &#x3D; 20$个clock cycle,<br> CPI为：$1+0.02\times 20 + 0.005\times 400&#x3D; 3.4$</p>
<p> 加速比：$9&#x2F;3.4 &#x3D; 2.6$</p>
<h4 id="影响cache性能的4C因素"><a href="#影响cache性能的4C因素" class="headerlink" title="影响cache性能的4C因素"></a>影响cache性能的4C因素</h4><ol>
<li><p>强制性缺失（Compulsory Misses）</p>
<ol>
<li>这些缺失发生在第一次访问数据时，因为这时数据还没有被加载到缓存中。</li>
<li>强制性缺失也被称为“冷启动缺失”或“首次访问缺失”。</li>
<li>减少强制性缺失的方法有限，因为它们是程序运行的必然结果。预取策略（将数据提前加载到缓存中）可以在一定程度上帮助减少这类缺失。</li>
</ol>
</li>
<li><p>容量缺失（Capacity Misses）</p>
<ol>
<li>当缓存的容量不足以存储所有需要的数据时，就会发生容量缺失。</li>
<li>这种缺失表明缓存无法容纳程序工作集（即同时活跃的数据集合）。</li>
<li>增加缓存大小是减少容量缺失的直接方法，但这也会增加成本和可能增加访问延迟。</li>
</ol>
</li>
<li><p>冲突缺失（Conflict Misses）</p>
<ol>
<li>冲突缺失发生在缓存可以容纳更多数据，但由于缓存映射策略（如直接映射或组相联映射）的限2制，不同的数据块争用相同的缓存位置。</li>
<li>在直接映射缓存中，这种情况最为常见。</li>
<li>通过使用更复杂的映射策略（如全相联或更高程度的组相联）可以减少冲突缺失，但这可能增加硬件复杂性和成本。</li>
</ol>
</li>
<li><p>一致性问题（Coherency）</p>
<ol>
<li>在多核或多处理器系统中，维持缓存一致性是一个重要问题。</li>
<li>缓存一致性问题是指当多个缓存副本存储相同数据时，确保所有副本在任何时刻都是一致的。</li>
<li>缓存一致性问题不直接导致缺失，但它会影响系统的整体性能和正确性。</li>
<li>解决方案包括缓存一致性协议，如MESI（修改、独占、共享、无效）协议。(第5章)</li>
</ol>
</li>
</ol>
<h3 id="6种基础的Cache性能优化"><a href="#6种基础的Cache性能优化" class="headerlink" title="6种基础的Cache性能优化"></a>6种基础的Cache性能优化</h3><p>考虑某种优化策略对Cache性能带来的影响，主要分为以下4个维度：  </p>
<ol>
<li>访存(命中)时间(hit time)</li>
<li>未命中率(Miss rate)</li>
<li>未命中的代价(Miss Penalty)</li>
<li>硬件设计复杂度或成本</li>
</ol>
<table>
<thead>
<tr>
<th>Methods</th>
<th>hit time</th>
<th>Miss rate</th>
<th>Miss penalty</th>
<th>Hardware Complexity or Cost</th>
</tr>
</thead>
<tbody><tr>
<td>Larger Block Size</td>
<td>$\uparrow$</td>
<td>$\downarrow$(主要是降低了Copullsory Miss)</td>
<td>$\uparrow$</td>
<td>几乎不变</td>
</tr>
<tr>
<td>Larger Capacity</td>
<td>$\uparrow$</td>
<td>$\downarrow$(主要是降低了Capacity Miss)</td>
<td>几乎不变</td>
<td>$\uparrow$</td>
</tr>
<tr>
<td>High Associativity</td>
<td>$\uparrow$</td>
<td>$\downarrow$(主要是降低了Conflict Miss)</td>
<td>几乎不变</td>
<td>$\uparrow$</td>
</tr>
<tr>
<td>More Cache Levels</td>
<td>不变</td>
<td>对于各级来说保持不变</td>
<td>$\downarrow$</td>
<td>$\uparrow$</td>
</tr>
<tr>
<td>Read misses over Write</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Address Translation(虚拟内存和TLB技术)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="10种进阶优化策略"><a href="#10种进阶优化策略" class="headerlink" title="10种进阶优化策略"></a>10种进阶优化策略</h3><table>
<thead>
<tr>
<th>Methods</th>
<th>hit time</th>
<th>Miss rate</th>
<th>Miss penalty</th>
<th>Hardware Complexity or Cost</th>
</tr>
</thead>
<tbody><tr>
<td>Small and simple L1 Cache</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Way Prediction</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Piplined Cache Accesses</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Non-blocking-Cache</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Multibanked Caches</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Critical word first and early restart</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Merging write buffer</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Compiler optimization</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hardware Prefetching</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Compiler-controled prefetching</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ol>
<li><p><strong>什么是虚拟存储器，为什么要有虚拟存储器？</strong><br> 在实际使用计算机时，一个进程(或程序)可能需要的地址空间过大，使得整个内存都无法装下。或者对于多个进程，每个进程都需要自己的地址空间，超过了内存空间的总量。因此需要虚拟内存技术。<br> 虚拟内存（Virtual Memory）是计算机系统内存管理的一项关键技术。它使得操作系统通过将物理存储器和内存一同抽象为虚拟内存，从而为软件提供比实际物理内存更大的内存空间。(可以理解为，将内存作为硬盘的cache,构成整个虚拟内存空间)虚拟内存的实现方法：MMU(Memory Management Unit)+OS(Operation System)</p>
</li>
<li><p><strong>虚拟内存的优点：</strong></p>
<ol>
<li>更大的内存空间：程序可以使用比实际物理内存更多的内存。</li>
<li>内存保护：每个程序有自己的虚拟地址空间，避免了程序间的内存冲突。</li>
<li>数据共享和内存映射文件：程序可以更容易地共享数据，并将文件直接映射到内存中，以提高数据访问速度。</li>
</ol>
</li>
<li><p><strong>虚拟地址和物理地址</strong>：虚拟地址（virtual address）是程序员看到的虚拟地址空间。物理地址（physical address）是主存或硬盘上的实际地址。虚拟内存为每个程序提供了一种看似独占的内存抽象，称为虚拟地址空间。这意味着每个程序都认为自己拥有连续的、完整的内存空间，而实际上，这些空间可能是非连续的，甚至不完全存在于物理内存中。<br><img src="/2024/02/16/Computer-Architecture/image-17.png" alt="Alt text"></p>
</li>
</ol>
<h4 id="虚拟地址和物理地址的转换"><a href="#虚拟地址和物理地址的转换" class="headerlink" title="虚拟地址和物理地址的转换"></a>虚拟地址和物理地址的转换</h4><ol>
<li><p>页（Paging）：虚拟内存通常以“页”的形式组织，每页是一个固定大小的内存块（例如4K）。虚拟地址空间被分割成多个这样的页，它们可以独立地映射到物理内存中的页，或者在需要时存储到磁盘上。</p>
</li>
<li><p>页表（Page Table）：操作系统维护一个页表来追踪虚拟页和物理页之间的映射关系。当程序访问其虚拟内存中的地址时，页表用来查找相应的物理内存地址。</p>
</li>
</ol>
<p><img src="/2024/02/16/Computer-Architecture/image-18.png" alt="Alt text"><br><img src="/2024/02/16/Computer-Architecture/image-19.png" alt="Alt text"><br>3个关键问题：</p>
<ol>
<li><p>页表放在哪？<br> 放在内存中，通过虚拟地址的virtual page number,进行查表，得到physical page number。</p>
</li>
<li><p>页表放在内存中，怎么找到它？<br> CPU中专门有一个page table register,记录了页表的首地址(相当于一个指针)。</p>
</li>
<li><p>页表如何工作？<br> 每个进程有自己独立的页表（意味着独立的地址空间）、PC以及寄存器的值。存储在内存中的不同位置。当OS进行进程切换时，CPU读入对应进程的页表寄存器，PC以及其它状态寄存器，该进程便转为Active 状态。</p>
</li>
</ol>
<h4 id="缺页中断（Page-Fault）"><a href="#缺页中断（Page-Fault）" class="headerlink" title="缺页中断（Page Fault）"></a>缺页中断（Page Fault）</h4><p>当程序访问的虚拟内存页不在物理内存中时，会发生缺页中断。操作系统将处理这种中断，从磁盘中加载所需的页到物理内存，并更新页表。</p>
<p>由于磁盘的访问时间很长，此时操作系统会进行进程切换。</p>
<p>缺页后的替换策略，通常使用LRU算法。一个由OS实现的伪LRU算法：<br><img src="/2024/02/16/Computer-Architecture/image-20.png" alt="Alt text"></p>
<h4 id="快表TLB-Translation-Look-aside-Buffer"><a href="#快表TLB-Translation-Look-aside-Buffer" class="headerlink" title="快表TLB(Translation Look-aside Buffer)"></a>快表TLB(Translation Look-aside Buffer)</h4><ol>
<li><p><strong>为什么要有TLB？</strong><br>在虚拟内存的背景下，CPU拿到一个在内存中的数据，需要经过以下阶段： </p>
<ol>
<li>访问页表，根据虚拟地址的virtual page number,进行查表，得到physical page number。（相当于访问了一次，内存）。</li>
<li>根据Physical page number，和virtual address中的page offset结合，得到实际的物理地址，根据这个物理地址，再次访问内存。</li>
</ol>
<p>这个过程的问题在于，每当想要拿到一个在内存中的数据，需要访问2次内存。能否加速这个过程？</p>
</li>
<li><p><strong>TLB的原理</strong><br> TLB的原理就一句话，将部分使用频繁的页表表项建立为一个cache。TLB是一个小型、高速的缓存，存储了最近使用的一小部分虚拟地址到物理地址的映射关系。</p>
<p> <img src="/2024/02/16/Computer-Architecture/image-21.png" alt="Alt text"></p>
<p> <strong>注意：不是说TLB放在cache里，而是TLB自己就是一个cache。是专门针对页表建立的cache。</strong></p>
</li>
<li><p><strong>TLB Miss</strong><br> 只要是cache，就会有cache miss。TLB miss 的情况和cache miss类似，但是需要考虑页表中也不存在对应页的情况(相当于2级缓存全部miss)（缺页中断）</p>
</li>
</ol>
<h4 id="TLB和cache的交互"><a href="#TLB和cache的交互" class="headerlink" title="TLB和cache的交互"></a>TLB和cache的交互</h4><p>在使用了虚拟内存和TLB后，引入一个新的问题，TLB和cache之间如何交互？<br>具体来讲，CPU通过一个地址访问cache时，这个地址是虚拟地址，还是物理地址？</p>
<ol>
<li><p>PIPT（Physically Indexed, Physically Tagged）<br><img src="/2024/02/16/Computer-Architecture/image-22.png" alt="Alt text"></p>
<ol>
<li>在这种方式中，缓存使用物理地址进行索引和标记。  </li>
<li>这要求在访问缓存之前，必须先通过TLB将虚拟地址翻译成物理地址。</li>
<li>物理寻址的优势在于它避免了缓存别名问题（即多个虚拟地址映射到同一物理地址的情况），但它增加了访问缓存之前的延迟。<br>优点是简单，缺点是相当于访问了2次cache。</li>
</ol>
</li>
<li><p>VIVT（Virtually Indexed, Virtually Tagged）</p>
<ol>
<li>在这种方式中，缓存使用虚拟地址进行索引和标记。</li>
<li>这允许直接使用虚拟地址访问缓存，无需等待TLB翻译，从而减少了访问延迟。</li>
<li>但虚拟寻址带来了缓存一致性的问题，因为不同的虚拟地址可能映射到相同的物理地址。</li>
</ol>
</li>
<li><p>VIPT（Virtually Indexed, Physically Tagged）</p>
<ol>
<li><p>索引（Indexing）：缓存使用虚拟地址进行索引。这意味着在访问缓存以确定一个缓存行是否存在时，不需要等待虚拟地址到物理地址的转换。这样可以减少访问缓存的延迟，因为索引操作可以并行于TLB的地址翻译。</p>
</li>
<li><p>标记（Tagging）：缓存使用物理地址的标记。这意味着一旦确定了缓存行的位置，缓存使用物理地址的标签来确定是否命中。这样做的好处是维护缓存一致性和避免缓存别名问题，因为物理地址是全局唯一的。</p>
</li>
<li><p>地址转换：在VIPT缓存中，地址转换（即从虚拟地址到物理地址的转换）仍然需要进行，但其时间可以与访问缓存的索引过程重叠。</p>
</li>
</ol>
</li>
<li><p>PIVT（Physically Indexed, Virtually Tagged）<br> 理论上存在，但没啥用</p>
</li>
</ol>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>首先考虑一个页表大小的问题：假设有32位虚拟地址，每页大小为4KB, 每个页表表项(PTE, Page Table Entry)大小为4B。</p>
<p>32位地址能够编码的页数为： $2^{32}&#x2F;4K &#x3D; 2^{20}$<br>而每个页表表项大小为4B,为了存储所有这些表项，页表的大小为：$2^{20}\times4B &#x3D; 4MB$<br>也就是说，仅存储页表，就需要消耗主存中4MB中的空间。</p>
<p>如果是64位，这个数字变成 $2^{54}MB&#x3D;2^{44}GB$远远超过了内存的全部大小！！</p>
<p>因此需要多级页表。将上述4MB的页表分为1K个小页表。每个小页表大小为4KB，对应1000个页。将每个小页表看作一个需要寻址的地址。对这1k个小页表再建立一个页表，则新的页表有1000个表项，每个表项的索引长度为10。加上标签后表项大小变为4B，这个新的“页表的页表”的大小为1000*4B&#x3D;4KB，这样，只需要将这个二级页表放入主存，然后将部分一级页表(被分割的小页表)也放入主存，就能减少主存中的页表占用大小。</p>
<p>二级页表之所以能减少对主存空间的占用，主要是因为并不是所有的页表都需要常驻在主存中。这种设计允许操作系统按需加载和卸载页表，从而有效地管理大型虚拟地址空间，而不必为每个可能的虚拟地址都保留固定的物理内存空间。</p>
<h2 id="Chapter-3-指令级并行及其扩展"><a href="#Chapter-3-指令级并行及其扩展" class="headerlink" title="Chapter 3 指令级并行及其扩展"></a>Chapter 3 指令级并行及其扩展</h2><p>指令级并行的实现原理：流水线技术(Piplining)</p>
<p>并行的问题：三种Hazard:</p>
<ol>
<li><p><strong>结构冲突（Structural Hazards）</strong></p>
<ol>
<li>定义：当硬件资源不足以支持所有流水线阶段同时进行时，就会发生结构冲突。</li>
<li>举例：如果只有一个内存单元，但在同一时刻，流水线中的一个阶段需要读取指令，而另一个阶段需要读写数据，这就会导致结构冲突。</li>
<li>解决办法：增加资源（如多个内存单元、专用指令和数据缓存等），或者在设计时对资源进行时间复用。</li>
<li></li>
</ol>
</li>
<li><p><strong>数据冲突（Data Hazards）</strong></p>
<ol>
<li>定义：当流水线中的指令依赖于前一条或多条指令的结果时，就会发生数据冲突。</li>
<li>类型：<br> RAW（Read After Write）：后续指令需要读取前一条指令写入的数据。<br> WAR（Write After Read）：写入操作与前面的读取操作冲突。<br> WAW（Write After Write）：两条指令写入同一位置。  </li>
<li>解决办法：数据前递（Data Forwarding）来绕过这些冲突，指令重排（Instruction Reordering），或者在必要时暂停（Stalling）流水线。</li>
</ol>
</li>
<li><p><strong>控制冲突（Control Hazards）</strong> </p>
<ol>
<li>定义：当流水线中的指令修改了程序的控制流（如跳转和分支）时，就会发生控制冲突。</li>
<li>原因：由于流水线中后续的指令已经开始执行，但分支指令的结果尚未确定，因此不清楚这些指令是否应该继续。</li>
<li>解决办法：分支预测（Branch Prediction）来猜测分支的结果，延迟槽（Delay Slot）来填充分支决定之前的空闲周期，或者在分支决策确定前暂停流水线。</li>
</ol>
</li>
</ol>
<h3 id="三种data-hazard"><a href="#三种data-hazard" class="headerlink" title="三种data hazard:"></a>三种data hazard:</h3><h4 id="RAW-read-after-write"><a href="#RAW-read-after-write" class="headerlink" title="RAW(read after write)"></a>RAW(read after write)</h4><p><img src="/2024/02/16/Computer-Architecture/image-24.png" alt="Alt text"></p>
<p>写后读，第一条指令在第五个cycle才能写回结果，而第二条指令在第3个cycle就读了，产生stall.</p>
<p>RAW是真相关，只能通过添加bypassing改善或stall。</p>
<h4 id="WAR（读后写）"><a href="#WAR（读后写）" class="headerlink" title="WAR（读后写）"></a>WAR（读后写）</h4><p><img src="/2024/02/16/Computer-Architecture/image-25.png" alt="Alt text"></p>
<p>其实不影响，只是名字重了，所以也叫名相关(name dependent)，或者反相关，名相关的唯一问题在于，编译器进行指令重排的时候会产生问题，因此需要进行寄存器的重命名。</p>
<h4 id="WAW（写后写）"><a href="#WAW（写后写）" class="headerlink" title="WAW（写后写）"></a>WAW（写后写）</h4><p>同理，也是一种名称相关，可以通过寄存器重命名解决。</p>
<h4 id="解决真相关：bypassing和-forwarding"><a href="#解决真相关：bypassing和-forwarding" class="headerlink" title="解决真相关：bypassing和 forwarding"></a>解决真相关：bypassing和 forwarding</h4><p><img src="/2024/02/16/Computer-Architecture/image-26.png" alt="Alt text"></p>
<p>通过前递解决了一般的计算指令的RAW</p>
<p>对应load类指令的写后读，则还需要1周期的stall:<br><img src="/2024/02/16/Computer-Architecture/image-27.png" alt="Alt text"></p>
<p>增加相关单元后的流水线：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-29.png" alt="Alt text"></p>
<p>forwarding 单元的原理：通过比较MEM阶段和wb阶段的目的寄存器以及id阶段的源寄存器判断是否需要进行前递。</p>
<p>Hazard detection 单元主要负责检查是否存在ld,alu类型的RAW,这种类型的hazard需要stall流水线一个周期。</p>
<h3 id="Control-Hazard"><a href="#Control-Hazard" class="headerlink" title="Control Hazard"></a>Control Hazard</h3><p>1.control Hazard产生的原因：PC总是按顺序取指令，而分支条件跳转指令要到EX阶段才能判断具体要取的指令，此时已经取了新的指令进来，而新取的指令可能是错的。</p>
<p>无任何硬件优化下，每次分支产生3个cycle的penalty:<br><img src="/2024/02/16/Computer-Architecture/image-33.png" alt="Alt text"><br>解决思路：</p>
<ol>
<li><p>直接暂停流水线：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-30.png" alt="Alt text"></p>
<p>由于需要译码之后才能知道这是一条分支指令，因此还是多取了1条指令。</p>
</li>
<li><p>predict-not-taken<br> <img src="/2024/02/16/Computer-Architecture/image-31.png" alt="Alt text"></p>
<p> 每次都假设不发生跳转，如果猜对了，则不会有stall,猜错了则冲刷流水线，取相应的指令。猜测了的开销和每次停顿是一样的。</p>
<p> <img src="/2024/02/16/Computer-Architecture/image-32.png" alt="Alt text"></p>
<p> 在ID阶段添加一些硬件，使得提前一个周期得到分支结果和目标的PC值。(这样就只用冲刷1条指令，就是上面表格的结果。)</p>
</li>
</ol>
<h3 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h3><ol>
<li><p>为什么需要分支预测？已经分支预测为什么有效？</p>
<ol>
<li>对于更深的流水线，分支指令对性能的影响增大。而现代的面向对象编程(Object-oriented Programming)中，存在大量分支场景。</li>
<li>分支预测能够工作的原因：程序的运行总是有某种规律，使得分支的发生与否能够被预测（时间上的局部性原理）。指令序列总是不可避免的带有人类思维的痕迹，因此是可预测的。</li>
</ol>
</li>
<li><p>分支预测预测什么？<br> <strong>分支跳转的方向</strong>(taken or not taken),<strong>目标PC的地址</strong>(address)。</p>
</li>
</ol>
<h3 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h3><h4 id="BTB（Branch-Target-Buffer）-和BHT（Branch-History-Table）"><a href="#BTB（Branch-Target-Buffer）-和BHT（Branch-History-Table）" class="headerlink" title="BTB（Branch Target Buffer） 和BHT（Branch History Table）:"></a>BTB（Branch Target Buffer） 和BHT（Branch History Table）:</h4><p><img src="/2024/02/16/Computer-Architecture/image-34.png" alt="Alt text"></p>
<p>BHT：每条不同的PC指令映射为BHT中的一个条目，记录了该条指令跳转还是不跳转。通过branch指令的历史行为(taken or not taken)，来预测指令本次是否跳转。</p>
<p>BTB：BHT只负责预测指令发生与否，而BTB存储了指令的目标地址。这样，如果BHT预测指令跳转，BTB就提供相应的PC地址，从而实现快速的指令切换。<br><img src="/2024/02/16/Computer-Architecture/image-40.png" alt="Alt text"><br>BTB的问题：只记录了PC值，还是要走一遍取值，译码，执行的过程。</p>
<p>一种改进策略：<br><img src="/2024/02/16/Computer-Architecture/image-41.png" alt="Alt text"></p>
<p>不讲武德，直接把指令取好。不是记录PC的值，而是记录指令本身，这样如果BHT预测发生跳转，BTB直接可以拿出相应的指令，跳过了IF阶段。</p>
<h4 id="一位分支预测的缺点："><a href="#一位分支预测的缺点：" class="headerlink" title="一位分支预测的缺点："></a>一位分支预测的缺点：</h4><p><img src="/2024/02/16/Computer-Architecture/image-36.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;++<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">        loop...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑这样的一个两层循环。一开始（j&#x3D;(0,n-1)），内层循环每次都taken，外层循环每次都not taken，当内层循环结束时(j&#x3D;n)，会执行一次外层循环，此时实际的执行效果变为：内层循环not taken,外层循环taken。而根据BHT的历史记录，会连续预测错误2次分支指令，造成性能损失。</p>
<h4 id="改进：2位分支预测"><a href="#改进：2位分支预测" class="headerlink" title="改进：2位分支预测"></a>改进：2位分支预测</h4><p><img src="/2024/02/16/Computer-Architecture/image-37.png" alt="Alt text"></p>
<p><strong>2位分支预测的核心思路</strong>：通过2位比特编码，得到四个预测状态（taken,weak taken,weak not taken, not taken）。同样考虑上面的那个例子：<br>当进行一遍内层循环时，由于内层循环每次都taken,会被记录为(taken),外层循环由于只进行了一次，所以被记录为(weak not taken)，这样，当内外循环交替时，只有内层循环的预测出现错误，而外层循环能正确预测。</p>
<h4 id="高级预测方法：Correlating-Branch-Predictor（相关分支预测器）"><a href="#高级预测方法：Correlating-Branch-Predictor（相关分支预测器）" class="headerlink" title="高级预测方法：Correlating Branch Predictor（相关分支预测器）"></a>高级预测方法：Correlating Branch Predictor（相关分支预测器）</h4><p><strong>核心思路：</strong>：不止关心本条分支指令的历史，而是关心全局的（或其它与本条指令相关的）分支指令的历史，从而实现更好的预测。（从$y_{n+1} &#x3D; f(y_{n})$变为：$y_{n+1}^{(1)} &#x3D; f(y_{n}^{(1)},y_{n}^{(2)},y_{n}^{(3)},…,y_{n}^{(m)})$）</p>
<p>实现方法：  (m,n)预测：用前m条指令和n位的状态来预测本次分支。<br>举例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-38.png" alt="Alt text"></p>
<ol>
<li>(1,1)相当于一个BHT,没啥好说的。</li>
<li>(m,1)相当于记录下m条指令的历史状态，对应一个1位的预测器。</li>
<li>(m,2)每个m位预测历史对应一个n位的编码，通过对n位编码进行某种解释，得到跳转与否的预测。<br><img src="/2024/02/16/Computer-Architecture/image-39.png" alt="Alt text"></li>
</ol>
<h4 id="Tournament-Predictor-（锦标赛预测器）"><a href="#Tournament-Predictor-（锦标赛预测器）" class="headerlink" title="Tournament Predictor （锦标赛预测器）"></a>Tournament Predictor （锦标赛预测器）</h4><p><strong>核心思路：</strong> 养蛊，让几种不同的预测方法自己内卷，哪个效果好就用哪个。</p>
<h3 id="Software-Scheduling-for-Exposing-ILP（软件调度的ILP）"><a href="#Software-Scheduling-for-Exposing-ILP（软件调度的ILP）" class="headerlink" title="Software Scheduling for Exposing ILP（软件调度的ILP）"></a>Software Scheduling for Exposing ILP（软件调度的ILP）</h3><p><strong>核心思路：</strong> 聪明的编译器会根据代码的结构尽量减少stall。</p>
<p>举例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-42.png" alt="Alt text"><br>每次add前要等load把数据读出来，需要一个周期stall（加了forwarding单元后）。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-43.png" alt="Alt text"><br>通过循环内指令的重排，减少了stall。 (区别就是把 DADDUI R1,R1, #-8 这条判断循环跳转的指令挪到上面去了)</p>
<p><img src="/2024/02/16/Computer-Architecture/image-44.png" alt="Alt text"></p>
<p>更近一步，把循环4倍展开。可以有更多指令用于重排。进一步减少stall。问题在于使用了更多的寄存器，需要保证寄存器够用。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-45.png" alt="Alt text"></p>
<h3 id="Dynamic-Scheduling-动态调度"><a href="#Dynamic-Scheduling-动态调度" class="headerlink" title="Dynamic Scheduling 动态调度"></a>Dynamic Scheduling 动态调度</h3><p>首先考虑一个顺序发射，顺序执行(in order issue, in order execution)的例子：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-46.png" alt="Alt text"><br>F0存在经典的RAW，因而会有stall（没有forwarding单元，或者流水深度过长的时候）。</p>
<p>如果将第二条指令和第三条指令交换顺序执行，则不存在上述问题。能这么做的原因在于，两条指令直接不存在相关性。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-47.png" alt="Alt text"><br>对于WAW,WAR,简单的寄存器重命名就可以解决依赖问题。</p>
<h4 id="OOO-out-of-order-的思想"><a href="#OOO-out-of-order-的思想" class="headerlink" title="OOO(out of order)的思想"></a>OOO(out of order)的思想</h4><p>stall会出现的本质原因，在于指令被译码结束后，其操作数因为各种原因还没有准备好(比如需要等其它指令计算结束，或相关操作数在memory中需要load)。既然如此，指令译码结束后，可以检测其操作数状态，只有操作数准备好的指令，才将其放入对应的计算资源中执行相应操作。从而最大程度减小stall。</p>
<p>另外，尽管指令是乱序执行的，但让处理器在指令完成后对结果进行重排序，以确保与程序指定的顺序一致，就可以保证程序的正确性。</p>
<p>这方面的一个典型例子是Tomasulo 算法。</p>
<h4 id="Tomasulo-Algorithm"><a href="#Tomasulo-Algorithm" class="headerlink" title="Tomasulo Algorithm"></a>Tomasulo Algorithm</h4><p>实现OOO的关键在于硬件支持：一个典型的Tomasulo算法需要以下功能单元：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-48.png" alt="Alt text"></p>
<ol>
<li><p><strong>保留站（Reservation Stations）</strong></p>
<ol>
<li>作用：保留站用于暂存即将执行的指令，同时跟踪指令所需的操作数是否已经可用。</li>
<li>功能：每个保留站都与一个特定的执行单元相关联，并存储指令、操作数、操作数的来源以及执行状态等信息。保留站还负责检测操作数的可用性，并在操作数准备就绪时触发指令的执行。</li>
</ol>
</li>
<li><p><strong>寄存器重命名（Register Renaming）</strong></p>
<ol>
<li>作用：减少WAR（Write After Read）和WAW（Write After Write）冲突，提高指令流的并行度。</li>
<li>功能：使用保留站中的标签而非真实的寄存器名称，从而允许多个指令同时对同一寄存器进行操作，而不会相互干扰。</li>
</ol>
</li>
<li><p><strong>公共数据总线（Common Data Bus，CDB）</strong></p>
<ol>
<li>作用：用于广播执行单元完成的操作结果，同时通知等待这些结果的其它保留站和寄存器。</li>
<li>功能：任何执行单元完成操作后，会将结果放在CDB上。保留站和寄存器监听CDB，以获取它们需要的数据。</li>
</ol>
</li>
<li><p><strong>执行单元（Execution Units）</strong></p>
<ol>
<li>作用：执行具体的计算任务，如加法、乘法、逻辑操作等。</li>
<li>功能：根据保留站提供的指令和操作数进行计算，并将结果发送到CDB。</li>
</ol>
</li>
<li><p><strong>指令队列（Instruction Queue）</strong></p>
<ol>
<li>作用：暂存尚未处理的指令。</li>
<li>功能：指令队列按照程序顺序存储指令，然后将指令分发到相应的保留站。</li>
</ol>
</li>
<li><p><strong>load Buffers</strong></p>
<ol>
<li>作用：Load Buffers用于处理来自内存的加载（load）操作。</li>
<li>功能：当指令队列中出现一个加载操作时，该操作被放置在Load Buffer中。Load Buffer负责跟踪加载操作的地址计算，并在地址计算完成后从内存中获取数据。一旦数据加载完成，它就可以被送往执行单元或者直接写入寄存器。</li>
</ol>
</li>
<li><p><strong>Store Buffers</strong></p>
<ol>
<li>作用：Store Buffers用于处理写入内存的存储（store）操作。</li>
<li>功能：当指令队列中出现一个存储操作时，该操作被放置在Store Buffer中。Store Buffer负责跟踪存储操作的地址计算和待存储的数据。一旦地址和数据都准备好，存储操作就可以被提交到内存。</li>
</ol>
</li>
<li><p><strong>重排序缓冲区（Reorder Buffer，ROB，可选）</strong></p>
<ol>
<li>作用：确保即使在乱序执行的情况下，指令的结果也能按照程序顺序提交（commit），维护程序的正确性。</li>
<li>功能：ROB跟踪指令的执行状态，并在所有先行指令完成后按序提交结果。</li>
</ol>
</li>
</ol>
<h4 id="进一步理解："><a href="#进一步理解：" class="headerlink" title="进一步理解："></a>进一步理解：</h4><p><img src="/2024/02/16/Computer-Architecture/image-49.png" alt="Alt text"></p>
<p>一个Tomasulo 的算法表。其中各部分的解释如下：</p>
<ol>
<li><p><strong>Instruction status:</strong> 一条指令包含多种状态。Issue代表已经发射(放入了执行队列)，Execute表示被执行(放入了对应的执行单元)，Write Result表示执行完毕且结果已写回。 这部分只是便于理解算法本身，硬件中并不存在真实的结构。</p>
</li>
<li><p><strong>Reservation Stations:</strong> 保留站中指令的状态。</p>
<ol>
<li>Op：表示对应的操作。</li>
<li>Busy: 对应的执行单元处于忙碌状态，指令正在执行，或者对应的发射槽被占用。</li>
<li>Vj,Vk: 左右操作数的值。表示操作数具体放在哪个寄存器。如果Vj,Vk都有数，且对应的执行单元不busy,说明指令可以被执行。</li>
<li>Qj,Qk:即将产生Vj,Vk的操作。表示指令直接的依赖关系。也就是说，Qj和Vj互斥，Qk和Vk互斥，2个中只同时有一个有数。</li>
</ol>
</li>
<li><p><strong>Register Status：</strong> 寄存器与对应指令的关系，表明那条指令将写哪个寄存器。</p>
</li>
</ol>
<h4 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h4><p><img src="/2024/02/16/Computer-Architecture/image-50.png" alt="Alt text"><br>    初始状态</p>
<p><img src="/2024/02/16/Computer-Architecture/image-51.png" alt="Alt text"></p>
<p>第一条指令被发射，进入loads buffer，同时对应的寄存器F6处记录下Load1，表示Load1的结构将写入F6。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-52.png" alt="Alt text"></p>
<p>发射指令load2，和前面差不多</p>
<p><img src="/2024/02/16/Computer-Architecture/image-53.png" alt="Alt text"></p>
<p>第一条load指令执行完毕，拿到了操作数，但还没来得及写回。第三条mul指令被发射，进入保留站，对应的发射槽变为Busy。其右操作数F4是现成的，因此写在Vk，而左操作数依赖Load2的结果，写在Qj。由于此时load2还没执行完，因此这条乘法指令没发被执行。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-54.png" alt="Alt text"></p>
<p>下一条减法指令发射。第一条load指令已经将结果写入F6寄存器。因此减法指令可以直接拿到这个操作数Vj,而另一个操作数需要等待Load2写回。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-55.png" alt="Alt text"></p>
<p>Load2写回， Mul和sub指令都拿到了2个操作数，下一个周期就可以开始执行了。其余类似。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-56.png" alt="Alt text"><br>注意看上面的2条运算指令进入了complete阶段。</p>
<h4 id="Tumasulo的总结"><a href="#Tumasulo的总结" class="headerlink" title="Tumasulo的总结"></a>Tumasulo的总结</h4><p>很经典，体现了OOO的精髓。很有效率，但是硬件开销比较大。体</p>
<p>同时Common Data Bus的设计存在很大限制。因为它需要广播通知所有的保留站对应的操作数到了，从而存在以下几个问题：</p>
<ol>
<li>扇出（Fan-out）问题<br>挑战：CDB需要将数据同时广播给多个保留站和寄存器文件，这就导致了较大的扇出。高扇出会增加电路的负载，从而影响信号的传播时间和电路的响应速度。<br>影响：高扇出可能限制处理器的时钟频率，因为信号需要在一个时钟周期内在整个CDB上稳定下来。</li>
<li>功耗<br>挑战：广播机制意味着CDB在每次操作时都需要激活多个接收点，这增加了功耗。<br>影响：在功耗敏感的应用场景中，如移动设备或高性能计算，这可能是一个显著的问题。</li>
<li>硬件复杂性<br>挑战：实现一个高效且可靠的CDB需要复杂的硬件设计，尤其是在处理高速、高密度信号时。<br>影响：这增加了处理器设计的复杂性和成本。</li>
<li>争用和冲突<br>挑战：当多个执行单元几乎同时完成计算时，可能会出现对CDB的争用。<br>影响：必须有机制来处理这种争用，否则可能导致性能下降。</li>
</ol>
<h4 id="Dynamic-Scheduling的总结"><a href="#Dynamic-Scheduling的总结" class="headerlink" title="Dynamic Scheduling的总结"></a>Dynamic Scheduling的总结</h4><p><strong>优点</strong></p>
<ol>
<li><p>提高性能：通过允许指令乱序执行，动态调度可以减少因数据依赖性引起的延迟，提高处理器的执行效率。</p>
</li>
<li><p>提高资源利用率：动态调度允许处理器更有效地利用其执行单元，减少因指令等待而空闲的情况。</p>
</li>
<li><p>减少冲突：动态调度可以减少流水线中的结构冲突和数据冲突，尤其是在超标量和乱序执行的处理器中。</p>
</li>
<li><p>自适应性：动态调度可以根据指令流的实际情况动态调整，适应不同的程序和工作负载。</p>
</li>
<li><p>隐藏延迟：它可以有效地隐藏长延迟操作（如缓存未命中）的影响，通过执行其他独立指令来填充等待时间。</p>
</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><p>硬件复杂性：实现动态调度需要复杂的硬件支持，如保留站、重排序缓冲区和复杂的控制逻辑。</p>
</li>
<li><p>功耗增加：由于需要更多的硬件资源和更高的运算速度，动态调度的处理器通常消耗更多的功率。</p>
</li>
<li><p>设计挑战：设计一个高效且准确的动态调度算法是非常具有挑战性的，需要精确处理指令间的依赖和冲突。</p>
</li>
<li><p>成本增加：与简单的顺序执行处理器相比，动态调度处理器的制造成本更高。</p>
</li>
<li><p>时钟频率的限制：由于动态调度的复杂性，可能对处理器的最高时钟频率造成限制。</p>
</li>
</ol>
<h3 id="推断（Speculation）"><a href="#推断（Speculation）" class="headerlink" title="推断（Speculation）"></a>推断（Speculation）</h3><pre><code>Speculation = Dynamic Scheduling + Prediction
</code></pre>
<p>动态调度结合分支预测技术，提前执行一些可能用得到的指令。如果判断对了，皆大欢喜，如果判断失误，丢弃对应的指令结果，进行回滚(Roll back)。可以总结为: Out of order execution, in order commit.</p>
<h4 id="关键硬件-ROB（Reorded-Buffer）"><a href="#关键硬件-ROB（Reorded-Buffer）" class="headerlink" title="关键硬件: ROB（Reorded Buffer）"></a>关键硬件: ROB（Reorded Buffer）</h4><p><img src="/2024/02/16/Computer-Architecture/image-57.png" alt="Alt text"></p>
<h5 id="ROB的工作原理"><a href="#ROB的工作原理" class="headerlink" title="ROB的工作原理"></a>ROB的工作原理</h5><ol>
<li><p>指令进入ROB：当指令被分派（Dispatched）到流水线时，它们会进入ROB。每条指令在ROB中都有一个对应的条目。</p>
</li>
<li><p>指令执行：指令可以乱序执行，即按照数据依赖和执行单元的可用性进行执行，而不是严格按照程序顺序。执行过程中，指令的结果（如计算结果或加载的数据）暂时存储在ROB中，而不是直接写入寄存器或内存。</p>
</li>
<li><p>维护程序顺序：尽管指令是乱序执行的，ROB确保按照原始程序顺序“提交”（Commit）指令的结果。这意味着只有当ROB中所有先前的指令都已正确完成，一条指令的结果才能被提交到寄存器或内存。</p>
</li>
<li><p>处理分支和异常：如果处理器遇到分支预测错误或异常，ROB可以用来撤销或回滚错误预测的指令，并从正确的点重新开始执行。</p>
</li>
<li><p>结果提交：一旦确认指令可以安全提交，其结果就从ROB转移到相应的目的地，如寄存器文件或内存。这个提交过程保证了即使发生乱序执行，外部观察到的效果仍然符合程序的顺序执行。</p>
</li>
</ol>
<h5 id="ROB的重要性"><a href="#ROB的重要性" class="headerlink" title="ROB的重要性"></a>ROB的重要性</h5><ol>
<li>支持乱序执行：ROB使得处理器可以在保持程序语义的前提下自由地重排指令的执行顺序。</li>
<li>支持推测执行：ROB存储推测执行的结果，并在确定这些推测是正确的之后才进行提交。</li>
<li>保证异常处理的正确性：在发生异常或分支预测错误时，ROB提供了一种机制来撤销或回滚已经执行但尚未提交的指令。</li>
<li>隐藏延迟：通过允许后续独立指令先于前面的长延迟指令执行，ROB有助于隐藏延迟，提高处理器效率。</li>
</ol>
<h3 id="Multi-Issue多发射"><a href="#Multi-Issue多发射" class="headerlink" title="Multi Issue多发射"></a>Multi Issue多发射</h3><p>首先思考CPI这个概念：顾名思义，Clock Per Instruction，在流水下，最优的情况是每个周期就能执行一条指令，也就是说CPI&#x3D;1.那么问题来了，能不能进一步挖掘指令的并行性能，使CPI小于1？</p>
<p><strong>Multi Issue（多发射）</strong>技术是指处理器能够在每个时钟周期内发射（即开始执行）多条指令的能力。这种技术是超标量架构的一个关键特征，它允许处理器并行地执行多个操作，从而提高整体性能和处理器的吞吐量。</p>
<p>一个解决方法是，使用超长指令字(Very Long Instruction Word)VLIW。<br>每条超长指令是一系列简单指令的拼接。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-58.png" alt="Alt text"></p>
<h3 id="多线程Multi-Thread"><a href="#多线程Multi-Thread" class="headerlink" title="多线程Multi Thread"></a>多线程Multi Thread</h3><p>（待补充）</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="Chapter-4-DLP-in-Vector-SIMD-and-GPU-Architectures"><a href="#Chapter-4-DLP-in-Vector-SIMD-and-GPU-Architectures" class="headerlink" title="Chapter 4 DLP in Vector, SIMD, and GPU  Architectures"></a>Chapter 4 DLP in Vector, SIMD, and GPU  Architectures</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><h4 id="数据级并行（Data-level-parallelism-DLP）"><a href="#数据级并行（Data-level-parallelism-DLP）" class="headerlink" title="数据级并行（Data level parallelism, DLP）"></a>数据级并行（Data level parallelism, DLP）</h4><p>数据级并行是指同时对多个数据项执行相同的操作。这种并行性主要体现在在单个操作中处理多个数据项，而不是在多个操作上。在处理大量数据时，DLP特别有效，因为它可以显著加快数据处理速度。</p>
<h4 id="单指令多数据流（Single-Instruction-Multi-Data-SIMD）"><a href="#单指令多数据流（Single-Instruction-Multi-Data-SIMD）" class="headerlink" title="单指令多数据流（Single Instruction Multi Data,SIMD）"></a>单指令多数据流（Single Instruction Multi Data,SIMD）</h4><p>SIMD是实现数据级并行的一种常见方式。在SIMD架构中，单个指令控制多个处理单元同时对不同的数据执行相同的操作。这种方法在多媒体处理、科学计算和机器学习等领域非常有效，因为这些领域常常涉及到对大量数据执行重复的操作。</p>
<p>同时，由于SIMD的编程模型仍然是串行的，比较符合人类的思维逻辑，减小了编程的难度。</p>
<h4 id="向量处理器（Vector-Processor）"><a href="#向量处理器（Vector-Processor）" class="headerlink" title="向量处理器（Vector Processor）"></a>向量处理器（Vector Processor）</h4><p>向量处理器是一种专门的处理器，设计用来高效地执行SIMD操作。在向量处理器中，指令不是对单个数据项进行操作，而是对一个数据集合（向量）进行操作。每个向量指令可以同时对多个数据元素执行相同的操作，这使得向量处理器特别适合于那些需要大规模数值计算的应用。</p>
<h3 id="一个典型例子-VMIPS"><a href="#一个典型例子-VMIPS" class="headerlink" title="一个典型例子:VMIPS"></a>一个典型例子:VMIPS</h3><p><img src="/2024/02/16/Computer-Architecture/image-60.png" alt="Alt text"><br>在硬件上对寄存器和运算单元进行扩展，同时设计了新的指令，支持向量操作</p>
<p><img src="/2024/02/16/Computer-Architecture/image-59.png" alt="Alt text"></p>
<p>使用vector后，64个数据的操作指令减少到6条。</p>
<h5 id="向量体系结构的运行时间分析"><a href="#向量体系结构的运行时间分析" class="headerlink" title="向量体系结构的运行时间分析"></a>向量体系结构的运行时间分析</h5><p><img src="/2024/02/16/Computer-Architecture/image-61.png" alt="Alt text"><br>假设只有1个执行单元，多条指令可以同时发射，但需要顺序执行，此时执行时间约等于向量的长度。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-62.png" alt="Alt text"></p>
<p>在这张图上我们假设乘法单元和加法单元各有一个，则通过前递(forwarding)二者可以几乎并行的执行。</p>
<ol>
<li><p>Convoy<br>在向量处理器的上下文中，“Convoy”通常指一组可以同时发射（即开始执行）的向量指令。在某些向量处理器设计中，一组指令被打包成一个Convoy，这组指令共享相同的执行资源。Convoy的概念有助于优化指令流水线，提高处理器的吞吐量。</p>
</li>
<li><p>Chaining<br>“Chaining”是向量处理器中一种重要的性能优化技术。在Chaining中，一个向量指令的输出直接作为另一个向量指令的输入，而无需等待第一个指令完全完成。这种方法可以减少存储器访问和中间结果写回的开销，从而加速整个计算过程。</p>
</li>
<li><p>chime<br>向量处理器处理一个convoy的用时。m个convey则需要m个chime。<br>对应长度为$n$的向量，则需要$m\times$个周期来执行。</p>
<p>例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-63.png" alt="Alt text"></p>
</li>
</ol>
<h4 id="提升Vector性能的方法"><a href="#提升Vector性能的方法" class="headerlink" title="提升Vector性能的方法"></a>提升Vector性能的方法</h4><p><img src="/2024/02/16/Computer-Architecture/image-64.png" alt="Alt text"></p>
<h5 id="multiple-lanes"><a href="#multiple-lanes" class="headerlink" title="multiple lanes"></a>multiple lanes</h5><p><img src="/2024/02/16/Computer-Architecture/image-65.png" alt="Alt text"></p>
<p>最简单粗暴的方法：直接做多硬件资源，使各种功能单元数量翻倍。</p>
<h5 id="Vector-Length-Register"><a href="#Vector-Length-Register" class="headerlink" title="Vector Length Register"></a>Vector Length Register</h5><p>使用向量长度寄存器，达到能够支持任意长度向量的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">low = <span class="number">0</span>;</span><br><span class="line">VL = (n % MVL); <span class="comment">/*find odd-size piece using modulo op % */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= (n/MVL); j=j+<span class="number">1</span>) &#123; <span class="comment">/*outer loop*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt; (low+VL); i=i+<span class="number">1</span>) <span class="comment">/*runs for length VL*/</span></span><br><span class="line">        Y[i] = a * X[i] + Y[i] ; <span class="comment">/*main operation*/</span></span><br><span class="line">    low = low + VL; <span class="comment">/*start of next vector*/</span></span><br><span class="line">    VL = MVL; <span class="comment">/*reset the length to maximum vector length*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中MVL为Maximum Vector Length,即硬件支持的最大向量长度（如64）。这个大小对程序员来说是已知的。</p>
<h5 id="Vertor-Mask-Register"><a href="#Vertor-Mask-Register" class="headerlink" title="Vertor Mask Register"></a>Vertor Mask Register</h5><p>考虑如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i=i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (X[i] != <span class="number">0</span>)</span><br><span class="line">        X[i] = X[i] – Y[i];</span><br></pre></td></tr></table></figure>

<p>对一个向量中符合某种条件的代码进行操作。</p>
<p>此时可以使用Mask Vector</p>
<p>对应的汇编指令可以设计为：<br><img src="/2024/02/16/Computer-Architecture/image-67.png" alt="Alt text"></p>
<p>而在硬件支持方面，只需要在所有运算单元上增加一个enable信号，只有接收到enable信号的功能单元才执行操作，即可支持mask功能。</p>
<h5 id="Memory-Banks"><a href="#Memory-Banks" class="headerlink" title="Memory Banks"></a>Memory Banks</h5><p>使用多bank的内存，支持高带宽的并行存取。</p>
<p>此时需考虑bank conflict的情况。</p>
<p>如矩阵乘：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i=i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j=j+<span class="number">1</span>) &#123;</span><br><span class="line">        A[i][j] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k=k+<span class="number">1</span>)</span><br><span class="line">            A[i][j] = A[i][j] + B[i][k] * D[k][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于D矩阵的数据，如果存储在同一个bank中，会出现比较严重的bank conflict。例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-68.png" alt="Alt text"></p>
<h5 id="Scatter-Gather-对稀疏的支持。"><a href="#Scatter-Gather-对稀疏的支持。" class="headerlink" title="Scatter-Gather 对稀疏的支持。"></a>Scatter-Gather 对稀疏的支持。</h5><p>考虑计算2个稀疏矩阵A和C的加法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">    A[K[i]] = A[K[i]]+C[K[i]];</span><br><span class="line">    A[M[i]] = A[M[i]]+C[M[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>K和M分别是A与C中非0元素位置的索引。需要的指令支持为：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-69.png" alt="Alt text"></p>
<h4 id="向量处理器的优缺点"><a href="#向量处理器的优缺点" class="headerlink" title="向量处理器的优缺点"></a>向量处理器的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>对于取值来说，向量处理器能够用更少的指令实现同样的功能，因此简化了取指。</li>
<li>简化了指令的发射执行。对于分支指令，由于向量指令能够合并分支，避免了一部分分支预测的开销。同时对于数据依赖检测的硬件实现也更简单。</li>
<li>更有效的内存访问。向量结构的访存地址通常更规则，结合memory的bank结构，能够更有效的存取数据，使得访存的延迟被摊销掉不少。</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>对于一些标量操作，仍然需要传统的标量单元来执行</li>
<li>难以进行精确的中断控制。因为是向量操作，无法进行有效的数据回滚</li>
<li>对编译器和程序员带来一定挑战，必须将原本的程序向量化</li>
<li>如果向量长度比较小，向量处理器通常并不高效</li>
<li>对某些特殊的应用类型的性能很一般(数据并行度比较差的程序)</li>
<li>需要对内存系统进行优化</li>
</ol>
<h3 id="GPGPU-General-Purpose-Graphics-Processing-Unit-通用图形处理器"><a href="#GPGPU-General-Purpose-Graphics-Processing-Unit-通用图形处理器" class="headerlink" title="GPGPU General Purpose Graphics Processing Unit 通用图形处理器"></a>GPGPU General Purpose Graphics Processing Unit 通用图形处理器</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>GPGPU</strong>（General-Purpose computing on Graphics Processing Units）指的是在图形处理单元（GPU）上进行的通用计算。这种技术利用了GPU的高并行处理能力来执行非图形相关的计算任务，特别是那些可以通过数据并行性来显著加速的任务。</p>
<p><strong>背景</strong><br>最初，GPU被设计用来处理计算机图形和图像相关的任务，例如渲染3D图形和处理视频内容。然而，人们逐渐意识到GPU强大的并行处理能力也非常适合进行科学计算、工程模拟、数据分析等任务。</p>
<p><strong>GPGPU的特点</strong><br>高度的数据并行性：GPU含有数百到数千个小型、高效的处理核心，能够同时处理大量数据。</p>
<p><strong>专用硬件加速</strong>：GPU包含专门设计的硬件，适用于执行浮点运算和向量运算。</p>
<p><strong>适用于特定类型的计算</strong>：GPGPU非常适合执行可以被分解为小的、独立的并行任务的计算，如矩阵运算、信号处理等。</p>
<p><strong>编程模型</strong>：利用GPGPU进行计算通常需要特定的编程模型和编程语言，如CUDA（Compute Unified Device Architecture，由NVIDIA开发）和OpenCL（Open Computing Language）。</p>
<h4 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h4><p>什么是编程？</p>
<p>编程模型（Programming Model）是指用于指导和简化特定类型程序设计的一套规则、概念和结构。它定义了程序中的数据和控制流结构，以及程序员与计算系统（如处理器、操作系统或整个计算平台）之间的交互方式。编程模型是编程范式（如面向对象编程、函数式编程）和具体技术实现（如API或编程框架）之间的中间层。</p>
<p>一般而言，编程模型包含以下3个方面：</p>
<ol>
<li>How to compute the wanted function(计算过程、算法)</li>
<li>How to organize the memory to serve the computation（存储管理）</li>
<li>How to map the function to the real hardware（控制、硬件配置）</li>
</ol>
<p>对于GPU这类并行架构来说，编程模型更关心以下几个方面：</p>
<ol>
<li>How to divide the workload (任务的切分)</li>
<li>How to communicate between the divided work（任务间通信）</li>
<li>How to synchronize the divided work（任务同步）</li>
</ol>
<h5 id="异构计算-Heterogeneous-computing"><a href="#异构计算-Heterogeneous-computing" class="headerlink" title="异构计算 Heterogeneous computing"></a>异构计算 Heterogeneous computing</h5><p>在程序员的视角，GPU编程是一种异构计算：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-70.png" alt="Alt text"></p>
<p>异构计算（Heterogeneous Computing）是一种计算范式，它涉及到在单个系统中结合使用多种类型的处理器或核心来提高计算效率和性能。这种系统通常包含不同种类的处理单元，如传统的中央处理器（CPU）、图形处理器（GPU）、数字信号处理器（DSP）和其他类型的专用加速器。</p>
<h5 id="GPGPU的线程模型："><a href="#GPGPU的线程模型：" class="headerlink" title="GPGPU的线程模型："></a>GPGPU的线程模型：</h5><p>NVIDIA GPU的线程模型是一个专门为其CUDA（Compute Unified Device Architecture）平台设计的并行计算架构。这个模型使得开发者能够有效地利用GPU的强大并行处理能力。在这个模型中，关键概念包括内核（Kernel）、网格（Grid）、块（Block）和线程（Thread）。</p>
<p><strong>Kernel（内核）</strong><br>含义：内核是在GPU上执行的一个函数。当你启动一个内核时，实际上是在告诉GPU同时执行许多线程的实例。<br>角色：每个内核代表了一个在GPU上并行执行的任务。在CUDA编程中，内核由特定的CUDA C&#x2F;C++函数构成，使用__global__声明修饰符标记。</p>
<p><strong>Grid（网格）</strong><br>含义：网格是一组块的集合。当一个内核被启动时，它会以网格的形式组织。<br>角色：网格代表了所有线程的总体组织结构，它定义了执行内核所需要的所有线程块。</p>
<p><strong>Block（块）</strong><br>含义：块是一组线程的集合，这些线程可以协同执行，并能够通过共享内存进行通信。<br>角色：每个块中的线程可以同步执行，并共享一定量的快速但容量有限的共享内存。一个块内的所有线程都在同一个GPU上执行。</p>
<p><strong>Thread（线程）</strong><br>含义：线程是执行内核代码的基本单位。每个线程执行内核中的一部分操作。<br>角色：在CUDA中，每个线程都有其唯一的线程ID，用于计算数据的位置和执行特定的操作。线程是实际执行计算的实体。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-71.png" alt="Alt text"></p>
<p><img src="/2024/02/16/Computer-Architecture/image-72.png" alt="Alt text"></p>
<h5 id="SMIT-和SMID的区别"><a href="#SMIT-和SMID的区别" class="headerlink" title="SMIT 和SMID的区别"></a>SMIT 和SMID的区别</h5><p><img src="/2024/02/16/Computer-Architecture/image-73.png" alt="Alt text"></p>
<p>SMID是一个线程同时操作多个标量操作。<br>SMIT是多个线程同时进行单个的标量操作。</p>
<h5 id="GPU的优势"><a href="#GPU的优势" class="headerlink" title="GPU的优势"></a>GPU的优势</h5><p>branch, memory bandwidth, multi-bank, coalescing</p>
<h4 id="GPU控制架构"><a href="#GPU控制架构" class="headerlink" title="GPU控制架构"></a>GPU控制架构</h4><p><img src="/2024/02/16/Computer-Architecture/image-74.png" alt="Alt text"></p>
<p>一个SM(Streaming Multiprocessor)可编程多处理器 的架构如图。</p>
<h5 id="Warp的概念"><a href="#Warp的概念" class="headerlink" title="Warp的概念"></a>Warp的概念</h5><p>线程组：一个 Warp 通常包含32个线程。这些线程在硬件上被同时调度执行，共享同一个指令流。</p>
<p>并行执行：Warp 中的所有线程都执行相同的指令，但是每个线程可以在不同的数据上操作。这是一种单指令多数据（SIMD）的并行处理方式。</p>
<p>效率：通过将多个线程组织成一个 Warp，GPU 能够高效地利用其并行处理单元，尤其是在处理类似的数据或执行重复任务时。</p>
<p>SM上的指令调度全部以warp为单位进行。<br><img src="/2024/02/16/Computer-Architecture/image-75.png" alt="Alt text"></p>
<p>warp只有在ready的情况下才会被调度。warp的标志位包括：</p>
<ol>
<li>ID：表示线程数的identity</li>
<li>PC: PC值，warp的指令地址</li>
<li>Decoded instruction:需要执行的指令类型</li>
<li>Ready: 可以被调度</li>
<li>Valid: 是否有效</li>
</ol>
<p>warp的调度方法包括 轮询(round-robin),贪心GTO(greedy-then-oldest)。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-76.png" alt="Alt text"></p>
<p>轮询存在的问题： 每个线程都是先访存再计算，导致计算效率低。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-77.png" alt="Alt text"></p>
<p>使用2级轮询可以进行改善。</p>
<h5 id="线程的发散"><a href="#线程的发散" class="headerlink" title="线程的发散"></a>线程的发散</h5><p>(略，复习不完了)</p>
<h4 id="GPU-存储架构"><a href="#GPU-存储架构" class="headerlink" title="GPU 存储架构"></a>GPU 存储架构</h4><p>不同于CPU，GPU中的存储器呈倒三角结构</p>
<p><img src="/2024/02/16/Computer-Architecture/image-78.png" alt="Alt text"></p>
<h4 id="运算单元架构"><a href="#运算单元架构" class="headerlink" title="运算单元架构"></a>运算单元架构</h4><p>(略，复习不完了)</p>
<h4 id="张量核心架构"><a href="#张量核心架构" class="headerlink" title="张量核心架构"></a>张量核心架构</h4><p>(略，复习不完了)</p>
<h2 id="Chapter-5-Multiprocess-and-Thread-Level-Parallelism"><a href="#Chapter-5-Multiprocess-and-Thread-Level-Parallelism" class="headerlink" title="Chapter 5 Multiprocess and Thread-Level Parallelism"></a>Chapter 5 Multiprocess and Thread-Level Parallelism</h2><h3 id="多处理器的概念"><a href="#多处理器的概念" class="headerlink" title="多处理器的概念"></a>多处理器的概念</h3><p>在计算机架构中，多处理器（Multiprocessor）指的是包含多个处理单元（通常是CPU核心）的系统。这些处理单元可以并行处理多个任务，提高系统的总体计算能力和吞吐率。多处理器系统可以是对称的（SMP，Symmetric Multiprocessing）或不对称的（Asymmetric Multiprocessing），具体取决于各个处理器之间的角色和功能是否相同。</p>
<p>多处理器的特点<br>并行处理能力：多处理器系统能够同时执行多个计算任务，提高了处理效率和吞吐量。</p>
<p>增强的性能：相较于单处理器系统，多处理器系统通常提供更高的性能，特别是在处理并行化良好的任务时。</p>
<p>可扩展性：多处理器架构允许更灵活地扩展计算能力，可以通过增加更多的处理器来提高系统性能。</p>
<p>容错能力：在一些设计中，多处理器系统可以提供更好的容错能力，当一个处理器失败时，其他处理器可以接管其任务。</p>
<p>资源共享：多处理器通常共享系统资源，如内存、I&#x2F;O设备等。这要求有效的资源管理和调度策略，以避免冲突和瓶颈。</p>
<p>高效的数据处理：对于需要大量数据处理的应用（如数据库服务器、科学计算应用），多处理器系统可以提供显著的性能优势。</p>
<h3 id="SMP和DMP"><a href="#SMP和DMP" class="headerlink" title="SMP和DMP"></a>SMP和DMP</h3><h4 id="SMP-Symmetric-multiprocessors"><a href="#SMP-Symmetric-multiprocessors" class="headerlink" title="SMP(Symmetric multiprocessors)"></a>SMP(Symmetric multiprocessors)</h4><p><img src="/2024/02/16/Computer-Architecture/image-79.png" alt="Alt text"></p>
<p>多个处理器共享同一个内存地址。(目前大部分Intel和AMD处理器的架构)</p>
<p>地址是一致的(Uniformed Memory Access)</p>
<h4 id="DMP"><a href="#DMP" class="headerlink" title="DMP"></a>DMP</h4><p><img src="/2024/02/16/Computer-Architecture/image-80.png" alt="Alt text"></p>
<p>每个处理器具有独立的内存和地址，需要考虑数据一致性。</p>
<h3 id="多处理器的并行挑战"><a href="#多处理器的并行挑战" class="headerlink" title="多处理器的并行挑战"></a>多处理器的并行挑战</h3><h4 id="并行效率"><a href="#并行效率" class="headerlink" title="并行效率"></a>并行效率</h4><p>例：如果使用100个核，想要达到单核80倍的加速比，根据阿姆达尔定律：</p>
<p>speed up  &#x3D; $\frac{1}{a%+(1-a%)\div100}$</p>
<p>其中a为并行指令的百分比。解的a为0.25，也就是说串行指令只能占0.25%。</p>
<h4 id="通信开销"><a href="#通信开销" class="headerlink" title="通信开销"></a>通信开销</h4><p><img src="/2024/02/16/Computer-Architecture/image-81.png" alt="Alt text"></p>
<p>200ns的通信时间相当于660个时钟周期，0.002的通信频率使CPI变为：<br>$0.5+660\times0.002&#x3D;1.82$</p>
<h4 id="缓存一致性-Cache-Coherence"><a href="#缓存一致性-Cache-Coherence" class="headerlink" title="缓存一致性(Cache Coherence)"></a>缓存一致性(Cache Coherence)</h4><p><img src="/2024/02/16/Computer-Architecture/image-82.png" alt="Alt text"></p>
<p>AB二者缓存中都有数据X，A写了自己的cachee,并通过write through写了Memory,B不知道，造成不一致。</p>
<p>一般来说有3中解决方案：<br><img src="/2024/02/16/Computer-Architecture/image-83.png" alt="Alt text"></p>
<ol>
<li>软件调度，直接禁止所有对Shared Memory的缓存操作</li>
<li>某个处理器写了一个数据后，其它cache中的该数据失效。</li>
<li>通过协议及时更新数据。</li>
</ol>
<h5 id="Snoopy-监听-Coherence-Protocol"><a href="#Snoopy-监听-Coherence-Protocol" class="headerlink" title="Snoopy(监听) Coherence Protocol"></a>Snoopy(监听) Coherence Protocol</h5><p><img src="/2024/02/16/Computer-Architecture/image-84.png" alt="Alt text"></p>
<p>还是上面那个例子，当A写了之后，B再读自己cache中的X会显示cache miss，因为相应数据已经失效了。</p>
<p>实现方式： 通过一个BUS广播告诉所有Cache数据的状态。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-85.png" alt="Alt text"></p>
<p>cache 中，每个数据有3中不同状态：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-86.png" alt="Alt text"></p>
<h6 id="协议内容"><a href="#协议内容" class="headerlink" title="协议内容"></a>协议内容</h6><p><img src="/2024/02/16/Computer-Architecture/image-87.png" alt="Alt text"></p>
<p>分类讨论read hit,read miss,write hit,write miss。</p>
<p>同时在read miss,write hit,write miss的情况下，考虑被替换的数据状态是invalid,shared 还是modified,相应的bus要做出对应的行为。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-88.png" alt="Alt text"><br>Snoopy协议下cache的状态转换图</p>
<p><img src="/2024/02/16/Computer-Architecture/image-89.png" alt="Alt text"><br>Snoopy协议下bus的状态转换图</p>
<h5 id="Snoopy协议的扩展："><a href="#Snoopy协议的扩展：" class="headerlink" title="Snoopy协议的扩展："></a>Snoopy协议的扩展：</h5><h6 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h6><p><img src="/2024/02/16/Computer-Architecture/image-90.png" alt="Alt text"></p>
<p>添加一个新的状态 Exclusive,表示数据在只有本cache中有，而且还没有被写过(clean)</p>
<p>当其它cache读这个数据时，转变为S<br>当本processor写这个cache时，变为M状态，此时不需要广播其它cache。</p>
<h6 id="MOSI"><a href="#MOSI" class="headerlink" title="MOSI"></a>MOSI</h6><p><img src="/2024/02/16/Computer-Architecture/image-91.png" alt="Alt text"></p>
<p>应用场景：处理器之间交换数据速度比处理器与Memory之间交换数据快时，添加一个状态叫Owned</p>
<p>状态为O说明只有这个Cache中的数据是最新的，其它cache都不从memory中拿数据而是从该cache中拿。</p>
<p>O变为M,说明写回Memory的动作完成。</p>
<h5 id="Snoopy总结"><a href="#Snoopy总结" class="headerlink" title="Snoopy总结"></a>Snoopy总结</h5><p>Snoopy协议的基本概念<br>“Snoopy”协议得名于它的工作方式，类似于卡通角色“Snoopy”（史努比）的窥探行为。在这种协议下，每个处理器（或更准确地说，每个处理器的缓存控制器）都会“窥探”（snoop）在共享总线上发生的所有事务（如读取和写入操作），以监控其他处理器对共享内存的访问。</p>
<p>工作机制<br>缓存一致性：Snoopy协议的主要目的是维持缓存一致性，确保所有处理器的缓存中存储的是共享内存的最新数据。</p>
<p>总线监听：当一个处理器执行内存操作（读取或写入）时，其他处理器的缓存控制器会监听总线上的这些操作，并根据需要更新或失效其本地缓存副本。</p>
<p>写入操作：例如，当一个处理器写入共享数据时，其他处理器的缓存可能需要使其缓存中的相应数据无效，以保证一致性。</p>
<p>Snoopy协议的类型<br>写失效（Write Invalidate）：最常见的方式是在写入数据时使其他所有缓存中的该数据无效。<br>写更新（Write Update）：另一种方式是在写入数据时更新所有缓存中的该数据副本。<br>优点与挑战<br>优点：Snoopy协议简单直观，对于中等规模的多处理器系统非常有效。<br>挑战：随着处理器数量的增加，总线流量和协议开销可能会变得过大，影响系统性能。对于大规模的多处理器系统，可能需要更复杂的一致性协议。</p>
<h5 id="Directory-Coherence-Protocol-目录协议"><a href="#Directory-Coherence-Protocol-目录协议" class="headerlink" title="Directory Coherence Protocol 目录协议"></a>Directory Coherence Protocol 目录协议</h5><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>Directory Coherence Protocol是一种用于维护多处理器系统中缓存一致性的协议，特别适用于大规模或者分布式共享内存系统。与基于总线的Snoopy协议不同，Directory协议不依赖于总线广播，而是使用一个中央的存储结构（称为目录）来追踪哪些处理器拥有某个内存位置的副本。</p>
<p>工作原理<br>目录（Directory）：目录是一个数据结构，它存储了每个内存块的共享信息。对于每个内存块，目录记录了哪些缓存拥有该块的副本，以及每个副本的状态（例如，是否被修改）。</p>
<p>状态追踪：当处理器需要读取或写入内存时，它首先与目录通信。目录决定是否需要采取行动，如向其他拥有该数据副本的缓存发送失效（Invalidate）或更新（Update）消息。</p>
<p>消息传递：Directory协议依赖于消息传递机制，用于在处理器、缓存和目录之间传递控制消息。</p>
<p>工作流程<br>读取操作：当处理器发起一个读取请求时，目录检查该内存块的状态，并根据需要更新状态和发送消息。<br>写入操作：当处理器发起写入请求时，目录可能需要向其他拥有该内存块副本的缓存发送失效消息，以保持一致性。<br>优点<br>可扩展性：由于不依赖于总线广播，Directory协议在大规模多处理器系统中比Snoopy协议具有更好的可扩展性。<br>减少网络流量：通过仅向相关的缓存发送消息，Directory协议可以减少网络上的流量和冲突。<br>挑战。</p>
<p>目录开销：目录的维护需要额外的存储空间和管理开销。<br>复杂性：实现和维护Directory协议比Snoopy协议更复杂，特别是在处理大量处理器和缓存时。</p>
<h5 id="-1"><a href="#-1" class="headerlink" title></a></h5><p><img src="/2024/02/16/Computer-Architecture/image-92.png" alt="Alt text"><br>Local Node（本地节点）<br>含义：Local node通常指发起某个特定内存操作（如读取或写入请求）的处理器或缓存。<br>作用：本地节点根据需要读取或修改数据，并与目录节点通信以维护一致性。<br>例子：如果一个处理器尝试写入一个共享变量，那么这个处理器就是该写入操作的本地节点。<br>Home Node（家节点）<br>含义：Home node是存储某个特定内存地址的数据和其目录条目的节点。<br>作用：家节点负责管理目录信息，包括哪些节点拥有该内存地址的副本，以及这些副本的状态（共享、独占、修改等）。<br>例子：对于给定的内存地址，家节点包含该地址的主副本和一个目录条目，用于跟踪其他节点对该地址的缓存情况。<br>Remote Node（远程节点）<br>含义：Remote node指除了本地节点和家节点之外，涉及到特定内存操作的其他节点。<br>作用：远程节点可能包含与操作相关的内存地址的缓存副本。在处理缓存一致性操作时，家节点可能需要向远程节点发送消息，如失效或更新消息。<br>例子：如果多个处理器缓存了同一个内存地址的数据，那么在某个处理器（本地节点）写入该地址时，其他拥有该地址副本的节点就是远程节点。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-93.png" alt="Alt text"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CA/" rel="tag"># CA</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/02/12/System-Verilog-Notes/" rel="prev" title="System Verilog Notes">
      <i class="fa fa-chevron-left"></i> System Verilog Notes
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/" rel="next" title="SoC设计方法">
      SoC设计方法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%AD%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">高等计算机体系结构课程笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter1-Overview-and-Fundamental"><span class="nav-number">1.1.</span> <span class="nav-text">chapter1 Overview and Fundamental</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter2-Memory-Hierarchy"><span class="nav-number">1.2.</span> <span class="nav-text">Chapter2 Memory Hierarchy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.2.2.</span> <span class="nav-text">Cache的原理及设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%9D%97%E7%9A%84%E6%91%86%E6%94%BE-Block-Placement"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">数据块的摆放(Block Placement)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%9D%97%E7%9A%84%E5%AF%BB%E5%9D%80"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">数据块的寻址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%9D%97%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">数据块替换策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E7%AD%96%E7%95%A5"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">写策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache-%E6%80%A7%E8%83%BD%E5%AF%B9CPI%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">Cache 性能对CPI的影响</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%B1%E5%93%8Dcache%E6%80%A7%E8%83%BD%E7%9A%844C%E5%9B%A0%E7%B4%A0"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">影响cache性能的4C因素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E7%A7%8D%E5%9F%BA%E7%A1%80%E7%9A%84Cache%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.3.</span> <span class="nav-text">6种基础的Cache性能优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E7%A7%8D%E8%BF%9B%E9%98%B6%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">1.2.4.</span> <span class="nav-text">10种进阶优化策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">1.2.5.</span> <span class="nav-text">虚拟存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">虚拟地址和物理地址的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%EF%BC%88Page-Fault%EF%BC%89"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">缺页中断（Page Fault）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E8%A1%A8TLB-Translation-Look-aside-Buffer"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">快表TLB(Translation Look-aside Buffer)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB%E5%92%8Ccache%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">TLB和cache的交互</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">多级页表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-3-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95"><span class="nav-number">1.3.</span> <span class="nav-text">Chapter 3 指令级并行及其扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8Ddata-hazard"><span class="nav-number">1.3.1.</span> <span class="nav-text">三种data hazard:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RAW-read-after-write"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">RAW(read after write)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WAR%EF%BC%88%E8%AF%BB%E5%90%8E%E5%86%99%EF%BC%89"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">WAR（读后写）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WAW%EF%BC%88%E5%86%99%E5%90%8E%E5%86%99%EF%BC%89"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">WAW（写后写）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E7%9C%9F%E7%9B%B8%E5%85%B3%EF%BC%9Abypassing%E5%92%8C-forwarding"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">解决真相关：bypassing和 forwarding</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Control-Hazard"><span class="nav-number">1.3.2.</span> <span class="nav-text">Control Hazard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">分支预测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">动态分支预测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BTB%EF%BC%88Branch-Target-Buffer%EF%BC%89-%E5%92%8CBHT%EF%BC%88Branch-History-Table%EF%BC%89"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">BTB（Branch Target Buffer） 和BHT（Branch History Table）:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BD%8D%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">一位分支预测的缺点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%EF%BC%9A2%E4%BD%8D%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">改进：2位分支预测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%EF%BC%9ACorrelating-Branch-Predictor%EF%BC%88%E7%9B%B8%E5%85%B3%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%99%A8%EF%BC%89"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">高级预测方法：Correlating Branch Predictor（相关分支预测器）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tournament-Predictor-%EF%BC%88%E9%94%A6%E6%A0%87%E8%B5%9B%E9%A2%84%E6%B5%8B%E5%99%A8%EF%BC%89"><span class="nav-number">1.3.4.5.</span> <span class="nav-text">Tournament Predictor （锦标赛预测器）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Software-Scheduling-for-Exposing-ILP%EF%BC%88%E8%BD%AF%E4%BB%B6%E8%B0%83%E5%BA%A6%E7%9A%84ILP%EF%BC%89"><span class="nav-number">1.3.5.</span> <span class="nav-text">Software Scheduling for Exposing ILP（软件调度的ILP）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dynamic-Scheduling-%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6"><span class="nav-number">1.3.6.</span> <span class="nav-text">Dynamic Scheduling 动态调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OOO-out-of-order-%E7%9A%84%E6%80%9D%E6%83%B3"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">OOO(out of order)的思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tomasulo-Algorithm"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">Tomasulo Algorithm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">进一步理解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">执行过程：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tumasulo%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.6.5.</span> <span class="nav-text">Tumasulo的总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dynamic-Scheduling%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.6.6.</span> <span class="nav-text">Dynamic Scheduling的总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E6%96%AD%EF%BC%88Speculation%EF%BC%89"><span class="nav-number">1.3.7.</span> <span class="nav-text">推断（Speculation）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E7%A1%AC%E4%BB%B6-ROB%EF%BC%88Reorded-Buffer%EF%BC%89"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">关键硬件: ROB（Reorded Buffer）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ROB%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.7.1.1.</span> <span class="nav-text">ROB的工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ROB%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">1.3.7.1.2.</span> <span class="nav-text">ROB的重要性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multi-Issue%E5%A4%9A%E5%8F%91%E5%B0%84"><span class="nav-number">1.3.8.</span> <span class="nav-text">Multi Issue多发射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8BMulti-Thread"><span class="nav-number">1.3.9.</span> <span class="nav-text">多线程Multi Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.3.10.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-4-DLP-in-Vector-SIMD-and-GPU-Architectures"><span class="nav-number">1.4.</span> <span class="nav-text">Chapter 4 DLP in Vector, SIMD, and GPU  Architectures</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="nav-number">1.4.1.</span> <span class="nav-text">基本概念：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BA%A7%E5%B9%B6%E8%A1%8C%EF%BC%88Data-level-parallelism-DLP%EF%BC%89"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">数据级并行（Data level parallelism, DLP）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%8C%87%E4%BB%A4%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%88Single-Instruction-Multi-Data-SIMD%EF%BC%89"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">单指令多数据流（Single Instruction Multi Data,SIMD）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88Vector-Processor%EF%BC%89"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">向量处理器（Vector Processor）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E4%BE%8B%E5%AD%90-VMIPS"><span class="nav-number">1.4.2.</span> <span class="nav-text">一个典型例子:VMIPS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90"><span class="nav-number">1.4.2.0.1.</span> <span class="nav-text">向量体系结构的运行时间分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E5%8D%87Vector%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">提升Vector性能的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#multiple-lanes"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">multiple lanes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Vector-Length-Register"><span class="nav-number">1.4.2.1.2.</span> <span class="nav-text">Vector Length Register</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Vertor-Mask-Register"><span class="nav-number">1.4.2.1.3.</span> <span class="nav-text">Vertor Mask Register</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Memory-Banks"><span class="nav-number">1.4.2.1.4.</span> <span class="nav-text">Memory Banks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Scatter-Gather-%E5%AF%B9%E7%A8%80%E7%96%8F%E7%9A%84%E6%94%AF%E6%8C%81%E3%80%82"><span class="nav-number">1.4.2.1.5.</span> <span class="nav-text">Scatter-Gather 对稀疏的支持。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">向量处理器的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">1.4.2.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GPGPU-General-Purpose-Graphics-Processing-Unit-%E9%80%9A%E7%94%A8%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">1.4.3.</span> <span class="nav-text">GPGPU General Purpose Graphics Processing Unit 通用图形处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">编程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97-Heterogeneous-computing"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">异构计算 Heterogeneous computing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GPGPU%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">GPGPU的线程模型：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SMIT-%E5%92%8CSMID%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.3.2.3.</span> <span class="nav-text">SMIT 和SMID的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GPU%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.4.3.2.4.</span> <span class="nav-text">GPU的优势</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GPU%E6%8E%A7%E5%88%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">GPU控制架构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Warp%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.4.3.3.1.</span> <span class="nav-text">Warp的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%91%E6%95%A3"><span class="nav-number">1.4.3.3.2.</span> <span class="nav-text">线程的发散</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GPU-%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">GPU 存储架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E5%8D%95%E5%85%83%E6%9E%B6%E6%9E%84"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">运算单元架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%A0%E9%87%8F%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">张量核心架构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-5-Multiprocess-and-Thread-Level-Parallelism"><span class="nav-number">1.5.</span> <span class="nav-text">Chapter 5 Multiprocess and Thread-Level Parallelism</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.5.1.</span> <span class="nav-text">多处理器的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMP%E5%92%8CDMP"><span class="nav-number">1.5.2.</span> <span class="nav-text">SMP和DMP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SMP-Symmetric-multiprocessors"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">SMP(Symmetric multiprocessors)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DMP"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">DMP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%8C%91%E6%88%98"><span class="nav-number">1.5.3.</span> <span class="nav-text">多处理器的并行挑战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%95%88%E7%8E%87"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">并行效率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%BC%80%E9%94%80"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">通信开销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7-Cache-Coherence"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">缓存一致性(Cache Coherence)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Snoopy-%E7%9B%91%E5%90%AC-Coherence-Protocol"><span class="nav-number">1.5.3.3.1.</span> <span class="nav-text">Snoopy(监听) Coherence Protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%86%85%E5%AE%B9"><span class="nav-number">1.5.3.3.1.1.</span> <span class="nav-text">协议内容</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Snoopy%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%9A"><span class="nav-number">1.5.3.3.2.</span> <span class="nav-text">Snoopy协议的扩展：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#MESI"><span class="nav-number">1.5.3.3.2.1.</span> <span class="nav-text">MESI</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MOSI"><span class="nav-number">1.5.3.3.2.2.</span> <span class="nav-text">MOSI</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Snoopy%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.3.3.3.</span> <span class="nav-text">Snoopy总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Directory-Coherence-Protocol-%E7%9B%AE%E5%BD%95%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.5.3.3.4.</span> <span class="nav-text">Directory Coherence Protocol 目录协议</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.3.3.4.1.</span> <span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#-1"><span class="nav-number">1.5.3.3.5.</span> <span class="nav-text"></span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang xianke</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Wangxianke123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Wangxianke123" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang xianke</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">129k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:55</span>
</div>

        








      </div>
      <script src="https://Wangxianke123.github.io/live2d/autoload.js"></script>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>

</html>
