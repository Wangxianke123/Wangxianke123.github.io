<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CORDIC Algorithm</title>
    <url>/2024/02/28/CORDIC-Algorithm/</url>
    <content><![CDATA[<h1 id="Coordinate-Rotation-Dlgital-Computer-CORDIC-算法"><a href="#Coordinate-Rotation-Dlgital-Computer-CORDIC-算法" class="headerlink" title="Coordinate Rotation Dlgital Computer(CORDIC)算法"></a>Coordinate Rotation Dlgital Computer(CORDIC)算法</h1><p>参考：Computer Arithmetic: Algorithm and Hardware Design</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="角度模式"><a href="#角度模式" class="headerlink" title="角度模式"></a>角度模式</h3><p>考虑平面直角坐标系下的旋转，如图：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image.png" alt="basic"></p>
<p>点$E^{(i)}$旋转$\alpha^{(i)}$后得到了点$E^{(i+1)}$</p>
<p>那么假设$E^{(i)}$的坐标为：$E^{(i)}$:   $(x^{(i)},y^{(i)})&#x3D;(R^{(i)}cos\theta,R^{(i)}cos\theta)$</p>
<p>$E^{(i+1)}$的坐标可以表示为：<br>$x^{(i)+1} &#x3D; R^{(i)}cos(\theta+\alpha) &#x3D; x^{(i)}cos\alpha - y^{(i)}sin\alpha \ &#x3D;\frac{ x^{(i)}-y^{(i)}tan\alpha}{\frac{1}{cos\alpha}}\ &#x3D; \frac{ x^{(i)}-y^{(i)}tan\alpha}{(1+tan^2\alpha)^{1&#x2F;2}}$</p>
<p>同理有：<br>$y^{(i+1)} &#x3D; R^{(i)}sin(\theta+\alpha) &#x3D; x^{(i)}sin\alpha + y^{(i)}cos\alpha \ &#x3D;\frac{ x^{(i)}tan\alpha + y^{(i)} }{\frac{1}{cos\alpha}}\ &#x3D; \frac{  x^{(i)}tan\alpha + y^{(i)}}{(1+tan^2\alpha)^{1&#x2F;2}}$</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-1.png"></p>
<p>上述公式是一个迭代式，<br>$ z^{(i)}$表示当前旋转之前向量与x轴的夹角，$ z^{(i+1)}$表示在旋转后与x轴的夹角（顺时针为正）。</p>
<p>现在考虑一种图中的一种伪旋转，对公式2边同时除以$\cos\alpha^{(i)}$,得到$E’^{(i)}$的坐标：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-3.png"><br><img src="/2024/02/28/CORDIC-Algorithm/image-2.png"></p>
<p>令$x^{(0)}&#x3D;x,  y^{(0)}&#x3D;y,  z^{(0)}&#x3D;z$，则对于一个m次迭代的真旋转，有：<br><img src="/2024/02/28/CORDIC-Algorithm/image-4.png"></p>
<p>对伪旋转：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-5.png"></p>
<p>考虑每次迭代的角度选取，如果使$tan\alpha$恰好等于 $2^{-i},i&#x3D;0,1,2,3…$则上式变为：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-6.png"></p>
<p>其中$d_i \in {−1,1}$ </p>
<p>则每次真旋转迭代的计算可以通过：1次查表，2次移位，3次加(减)法实现。</p>
<p>对于伪旋转，由于每次的角度选取是固定值，因此K为常数，K &#x3D; 1.646 760 258 121….</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-7.png"></p>
<p>考虑计算 $cosz$,可以令$x^{(0)}&#x3D;1,  y^{(0)}&#x3D;0,  \sum\alpha^{(i)}&#x3D;z$此时有：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-10.png"></p>
<p>如果计算$cos30^\circ$,可以：<br><img src="/2024/02/28/CORDIC-Algorithm/image-8.png"></p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-9.png"></p>
<p>由于表中的角度表示范围达到了$−99.7^\circ ≤ z ≤ 99.7^\circ$,因此可以通过上述方法加上基本三角变化求出任何角的正余弦值。</p>
<h3 id="向量模式"><a href="#向量模式" class="headerlink" title="向量模式"></a>向量模式</h3><p>通过令$y\rightarrow 0$,可以计算反三角函数值$tan^{-1}y$,此时，</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-12.png"><br>带入</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-5.png"></p>
<p>可得<br><img src="/2024/02/28/CORDIC-Algorithm/image-13.png"></p>
<p>故可以取(1,y),将其旋转到x轴上，此时旋转过的角度即为$tan^{-1}y$</p>
<h3 id="一个简单的python验证程序"><a href="#一个简单的python验证程序" class="headerlink" title="一个简单的python验证程序"></a>一个简单的python验证程序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">lookuptable = &#123;&#125;</span><br><span class="line"></span><br><span class="line">lookuptable[<span class="number">0</span>]=<span class="number">45.0</span></span><br><span class="line">lookuptable[<span class="number">1</span>]=<span class="number">26.5650</span></span><br><span class="line">lookuptable[<span class="number">2</span>]=<span class="number">14.0362</span></span><br><span class="line">lookuptable[<span class="number">3</span>]=<span class="number">7.1250</span></span><br><span class="line">lookuptable[<span class="number">4</span>]=<span class="number">3.5763</span></span><br><span class="line">lookuptable[<span class="number">5</span>]=<span class="number">1.7899</span></span><br><span class="line">lookuptable[<span class="number">6</span>]=<span class="number">0.8951</span></span><br><span class="line">lookuptable[<span class="number">7</span>]=<span class="number">0.4476</span></span><br><span class="line">lookuptable[<span class="number">8</span>]=<span class="number">0.2238</span></span><br><span class="line">lookuptable[<span class="number">9</span>]=<span class="number">0.1119</span></span><br><span class="line">lookuptable[<span class="number">10</span>]=<span class="number">0.0230</span></span><br><span class="line">lookuptable[<span class="number">11</span>]=<span class="number">0.0140</span></span><br><span class="line">lookuptable[<span class="number">12</span>]=<span class="number">0.0070</span></span><br><span class="line">lookuptable[<span class="number">13</span>]=<span class="number">0.0035</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cordic</span>(<span class="params">value,  mode</span>):</span><br><span class="line">    z = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(mode==<span class="number">0</span>):</span><br><span class="line">        x =  <span class="number">0.607252935</span></span><br><span class="line">        y = <span class="number">0.0</span> </span><br><span class="line">    <span class="keyword">if</span>(mode==<span class="number">1</span>):</span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        y = value</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">        <span class="keyword">if</span>(mode==<span class="number">0</span>):</span><br><span class="line">            d = np.sign(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d = -np.sign(y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">0</span>):d = <span class="number">1</span></span><br><span class="line">        value -= d*lookuptable[i]</span><br><span class="line"></span><br><span class="line">        z -= d*lookuptable[i]</span><br><span class="line"></span><br><span class="line">        temp = x</span><br><span class="line">        x -= d * y * <span class="number">2.0</span>**(-i)</span><br><span class="line">        y +=  d* temp * <span class="number">2.0</span>**(-i)</span><br><span class="line">        <span class="comment"># print(&quot;y:&quot;,y)</span></span><br><span class="line">        <span class="comment"># print(&quot;x:&quot;,x)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mode==<span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;sin:&quot;</span>,y)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cos:&quot;</span>,x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;theta:&quot;</span>,z)</span><br><span class="line"></span><br><span class="line">cordic(<span class="number">4</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>对一个n位的cordic运算，若采用纯硬件实现，每一位需要1次查表，2次移位，3次加法，其计算复杂度是$O(n)$这个量级的。</p>
<p>考虑硬件实现，一个最简单的版本是这样的：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-14.png"></p>
<p>在不考虑优化版本时，图中的加法器可以用串行进位的方式实现，此时，对于k位的操作数，计算需要的时钟周期为$O(k^2)$。</p>
<h3 id="通用版本"><a href="#通用版本" class="headerlink" title="通用版本"></a>通用版本</h3><p><img src="/2024/02/28/CORDIC-Algorithm/image-15.png"></p>
<p>CORDIC算法可以被拓展，用于线性和双曲函数的计算。其通用公式为：<br><img src="/2024/02/28/CORDIC-Algorithm/image-17.png"><br><img src="/2024/02/28/CORDIC-Algorithm/image-16.png"></p>
<p>推理过程如下：<br>参考：（A unified algorithm for elementary functions）</p>
<p>考虑一个从二维直角坐标系到极坐标的非线性映射：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-18.png"></p>
<p>其中R是映射后的向量长度，A是其与坐标轴的夹角。</p>
<p>显然当m取1时，该映射为从直角坐标系到极坐标系的坐标变换。<br>当m取0时， 该变换总是落在一条相同的直线上<br>当m&#x3D;-1时，该变换为落在一条双曲线$x^2-y^2&#x3D;1$上。</p>
<p>事实上，如果将R看作特定曲线与x轴交点到原点的距离，根据上述定义，总是有：<br>$A &#x3D; \frac{2S}{R^2}$<br><img src="/2024/02/28/CORDIC-Algorithm/image-19.png"></p>
<p>其中S为变换前的点P与点O,R围成的阴影部分面积。</p>
<p>如果给出一个迭代式：<br><img src="/2024/02/28/CORDIC-Algorithm/image-20.png"></p>
<p>其中$\delta_i$时任意值，而m是映射中的参数。那么每次迭代后的点经过非线性映射后，在极坐标下可以表示为：<br><img src="/2024/02/28/CORDIC-Algorithm/image-21.png"></p>
<p>其中<br><img src="/2024/02/28/CORDIC-Algorithm/image-22.png"></p>
<p>即每次迭代可以看作是一次旋转和放缩。对n次迭代，最后得到的长度和角度为：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-23.png"></p>
<p>其中<img src="/2024/02/28/CORDIC-Algorithm/image-24.png"></p>
<p>如果再定义一个新的变量<br><img src="/2024/02/28/CORDIC-Algorithm/image-25.png"></p>
<p>则经过n次迭代后的点经过逆映射后，可以得到其在直角坐标系下的坐标：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-26.png"></p>
<p>同样的，注意到当m&#x3D;1时，该迭代式与之前推出的角度模式下的伪旋转迭代式一模一样。</p>
<p>而当m&#x3D;0时，分别让$y\rightarrow0$和$z\rightarrow 0$,可以得到如下不同的迭代结果：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-27.png"><br>且在m&#x3D;0时，多轮迭代后的缩放因子为1.</p>
<p>上述公式说明，直线迭代可以用于计算乘法，除法或直接计算一个乘加、除加操作。</p>
<p>而对双曲映射，迭代结果分别为：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-28.png"></p>
<p>其中缩放因子<code>K&#39;=0.8281593609602</code>。</p>
<p>上述公式说明，双曲映射可以被用来计算双曲正弦，双曲余弦和双曲正切函数。</p>
<p>另外需要注意的是，对于双曲映射，并不总是收敛的，这是因为对于tan函数，总是有：<br> $tan^{−1}(2^{−(i+1)}) ≥ 0.5tan^{−1}(2^{−i})$</p>
<p>而同样的关系:放在双曲正切中却并不总是成立。</p>
<p>$tanh^{−1}(2^{−(i+1)}) ≥ 0.5tanh^{−1}(2^{−i})$</p>
<p>一个简单的收敛方法为，当迭代次数为:$ i &#x3D; 4, 13, 40, 121, …,3j + 1$时，该次迭代必须再重复一遍。即：<br>1,2,3,4,4,5,6,7,8,9,10,11,12,13,13,14….<br>(收敛性分析在原论文中有比较严格的推导，我懒得手推一遍，这里就不重复了，直接使用其结果)</p>
<p>计算范围为： <code>With these provisions, convergence in computing  hyperbolic sine and cosine functions is guaranteed for |z| &lt; 1.13 and in the case of the  tanh−1 function, for |y| &lt; 0.81.</code></p>
<p>此外，以下函数也可以被间接计算出来：<br><img src="/2024/02/28/CORDIC-Algorithm/image-29.png"></p>
<h3 id="收敛性仿真"><a href="#收敛性仿真" class="headerlink" title="收敛性仿真"></a>收敛性仿真</h3><p>写一个简单的双曲迭代来验证上述方法的收敛性：</p>
<p>以cosh为例，以下是一段简单的python代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>): </span><br><span class="line">    lookuptable_tanh[i] = math.atanh(<span class="number">2</span>**(-i))</span><br><span class="line">    <span class="built_in">print</span>(math.atanh(<span class="number">2</span>**(-i)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_tanh</span>(<span class="params">value</span>):</span><br><span class="line">    k=<span class="number">0.8281593609602</span></span><br><span class="line">    x=<span class="number">1</span>/k</span><br><span class="line">    y=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>):</span><br><span class="line">        <span class="keyword">if</span>(value)&gt;<span class="number">0</span>:</span><br><span class="line">            d=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d=-<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        value = value - d*lookuptable_tanh[i]</span><br><span class="line">        temp=x</span><br><span class="line">        x = x + d*y*<span class="number">2</span>**-i</span><br><span class="line">        y = y + d*temp*<span class="number">2</span>**-i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if(i==4 or i==13):</span></span><br><span class="line">        <span class="comment">#     if(value)&gt;0:</span></span><br><span class="line">        <span class="comment">#         d=1</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         d=-1</span></span><br><span class="line">        <span class="comment">#     value = value - d*lookuptable_tanh[i]</span></span><br><span class="line">        <span class="comment">#     temp=x</span></span><br><span class="line">        <span class="comment">#     x = x + d*y*2**-i</span></span><br><span class="line">        <span class="comment">#     y = y + d*temp*2**-i</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;my_cosh:&quot;</span>,x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;my_sinh:&quot;</span>,y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;my_tanh:&quot;</span>,y/x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(x,y,y/x)</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># 计算对应的 cosh 函数值</span></span><br><span class="line">y_numpy = np.cosh(x)</span><br><span class="line"></span><br><span class="line">y_custom=[]</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> x:</span><br><span class="line">    y,_,_ = my_tanh(value)</span><br><span class="line">    y_custom.append(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plt.plot(x, y_numpy, label=<span class="string">&#x27;numpy.cosh(x)&#x27;</span>)</span><br><span class="line">plt.plot(x, y_custom, label=<span class="string">&#x27;my_cosh(x)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;cosh(x)&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Comparison of cosh(x) functions&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>在不用重复第4次和第13次迭代时，结果如下：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-30.png"></p>
<p>可以看到蓝色线和橙色线不完全重合，局部放大后结果如下：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-31.png"></p>
<p>取消对应注释，重复第4和第13次迭代，结果如下：</p>
<p><img src="/2024/02/28/CORDIC-Algorithm/image-32.png"></p>
<p>可以看到蓝色线和橙色线基本完全重合，局部放大后结果如下：<br><img src="/2024/02/28/CORDIC-Algorithm/image-33.png"></p>
<h3 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h3>]]></content>
      <tags>
        <tag>数字集成电路</tag>
        <tag>Hardware Algorithm</tag>
        <tag>ICer</tag>
      </tags>
  </entry>
  <entry>
    <title>LFSR</title>
    <url>/2024/04/18/LFSR/</url>
    <content><![CDATA[<h1 id="LSFR"><a href="#LSFR" class="headerlink" title="LSFR"></a>LSFR</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LFSR 全称为Linear Feedback Shift Register, 线性反馈移位寄存器。LFSR 可以用来<br>产生可重复的伪随机序列，从而被广泛使用在计数器，解码器，密码系统，BIST等方<br>面。<br>一般的LFSR分为2种，内部反馈型和外部反馈型的LFSR，如图2–1所示。其中内<br>部反馈型LFSR又称为伽罗瓦LFSR，而外部反馈型LFSR又称为斐波那契型LFSR。</p>
<p><img src="/2024/04/18/LFSR/image.png" alt="2种不同类型的LFSR"></p>
<p>由于伽罗瓦LFSR的逻辑门位于2级寄存器之间，理论上拥有更低的延迟和更高的<br>频率。</p>
<p>LFSR可以生成具有固定周期的序列，当周期很长时，序列可以看作是近似随机的。</p>
<h2 id="LFSR的周期"><a href="#LFSR的周期" class="headerlink" title="LFSR的周期"></a>LFSR的周期</h2><p>LFSR的一个重要特性是其生成序列的周期性。对于一个n位的LFSR，其周期最大为$2^n-1$,这是因为全0的状态会无限循环，从而需要将全0的序列从中剔除。</p>
<p>一个LFSR的特性可以使用反馈多项式来描述。如图<br><img src="/2024/04/18/LFSR/image-1.png"></p>
<p>这样的一个LFSR,其反馈多项式可以写作：<br>$$f(x)  &#x3D; 1 + h_1x+ h_2x^2+\dots +h_{n-1}x^{n-1}+h_nx^n$$</p>
<p>之所以加上1， 是因为我们假设原始输入为0000..1,避免全0的状态。</p>
<p>需要注意的是，反馈多项式和用二进制表示多项式的概念是不同的。</p>
<p>反馈多项式代表LFSR的周期特征。具体来说，LFSR的周期数与其反馈多项式的阶数有关。<br>设$P_n(x)$为n次多项式，满足：<br>$$min{k:P_n(x)|(x^k+1)}$$<br>的整数称为多项式$P_n(x)$的阶。即多项式$P_n(x)$仅能被$x^k+1$整除，而对任何${x^m+1|m&lt;k}$,$P_n(x)$均不能被其整除。(这里的整除是GF(2)意义上的整除，在GF(2)域上，加法和减法都等价于模2运算。)</p>
<p>进一步的，称阶数为$2^n-1$的不可约多项式$P(x)$为$GF(2^n)$域上的本原多项式。即本原多项式仅能被$x^{2^n-1}+1$整除，而不能被${x^m+1|m&lt;2^n-1}$整除。同时，本原多项式还无法被分解为$f(x)g(x)$的形式。不可约多项式有点类似于”素数”的概念，即不能被分解为更小的2个多项式的乘积。</p>
<p>LFSR的周期数等于其反馈多项式的阶数。由此我们可以知道，为了构造具有最大周期数的LFSR,我们需要构造反馈多项式为本原多项式的LFSR。</p>
<p>下面是一个寻找本原多项式的python程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_primitive_poly</span>(<span class="params">poly, field_size</span>):</span><br><span class="line">    x = sympy.Symbol(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> poly.degree() != field_size:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> poly.is_irreducible:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**(field_size-<span class="number">1</span>),<span class="number">2</span>**(field_size)-<span class="number">1</span>):</span><br><span class="line">        level = sympy.Poly(x**i+<span class="number">1</span>, x, domain=<span class="string">&#x27;GF(2)&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> level.rem(poly).is_zero:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">integer_to_binary_list</span>(<span class="params">i</span>):</span><br><span class="line">    binary_string = <span class="built_in">bin</span>(i)[<span class="number">2</span>:]  </span><br><span class="line">    binary_list = [<span class="built_in">int</span>(bit) <span class="keyword">for</span> bit <span class="keyword">in</span> binary_string]  </span><br><span class="line">    <span class="keyword">return</span> binary_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_primitive_polys</span>(<span class="params">field_size</span>):</span><br><span class="line">    x = sympy.Symbol(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    primitive_polys = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2</span>**(field_size+<span class="number">1</span>)):</span><br><span class="line">        binary_list = integer_to_binary_list(i)</span><br><span class="line">        <span class="comment">#print(binary_list)</span></span><br><span class="line">        symb=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binary_list)):</span><br><span class="line">            symb += binary_list[j]*x**(<span class="built_in">len</span>(binary_list)-j-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        poly = sympy.Poly(symb, x, domain=<span class="string">&#x27;GF(2)&#x27;</span>)</span><br><span class="line">        <span class="comment">#print(poly)</span></span><br><span class="line">        <span class="keyword">if</span> is_primitive_poly(poly, field_size):</span><br><span class="line">            primitive_polys.append(poly)</span><br><span class="line">    <span class="keyword">return</span> primitive_polys</span><br><span class="line"></span><br><span class="line">field_size = <span class="number">9</span></span><br><span class="line">primitive_polys = find_primitive_polys(field_size)</span><br><span class="line"><span class="keyword">for</span> poly <span class="keyword">in</span> primitive_polys:</span><br><span class="line">    <span class="built_in">print</span>(poly)</span><br></pre></td></tr></table></figure>


<p>该程序的时间复杂度是$O(2^n)$级别的，性能会随着field size设置的增大而急剧下降。</p>
<p>一个更好的办法是利用前人的结果，通过查表寻找需要本原多项式。</p>
<p>下面的网站给出了$GF(2^{10})$以内的所有本原多项式：</p>
<p><a href="https://www.ece.unb.ca/tervo/ece4253/factors.shtml">https://www.ece.unb.ca/tervo/ece4253/factors.shtml</a></p>
<p>部分结果如图：</p>
<p><img src="/2024/04/18/LFSR/image-2.png"></p>
<h2 id="LFSR的应用"><a href="#LFSR的应用" class="headerlink" title="LFSR的应用"></a>LFSR的应用</h2><p>(待续)</p>
<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <tags>
        <tag>数字集成电路</tag>
        <tag>Basic Module</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnPerl</title>
    <url>/2024/05/08/LearnPerl/</url>
    <content><![CDATA[<h1 id="Learn-Perl"><a href="#Learn-Perl" class="headerlink" title="Learn Perl"></a>Learn Perl</h1><h2 id="ch2-标量数据"><a href="#ch2-标量数据" class="headerlink" title="ch2 标量数据"></a>ch2 标量数据</h2><h3 id="第一个Helloword-程序"><a href="#第一个Helloword-程序" class="headerlink" title="第一个Helloword 程序"></a>第一个Helloword 程序</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/perl</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Hello, world!\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>perl是一种脚本语言，一般已经被内置在类unix系统中。类似的还有shell，bash,csh,tcl,python等。</p>
<p>第一行的<code>#!</code>读作shell bang。shell bang 是一个用于指定脚本解释器的特殊字符组合。它由 <code>#</code>（井号）和 <code>!</code>（感叹号）组合而成，通常位于脚本的第一行。当一个脚本被执行时，系统会参考 shebang 指定的解释器来执行这个脚本。</p>
<p>例如，如果一个脚本的第一行是 <code>#!/bin/bash</code>，那么这个脚本就会使用 Bash 作为其解释器。如果改为 <code>#!/usr/bin/python3</code>，那么这个脚本就会使用 Python 3 作为其解释器。</p>
<p>linux默认的脚本解释器总是在&#x2F;usr&#x2F;bin目录下，如果解释器安装在其他目录下，则需要修改对应的路径。</p>
<p>由于有shell bang的存在，perl程序不需要有特定的扩展名，而只需要是<strong>可执行</strong>的。（为了区分可以加上<code>.pl</code>）的后缀。</p>
<p>此外也可以直接通过<code>perl</code>命令执行脚本。这2种方式大部分情况下是相同的，然而有时候也会产生不同的效果。</p>
<p><img src="/2024/05/08/LearnPerl/image.png"><br>目前本人还没搞清楚这种情况出现的原因。</p>
<p>反引号&#96;&#96;可以用于执行外部命令:</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/perl</span></span><br><span class="line"> @lines = <span class="string">`ls -a`</span>;</span><br><span class="line"> <span class="keyword">foreach</span> (@lines) &#123;</span><br><span class="line">  <span class="keyword">print</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="标量数据"><a href="#标量数据" class="headerlink" title="标量数据"></a>标量数据</h3><p>字符串，数字都被看做标量数据。</p>
<p>perl会根据数据的操作符判断执行代数运算还是字符串操作。</p>
<p>变量采用美元符号声明：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/perl</span></span><br><span class="line"><span class="keyword">use</span> v5.<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">$alef  = <span class="keyword">chr</span>( <span class="number">0x05D0</span> );</span><br><span class="line">$alpha = <span class="keyword">chr</span>( <span class="keyword">hex</span>(<span class="string">&#x27;03B1&#x27;</span>) );</span><br><span class="line">$omega = <span class="keyword">chr</span>( <span class="number">0x03C9</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">say</span> <span class="string">&quot;alpha:&quot;</span>.$alpha;</span><br><span class="line"><span class="keyword">say</span> <span class="string">&quot;alef:&quot;</span>.$alef;</span><br><span class="line"><span class="keyword">say</span> <span class="string">&quot;omega:&quot;</span>.$omega;</span><br><span class="line"></span><br><span class="line">$code_point = <span class="keyword">ord</span>( <span class="string">&#x27;א&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">say</span> $code_point;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/05/08/LearnPerl/image2.png"><br>chr函数会将对应的ascii字符进行转换。ord则相反。</p>
<p>使用<code>x</code>可以将字符串重复对应的次数。</p>
<p><img src="/2024/05/08/LearnPerl/image1.png"></p>
<p><code>say</code>和<code>print</code>类似，区别是会自动换行。（需要5.10以上的版本）</p>
<p>使用<code>.</code>可以连接2个字符串。</p>
<h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><p>获取标准输入：<code>&lt;STDIN&gt;</code></p>
<p><img src="/2024/05/08/LearnPerl/image-1.png"></p>
<p><img src="/2024/05/08/LearnPerl/image-2.png"></p>
<p><code>chomp</code>的作用是去掉字符串末尾的换行符。</p>
<h2 id="ch3"><a href="#ch3" class="headerlink" title="ch3"></a>ch3</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>数组和标量的声明方式完全相同。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/perl</span></span><br><span class="line"><span class="keyword">use</span> v5.<span class="number">10</span>;</span><br><span class="line">$word[<span class="number">0</span>]= <span class="string">&quot;s&quot;</span>;</span><br><span class="line"></span><br><span class="line">$word[<span class="number">1</span>]= <span class="string">&quot;h&quot;</span>;</span><br><span class="line">$word[<span class="number">2</span>]= <span class="string">&quot;i&quot;</span>;</span><br><span class="line">$word[<span class="number">3</span>]= <span class="string">&quot;t&quot;</span>;</span><br><span class="line"></span><br><span class="line">$a = $#word;</span><br><span class="line"><span class="keyword">say</span> $a;</span><br><span class="line"><span class="keyword">say</span>  $word[-<span class="number">4</span>].$word[-<span class="number">3</span>].$word[-<span class="number">2</span>].$word[-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wenkai@LAPTOP-36N49UJG:~/perl/ex3$ ./array</span><br><span class="line">3</span><br><span class="line">shit</span><br></pre></td></tr></table></figure>


<p><code>$#</code>得到数组的长度(减一)</p>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3>]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Programming Language</tag>
      </tags>
  </entry>
  <entry>
    <title>SoC设计方法</title>
    <url>/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/</url>
    <content><![CDATA[<h1 id="SoC设计方法"><a href="#SoC设计方法" class="headerlink" title="SoC设计方法"></a>SoC设计方法</h1><h2 id="Soc设计概述及流程"><a href="#Soc设计概述及流程" class="headerlink" title="Soc设计概述及流程"></a>Soc设计概述及流程</h2><h3 id="什么是SoC"><a href="#什么是SoC" class="headerlink" title="什么是SoC?"></a>什么是SoC?</h3><p>半导体产业模式及其基本分工：<br><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image.png" alt="半导体产业链"></p>
<h4 id="SoC的基本概念："><a href="#SoC的基本概念：" class="headerlink" title="SoC的基本概念："></a>SoC的基本概念：</h4><pre><code>SoC(System on Chip)：系统级芯片，片上系统
</code></pre>
<p>SoC的诞生是集成电路领域发展的必然趋势。SoC的应用场景：<br>➢高性能计算<br>➢智能手机<br>➢汽车主控<br>➢物联网设备</p>
<h4 id="SoC的优势"><a href="#SoC的优势" class="headerlink" title="SoC的优势"></a>SoC的优势</h4><ol>
<li>有利于复杂系统的集成</li>
<li>缩短设计时间</li>
<li>可靠性更高</li>
<li>延迟更低(内部连线短，传输延迟更小。内部晶体管阻抗低，较小的门延迟)</li>
<li>低能耗</li>
<li>低成本（IP复用）</li>
</ol>
<h4 id="SoC发展的挑战"><a href="#SoC发展的挑战" class="headerlink" title="SoC发展的挑战"></a>SoC发展的挑战</h4><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-1.png" alt="设计成本"></p>
<ol>
<li><p>随着工艺节点的迭代，研发费用指数上升。</p>
</li>
<li><p>软硬件功能的划分（通用vs专用）<br><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-2.png" alt="不同划分带来不同成本占比"></p>
</li>
<li><p>复杂性提升导致的验证难度提升</p>
</li>
<li><p>制造成本高（7nm工艺下，$400mm^2$的芯片良率只有大约55%），设计错误不可接受</p>
</li>
</ol>
<h4 id="新型SoC-Chiplet"><a href="#新型SoC-Chiplet" class="headerlink" title="新型SoC: Chiplet"></a>新型SoC: Chiplet</h4><p>芯粒(Chiplet):将功能丰富面积较大的裸片（die）拆分成多个芯粒（chiplet）通过先进封装组合在一起形成一个系统芯片</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-3.png"></p>
<h4 id="SoC设计总结"><a href="#SoC设计总结" class="headerlink" title="SoC设计总结"></a>SoC设计总结</h4><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-4.png"></p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-5.png"></p>
<h3 id="SoC设计流程"><a href="#SoC设计流程" class="headerlink" title="SoC设计流程"></a>SoC设计流程</h3><p>SoC系统是软件和硬件的结合，需要综合评估系统的性能，设计相应的硬件和软件架构：</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-6.png" alt="SoC的软硬件协同设计流程"></p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-7.png" alt="SoC的软件设计流程"></p>
<h4 id="SoC的硬件设计流程"><a href="#SoC的硬件设计流程" class="headerlink" title="SoC的硬件设计流程"></a>SoC的硬件设计流程</h4><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-8.png" alt="SoC硬件设计流程-前端部分"></p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-9.png" alt="SoC硬件设计流程-后端部分"></p>
<p>步骤基本可以分为： </p>
<ol>
<li><strong>设计规范（spec）</strong>：确定芯片的顶层架构，规格参数，划分模块定义</li>
<li>模块设计与IP复用，顶端集成</li>
<li>前仿真：验证设计逻辑的正确性</li>
<li>验证</li>
<li>逻辑综合：代码翻译为电路（理想器件）</li>
<li>静态时序分析：检查设计是否符合时序要求，有无违例</li>
</ol>
<p>其中电路的抽象层次如下：</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-19.png"></p>
<p>分别为：</p>
<ol>
<li>系统级</li>
<li>RTL级</li>
<li>门级(gate level)</li>
<li>集体管级(transistor level)</li>
<li>版图级 (lay-out level)</li>
</ol>
<h3 id="静态时序分析"><a href="#静态时序分析" class="headerlink" title="静态时序分析"></a>静态时序分析</h3><h4 id="setup-time-建立时间"><a href="#setup-time-建立时间" class="headerlink" title="setup time 建立时间"></a>setup time 建立时间</h4><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-10.png" alt="建立时间"></p>
<p>在时钟信号到来之前，数据需要提前一段时间准备好。这个时间称为建立时间</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-11.png" alt="建立时间与时钟周期的关系"></p>
<p>如图，$t_{pcq}$指从时钟信号变化(50%)开始，到q端信号变化所需的时间(由寄存器本身的特性决定)；</p>
<p>$t_{pd}$是组合逻辑的传输延迟。</p>
<p>由于在下一个时钟到来之前，下一级寄存器的输入数据应当准备好，因此有：<br>$T_c \geq t_{pcq} + t_{pd} + t_{setup}$</p>
<h4 id="hold-time-保持时间"><a href="#hold-time-保持时间" class="headerlink" title="hold time 保持时间"></a>hold time 保持时间</h4><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-12.png" alt="保持时间"></p>
<p>在时钟信号变化之后，输入如数据不能立马跳变，而是需要保持原来的值一定时间，保证数据被完全写入寄存器。这个时间称为保持时间。</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-13.png" alt="保持时间的时序约束"></p>
<p>如图，对于理想时钟，clk总是同时到达。</p>
<p>$t_{ccq}$是时钟信号变化（50%）后，q1变化的时间。 </p>
<p>$t_{cd}$是组合逻辑的传播延时，则从时钟变化后，经过$t_{ccq}+t_{cd}$的时间，D2的数据会发生变化。</p>
<p>按照保持时间的定义，需满足：</p>
<p>$t_{ccq}+t_{cd} \geq t_{hold}$</p>
<h4 id="recovery-removal-time"><a href="#recovery-removal-time" class="headerlink" title="recovery&#x2F;removal time"></a>recovery&#x2F;removal time</h4><p>异步电路的复位信号，需要满足的时序关系：</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-14.png" alt="alt text"></p>
<h4 id="时钟偏斜-time-skew"><a href="#时钟偏斜-time-skew" class="headerlink" title="时钟偏斜 time skew"></a>时钟偏斜 time skew</h4><p>理论上clk对每个寄存器的clk端都应该相同，但实际上时钟到达每个元件的时间会有偏差，这个偏差称作time skew<br><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-15.png" alt="alt text"></p>
<p>可以通过插入buffer的办法尽量消除时钟偏向(时钟树综合)</p>
<h4 id="data-arrival-time-和-clk-arrival-time"><a href="#data-arrival-time-和-clk-arrival-time" class="headerlink" title="data arrival time 和 clk arrival  time"></a>data arrival time 和 clk arrival  time</h4><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-16.png" alt="data arrival time"></p>
<p>分析第二个寄存器的D端，数据到达需要经过：</p>
<ol>
<li>时钟启动时间(launch edge)</li>
<li>clk1相对于时钟源的延迟$T_{clk1}$</li>
<li>寄存器的内部延迟（时钟变化到数据变化需要的时间）$T_{co}$</li>
<li>组合逻辑的数据延迟 $T_{data}$</li>
</ol>
<p>分析第二个寄存器的时钟到达时间：<br><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-17.png" alt="clk arrival time"></p>
<ol>
<li>时钟启动时间(launch edge)</li>
<li>clk2相对于时钟源的延迟$T_{clk2}$</li>
</ol>
<p>根据建立时间，数据需要提前于时钟到达，并保持稳定：</p>
<p>$data\  required\  time（setup）  &#x3D; clk\  arrival \ time - t_{setup} - setup\ uncertainty$</p>
<p>根据保持时间的定义，在时钟到达后，数据需要保持稳定一段时间：</p>
<p>$data\  required\  time（hold）  &#x3D; clk\  arrival \ time + t_{hold} + hold\ uncertainty$</p>
<h4 id="时间裕量-time-slack"><a href="#时间裕量-time-slack" class="headerlink" title="时间裕量 time slack"></a>时间裕量 time slack</h4><p>对建立时间来说，由于数据应该提前到达，并保持一定时间的裕量，有：</p>
<p>$data \ arrival \ time(setup) + setup \ slack &#x3D; data \ required \ time$<br>$setup \ slack &#x3D; data \ required \ time - data \ arrival \ time \<br>  &#x3D;  clk\  arrival \ time - data \ arrival \ time - t_{setup} - setup\ uncertainty  $</p>
<p>set up slack应当大于0，才能保证时序正确。</p>
<p>对保持时间，时钟到达后数据需要保持一定的时间裕量，有：<br>$ data \ required \ time(hold) + hold \ slack &#x3D;data \ arrival \ time$</p>
<p>$hold \ slack &#x3D; data \ arrival \ time - data \ required \ time(hold)\<br> &#x3D;data \ arrival \ time -  clk\  arrival \ time - t_{hold} - hold\ uncertainty$</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-18.png"></p>
<p>计算最大工作频率。 考虑建立时间，使 setup slack为0：</p>
<p>$T{clk_1}+ T_{co} + T_{data} + T_{setup} &#x3D;T_{c} + T_{clk2}$</p>
<p>$f_{max} &#x3D; \frac{1}{T_{co} + T_{data} + T_{setup} + T{clk_1} - T_{clk2}}$</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-20.png"></p>
<h2 id="SoC架构"><a href="#SoC架构" class="headerlink" title="SoC架构"></a>SoC架构</h2><h3 id="SoC架构概述"><a href="#SoC架构概述" class="headerlink" title="SoC架构概述"></a>SoC架构概述</h3><p>一个典型的SoC架构如下图：<br><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-21.png"></p>
<p>SoC的同样遵循冯诺依曼架构，分别包括：</p>
<ol>
<li>中央处理器(计算，控制)</li>
<li>存储系统</li>
<li>总线</li>
<li>外设 (I&#x2F;O)</li>
<li>协处理器(可选，用于异构计算)</li>
</ol>
<h3 id="中央处理器CPU"><a href="#中央处理器CPU" class="headerlink" title="中央处理器CPU"></a>中央处理器CPU</h3><p>略</p>
<h3 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h3><p>在SoC（System-on-a-Chip）系统中，总线是用来连接各个组件和模块，实现数据、地址和控制信号的传输。</p>
<p>常见的总线包括ARM公司的AMBA（advanced microcontroller Bus Architecture）, 包括：</p>
<ol>
<li>AHB (Advanced High-performance Bus)</li>
<li>AXI (Advanced eXtensibleInterface)</li>
<li>APB (Advanced Peripheral Bus)</li>
</ol>
<h4 id="APB总线协议"><a href="#APB总线协议" class="headerlink" title="APB总线协议"></a>APB总线协议</h4><p>(待补充)</p>
<h4 id="AHB总线协议"><a href="#AHB总线协议" class="headerlink" title="AHB总线协议"></a>AHB总线协议</h4><p>(待补充)</p>
<h4 id="AXI总线协议"><a href="#AXI总线协议" class="headerlink" title="AXI总线协议"></a>AXI总线协议</h4><p>(待补充)</p>
<h3 id="接口控制模块"><a href="#接口控制模块" class="headerlink" title="接口控制模块"></a>接口控制模块</h3><p>SoC一般包含多种不同的串&#x2F;并接口，常见的有:</p>
<ol>
<li>SPI</li>
<li>UART</li>
<li>USB</li>
<li>PCIe</li>
</ol>
<p>此外还包括：</p>
<ol>
<li>中断控制器(Interrupt Controller, INTC)</li>
<li>实时时钟(Real Time Clock, RTC) 、Timer、Watchdog</li>
<li>功耗管理模块(Power Management Controller, PMC)</li>
</ol>
<p>等功能模块。</p>
<h4 id="串-并行通信接口"><a href="#串-并行通信接口" class="headerlink" title="串&#x2F;并行通信接口"></a>串&#x2F;并行通信接口</h4><h5 id="串行-解串器"><a href="#串行-解串器" class="headerlink" title="串行&#x2F;解串器"></a>串行&#x2F;解串器</h5><h5 id="PCIe-Peripheral-Component-Interconnect-Express"><a href="#PCIe-Peripheral-Component-Interconnect-Express" class="headerlink" title="PCIe (Peripheral Component Interconnect Express)"></a>PCIe (Peripheral Component Interconnect Express)</h5><h5 id="SPI-Serial-Peripheral-Interface"><a href="#SPI-Serial-Peripheral-Interface" class="headerlink" title="SPI (Serial Peripheral Interface)"></a>SPI (Serial Peripheral Interface)</h5><h5 id="UART-Universal-Asynchronous-Receiver-Transmitter"><a href="#UART-Universal-Asynchronous-Receiver-Transmitter" class="headerlink" title="UART (Universal Asynchronous Receiver&#x2F;Transmitter)"></a>UART (Universal Asynchronous Receiver&#x2F;Transmitter)</h5><h5 id="USB-Universal-Serial-Bus"><a href="#USB-Universal-Serial-Bus" class="headerlink" title="USB (Universal Serial Bus)"></a>USB (Universal Serial Bus)</h5><h4 id="中断控制模块"><a href="#中断控制模块" class="headerlink" title="中断控制模块"></a>中断控制模块</h4><p>(待补充)</p>
<h4 id="时钟外设"><a href="#时钟外设" class="headerlink" title="时钟外设"></a>时钟外设</h4><p>(待补充)</p>
<h4 id="功耗管理模块"><a href="#功耗管理模块" class="headerlink" title="功耗管理模块"></a>功耗管理模块</h4><p>(待补充)</p>
<h2 id="Lecture-3-系统级建模"><a href="#Lecture-3-系统级建模" class="headerlink" title="Lecture 3 系统级建模"></a>Lecture 3 系统级建模</h2><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-22.png"></p>
<p>在传统的top-down设计流程中，其余环节都可以比较好的形式化，量化，然而顶层的功能需求定义等工作还是依赖文档和设计者对于文档的理解。</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-23.png"></p>
<p>通过加强系统级建模，可以更好的克服非形式化手段带来的不精确性，有效将需求转化为产品。</p>
<h3 id="系统级建模ELS"><a href="#系统级建模ELS" class="headerlink" title="系统级建模ELS"></a>系统级建模ELS</h3><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-24.png"></p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-25.png"></p>
<p>通过更高层次的建模来提高开发效率</p>
<p>ELS功能：</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-26.png"></p>
<h4 id="ELS设计阶段"><a href="#ELS设计阶段" class="headerlink" title="ELS设计阶段"></a>ELS设计阶段</h4><p>ELS设计分为3个阶段：</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-27.png"></p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-28.png"></p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-29.png"></p>
<h3 id="ELS设计模型"><a href="#ELS设计模型" class="headerlink" title="ELS设计模型"></a>ELS设计模型</h3><h4 id="事物级建模"><a href="#事物级建模" class="headerlink" title="事物级建模"></a>事物级建模</h4><p>事务指模块之间的数据和事件的交互。数据交换可以是一个或多个字，<br>或者是一种数据结构。而诸如同步或者中断等则属于事件的交互<br>•事务级建模的核心概念是在一个系统建模过程中将运算功能和通信功<br>能分开，模块之间的通信通过函数调用来实现</p>
<p>与寄存器传输级模型相比较，事务级建模可以减少事件和信息的处理，<br>所需的程序代码更少，执行速度更快<br>• 根据实际需要提供足够的设计精度，根据描述系统精度的不同，事务<br>级模型可以分为三种：<br>• 没有时序信息的模型<br>• 周期近似的模型<br>• 周期精确的模型</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-30.png"></p>
<h4 id="ELS设计语言"><a href="#ELS设计语言" class="headerlink" title="ELS设计语言"></a>ELS设计语言</h4><p>业界获得较多支持和应用较为广泛的语言是SystemVerilog和SystemC<br>SystemVerilog是在Verilog上的扩展，吸收了C&#x2F;C++中的一些特性，可以实<br>现和C的仿真。由于是在Verilog上的扩展，SystemVerilog的优势在于基于<br>时钟的建模能力和验证能力。但在TLM的抽象上还存在一些不足，如缺少<br>抽象的数据类型<br>• 更为成功的是SystemC，SystemC是OSCI推出的基于C++扩展的描述语言。<br>是一种可以完成电子系统从软件到硬件的全部建模过程的语言。在目前的<br>设计中软件开发占到设计任务的60%-90%，基于C++扩展的语言SystemC<br>比从HDL扩展的语言有更加有利的发展趋势。SystemC完全支持TLM建模，<br>而且OSCI已经提出了TLM建模的标准。而其他语言目前还没有完全支持<br>TLM建模。</p>
<h2 id="Lecture-4-SoC验证"><a href="#Lecture-4-SoC验证" class="headerlink" title="Lecture 4 SoC验证"></a>Lecture 4 SoC验证</h2><p>设计验证(Verification)的目的是确认设计的功能正确性和性能（速度和功耗等）满足设计要求，贯穿于设计的整个过程。</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-31.png"></p>
<p>随着系统复杂的的提高，bug的数量也在提高，而找出bug的代价更大。</p>
<h3 id="SoC验证方法学"><a href="#SoC验证方法学" class="headerlink" title="SoC验证方法学"></a>SoC验证方法学</h3><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-32.png"></p>
<p>根据验证的方式可以分为：</p>
<p>Formal,Simulation,Emulation,Protyping</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-33.png"></p>
<p>从方式来分类可以分解基于仿真的验证和基于形式的验证2大类。</p>
<p>基于仿真的方法需要设置输入向量和预期结果，然后进行结果对比。</p>
<h3 id="事件驱动的仿真-simulation"><a href="#事件驱动的仿真-simulation" class="headerlink" title="事件驱动的仿真 simulation"></a>事件驱动的仿真 simulation</h3><p>时间驱动的仿真，将各个时间节点发生的时间进行归类，然后以特定顺序调用，以此模拟真实的系统。</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-34.png"></p>
<h4 id="代码覆盖率和功能覆盖率"><a href="#代码覆盖率和功能覆盖率" class="headerlink" title="代码覆盖率和功能覆盖率"></a>代码覆盖率和功能覆盖率</h4><p>(参考SV课程中的内容)</p>
<h4 id="仿真simulation和模拟emulation的区别"><a href="#仿真simulation和模拟emulation的区别" class="headerlink" title="仿真simulation和模拟emulation的区别"></a>仿真simulation和模拟emulation的区别</h4><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-35.png"></p>
<p>核心在于emulation采取一套不同的硬件系统来验证功能</p>
<p>Emulation的问题在于成本过高。</p>
<h3 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h3><p>可以达到100%覆盖率<br>仅适用于小尺寸的有限状态系统</p>
<p>对于类似soc这样的复杂系统，其输入空间的组合近似无穷大，如果不用形式验证的方法，很难穷尽所有的输入可能。</p>
<h4 id="形式化验证的分类"><a href="#形式化验证的分类" class="headerlink" title="形式化验证的分类"></a>形式化验证的分类</h4><p>主要分为模型检查和等价性检查。</p>
<p>其中等价性检查又分为LEC(logic equivalence)和SEC(sequential equivalence)</p>
<h4 id="基于AI和深度学习的验证"><a href="#基于AI和深度学习的验证" class="headerlink" title="基于AI和深度学习的验证"></a>基于AI和深度学习的验证</h4><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-36.png"></p>
<h3 id="测试平台搭建"><a href="#测试平台搭建" class="headerlink" title="测试平台搭建"></a>测试平台搭建</h3><h3 id="SoC混合信号验证"><a href="#SoC混合信号验证" class="headerlink" title="SoC混合信号验证"></a>SoC混合信号验证</h3><h2 id="Lecture5-逻辑综合"><a href="#Lecture5-逻辑综合" class="headerlink" title="Lecture5 逻辑综合"></a>Lecture5 逻辑综合</h2><p>gtech: 与工艺无关的门级网表</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-37.png"></p>
<h3 id="逻辑综合要解决的问题"><a href="#逻辑综合要解决的问题" class="headerlink" title="逻辑综合要解决的问题"></a>逻辑综合要解决的问题</h3><p> 单的综合只需要将RTL读入综合软件并elaborate即可得到门级网表，但<br>这并不代表综合真正成功<br>• 对于同步逻辑电路，综合成功表示综合后的电路中，触发器等时序逻辑部<br>件能在正确的时间(时钟沿)得到正确的数据，即满足时序要求，同时需要满<br>足扇出、负载等约束<br>• 触发器正确读取数据的关键<br>• 数据在时钟沿之前稳定足够的时间，即数据不要到达太晚，应满足建立时间(setup<br>time)要求<br>• 数据在时钟沿之后稳定足够的时间，即数据不能到达太早，应满足保持时间(hold<br>time)要求<br>• 时钟沿会在正确的时刻出现，即时钟质量要满足要求<br>• 可简单认为综合主要是为了保证建立时间、保持时间、时钟这几项要求</p>
<h3 id="Synopsys-DC-综合流程"><a href="#Synopsys-DC-综合流程" class="headerlink" title="Synopsys DC 综合流程"></a>Synopsys DC 综合流程</h3><ol>
<li>set library</li>
<li>Read design</li>
<li>Defign environment </li>
<li>Sent design constraints</li>
<li>Select compile strategy</li>
<li>Optimize the design</li>
<li>Analyze and resolve design problems</li>
<li>save design data</li>
</ol>
<h3 id="CCS-模型"><a href="#CCS-模型" class="headerlink" title="CCS 模型"></a>CCS 模型</h3><p>CCS模型即复合电流源模型Composite Current Source，精度可达HSpice的2%以内，但CCS库尺寸比NLDM库大一个数量级。</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-38.png"></p>
<h3 id="无法综合的部分"><a href="#无法综合的部分" class="headerlink" title="无法综合的部分"></a>无法综合的部分</h3><p>类似memory之类的模型无法由逻辑综合直接得到，而是需要专用工具或使用成型IP：</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-39.png"></p>
<h3 id="需要约束的时序路径"><a href="#需要约束的时序路径" class="headerlink" title="需要约束的时序路径"></a>需要约束的时序路径</h3><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-40.png"></p>
<h3 id="电路优化"><a href="#电路优化" class="headerlink" title="电路优化"></a>电路优化</h3><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-41.png"></p>
<h3 id="高层次综合HLS"><a href="#高层次综合HLS" class="headerlink" title="高层次综合HLS"></a>高层次综合HLS</h3><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-42.png"></p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-43.png"></p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-44.png"></p>
<h2 id="Lecture-6-STA"><a href="#Lecture-6-STA" class="headerlink" title="Lecture 6 STA"></a>Lecture 6 STA</h2><h3 id="建立时间和保持时间"><a href="#建立时间和保持时间" class="headerlink" title="建立时间和保持时间"></a>建立时间和保持时间</h3><p>Setup Time – 建立时间，数据在时钟沿之前必须保持稳定的时间长度</p>
<p>Hold Time – 保持时间，数据在时钟沿之后必须保持稳定的时间长度</p>
<h3 id="亚稳态"><a href="#亚稳态" class="headerlink" title="亚稳态"></a>亚稳态</h3><p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-45.png"></p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-46.png"></p>
<h3 id="Negative-hold-time"><a href="#Negative-hold-time" class="headerlink" title="Negative hold time"></a>Negative hold time</h3><p>建立时间总是正的，但保持时间可以为正值、零，甚至负值<br>• 某些触发器可能需要set-reset-enable或者scan-enable功能，或者其它<br>原因，使得触发器第一个传输门前存在部分组合逻辑<br>• 这些额外的组合逻辑会在输入数据D到第一个传输门的路径中引入额<br>外的延迟，此额外的延迟可能使得保持时间为正、零或者负</p>
<p><img src="/2024/02/20/SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-1/image-47.png" alt="alt text"></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>SoC</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture</title>
    <url>/2024/02/16/Computer-Architecture/</url>
    <content><![CDATA[<h1 id="高等计算机体系结构课程笔记"><a href="#高等计算机体系结构课程笔记" class="headerlink" title="高等计算机体系结构课程笔记"></a>高等计算机体系结构课程笔记</h1><h2 id="chapter1-Overview-and-Fundamental"><a href="#chapter1-Overview-and-Fundamental" class="headerlink" title="chapter1 Overview and Fundamental"></a>chapter1 Overview and Fundamental</h2><p>1.什么是计算机体系结构(Computer Architecture)?<br>    CA &#x3D; 指令集+微架构+硬件实现  (不单单是指令集设计)</p>
<p>1.指令集的概念：指令集是规定处理器外在行为的一系列内容的统称，是软件人员和硬件设计师之间的桥梁。同一个指令集体系会有多种硬件实现方式，称为微体系结构(microarchitecture)。</p>
<p>2.指令集的基本要素：<br>    指令集的分类(CISC or RISC)、<br>    内存地址分配（对齐方式、大端、小端）<br>    寻址模式（寄存器、立即数、etc）<br>    操作类型和码长<br>    操作内容（控制指令、存储指令、运算指令）<br>    控制流（jump、branch、return）、<br>    编码方式 (定长(MIPS)or变长(X86)) </p>
<p>3.CISC和RISC：</p>
<pre><code>CISC:(Complex Instruction Set Computer)复杂指令集计算机   代表：x86
RISC：(Reduced Instruction Set Computer)精简指令集计算机  代表：MIPS,ARM,RISCV
</code></pre>
<p>4:功耗墙与暗硅。功耗墙：芯片在工作时，如果功率超过某个临界值，就会使热量积累速度超过通过技术手段进行冷却的速度(风扇或水冷等),从而使局部温度不断升高，对芯片本身产生故障甚至永久损害。因此需要将芯片设计为在某个特定功率以下进行工作，即功耗墙。<br>暗硅：由于功耗墙的存在，一块芯片运行时，其上的所有晶体管并不在同一时间全部处于工作状态，这部分没有在工作的晶体管被称为暗硅。由于功耗墙和暗硅的存在，单纯依靠增大芯片面积或进行堆叠来提高芯片性能的做法是行不通的，必须同时考虑芯片的能效(energy efficiency)。<br>PS:集成电路的动态功耗正比于电压的平方x电容x频率。功耗墙的存在同时决定了单纯依靠提升频率来提升电路性能的做法是有极限的。</p>
<p>5:Thermal Design Power(TDP):热设计功耗。TDP 是一个指标，用于表示最大热输出，即一个芯片在运行最大负载时所产生的最大热量。这个值对于散热系统的设计至关重要，因为它帮助确保计算机的冷却系统能够有效地处理和散发这些热量，从而防止过热。</p>
<p>6.Dennard Scaling:随着晶体管尺寸缩小，它们的电压会等比例减小，在保持功耗密度不变的情况下，晶体管可以工作在更高的频率，从而提升了算力。然而随着功耗墙的出现，Dennard Scaling面临着终结。</p>
<p>7.计算机设计的2大原则：1.利用并行2.利用局部性原理</p>
<p>并行的相关术语：ILP（指令级并行）、DLP（数据级并行）、TLP（线程级并行）<br>SISD\SIMD\MISD\MIMD</p>
<p>局部性原理：局部性原理基于这样一个观察：程序在执行时倾向于从相对集中的内存位置重复访问数据和指令。局部性主要分为两种类型：</p>
<p>时间局部性（Temporal Locality）：这种类型的局部性指的是如果一个数据项被访问，那么它在不久的将来很可能会被再次访问。例如，程序中的循环可能多次访问相同的变量或指令。</p>
<p>空间局部性（Spatial Locality）：空间局部性指的是如果一个数据项被访问，那么它附近的数据项很快也可能被访问。这通常是由于数据结构的存储方式（如数组）或程序的顺序执行特性。</p>
<p>8.Amdahl’s Law: <img src="/2024/02/16/Computer-Architecture/image-2.png" alt="Alt text"><br>理解：某一部分的速度提升对总体速率提升的影响，需要考虑其在整体中占据的比例。<br>例：<br><img src="/2024/02/16/Computer-Architecture/image-3.png" alt="Alt text"><br><img src="/2024/02/16/Computer-Architecture/image-4.png" alt="Alt text"><br><img src="/2024/02/16/Computer-Architecture/image-5.png" alt="Alt text"></p>
<p>9.CPU Time和CPI计算：<br><img src="/2024/02/16/Computer-Architecture/image-6.png" alt="Alt text"></p>
<p>上式中，Instruction count由算法决定,Cycles per Instruction由体系结构决定，CLock cycle time由工艺决定。</p>
<p>CPI：clock cycles per instruction:<img src="/2024/02/16/Computer-Architecture/image-7.png" alt="Alt text"></p>
<h2 id="Chapter2-Memory-Hierarchy"><a href="#Chapter2-Memory-Hierarchy" class="headerlink" title="Chapter2 Memory Hierarchy"></a>Chapter2 Memory Hierarchy</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>为什么需要Memory Hierarchy?  <ol>
<li>存储墙的存在，运算单元的速度远远超过存储单元的速度（存储的发展主要是越来越大的容量或带宽，但速度的提升有限）。 导致计算机的性能瓶颈主要在于数据的搬运和存取，而非计算的速度。<br> <img src="/2024/02/16/Computer-Architecture/image-9.png" alt="Alt text"></li>
<li>同时高速存储(register、SRAM)的制造价格远远高于普通的低速存储(DRAM,FLASH),导致从成本的角度，无法做到在整个计算机系统中全部使用昂贵的高速存储。<br> <img src="/2024/02/16/Computer-Architecture/image-8.png" alt="Alt text"></li>
<li>但是，从程序运行的角度讲，我们总是希望能够用以足够大的，乃至近乎无限的存储空间。  </li>
<li>因为局部性原理的存在，使Memory Hierarchy成为可能。</li>
</ol>
</li>
</ol>
<p>2.什么是Memory Hierarchy?<br>    Memory hierarchy”（内存层次结构）是指一种组织和管理计算机内存系统的方式，它将不同类型的存储按照速度、成本和容量进行分层。所有的内存地址空间构建在一个最大的，同时也是最慢的内存结构上，而每一级的更快、更小的内存构成上一级的一个子集。</p>
<p>3.Cache的概念。<br>   缓存（Cache）是计算机体系结构中的一个关键组件，用于存储临时数据，以便快速访问。它位于处理器和主内存之间，旨在减少处理器访问主内存所需的平均时间。<br>   <strong>速度</strong>：缓存比主内存快得多，但比处理器内部的寄存器慢。<br>    <strong>大小</strong>：一般而言，缓存比主内存小得多，因此只能存储有限的数据。<br>    <strong>临时存储</strong>：缓存存储最近或最频繁使用的数据，以便快速访问。<br>    <strong>透明性</strong>：对于程序和用户来说，缓存的存在和操作通常是透明的。  </p>
<h3 id="Cache的原理及设计原则"><a href="#Cache的原理及设计原则" class="headerlink" title="Cache的原理及设计原则"></a>Cache的原理及设计原则</h3><ol>
<li><p>原理：本质上讲，Cache能够起效还是利用了程序的局部性原理。<br> 时间局部性：如果一个数据项最近被访问过，那么它在不久的将来可能会被再次访问。<br> 空间局部性：如果一个数据项被访问，那么它附近的数据项不久后也可能被访问。</p>
</li>
<li><p>Cache的设计主要需要考虑以下因素：  </p>
<ol>
<li>数据的摆放：什么样的数据可以从内存中放入Cache，以及按照什么样的规则摆放？ （<strong>全相联、直接映射、多路组相联</strong>）   </li>
<li>数据的寻找：数据摆放之后，如何寻找到想要的数据？（<strong>寻址策略，cache miss,hit</strong>）      </li>
<li>如何进行数据块的更换？（<strong>FIFO,LRU</strong>）  </li>
<li>对cache进行写操作时，采用何种写策略？(<strong>Write through、Write Back</strong>)</li>
</ol>
</li>
</ol>
<h4 id="数据块的摆放-Block-Placement"><a href="#数据块的摆放-Block-Placement" class="headerlink" title="数据块的摆放(Block Placement)"></a>数据块的摆放(Block Placement)</h4><p><img src="/2024/02/16/Computer-Architecture/image-10.png" alt="Alt text"></p>
<p><strong>全相联</strong>：任何一个数据块可以放在Cache的任何位置。<br>    优点：可以充分利用Cache的空间。缺点：数据寻址的开销增大  （一般不用这个）</p>
<p><strong>直接映射</strong>：数据块经过某种映射规则（通常是简单哈希，如编号 mod 8）后放入相应编号的Block.  (mod 几取决于cache中的block个数)<br>    优点：寻址方便  缺点，容易造成空间浪费，导致cache miss和频繁的数据换入换出</p>
<p><strong>多路组相联</strong>：是以上二者的折中，首先将cache中的block分路，一个数据块经过映射后，可以任何一个路的对应位置。（一个块有n个位置可放称作n路组相连，注意区分<strong>路</strong>和<strong>组</strong>）</p>
<h4 id="数据块的寻址"><a href="#数据块的寻址" class="headerlink" title="数据块的寻址"></a>数据块的寻址</h4><p>不同的摆放策略带来不同的寻址（或地址编码）方式：<br>以多路组相联为例：<br> <img src="/2024/02/16/Computer-Architecture/image-11.png" alt="Alt text"></p>
<p> 不同数据的作用： offset的作用是在block内进行索引，首先需要明确的是，计算机系统中的地址索引通常以字节Byte为单位，因此，如果一个Block的容量大于1个字节（通常是16B即4Words），则需要进行bolck内的偏移(offset)。<br> index的大小等于set中block的个数。(如每个set 拥有256个blocks，则index为8位)。<br> Tag作为地址的剩余位，一起写入cache中，用于作为标签比较，Tag一致则说明cache命中。</p>
<p> <img src="/2024/02/16/Computer-Architecture/image-12.png" alt="Alt text"></p>
<p>上述多路组相联的寻址策略，是直接根据index取出所有way中的对应数据，然后通过tag比对丢弃剩余的数据，只保留所需要的数据。<br>对于直接映射，地址编码中的offset用于块内的字索引。<br>对于全相联，地址编码中不存在index。  </p>
<p>例题：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-13.png" alt="Alt text"></p>
<p>解：4路,一共1KB,每路256B，缓存行32B,行数为256&#x2F;32 &#x3D; 8，index为3，offset为5，tag4位。</p>
<p><strong>（考试必考，为数不多可以出计算题的地方）</strong></p>
<h4 id="数据块替换策略"><a href="#数据块替换策略" class="headerlink" title="数据块替换策略"></a>数据块替换策略</h4><p>分情况讨论：  </p>
<ol>
<li>处理器在Cache中拿到了想要的数据(Tag比对正确，Valid有效)，称为Cache hit,皆大欢喜。</li>
<li>Tag比对失败，或Valid无效，需要对Cache进行Block的替换，称为Cache miss。<br> 对于直接映射的策略，则直接进行一次映射然后进行替换。<br> 对于全相联或多路组相联，则需要考虑具体替换哪一路中的数据。 具体策略可以有：完全随机，LRU(Least recently used),FIFO(First in First out)。</li>
</ol>
<h4 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h4><p>核心矛盾：对cache中的数据进行写操作，导致cache和主存中的数据产生不一致，此时有2种选择：</p>
<ol>
<li>立即更新主存中的数据(称为写穿透，write through)</li>
<li>额外增加一个dirty位，当一个被改写的数据块被从cache换出时，再将主存中的数据进行更新,称为(write back)</li>
</ol>
<p>一般都是用write back,因为write through开销太大。</p>
<p>一种解决写主存耗时过长的策略： write buffer。<br><img src="/2024/02/16/Computer-Architecture/image-14.png" alt="Alt text"></p>
<p>把要写的数据丢给buffer让它写，然后接着干自己的活。（write back 和write through都能用）</p>
<p>当写miss发生时，write through有2中选择，直接改写主存中的数据，而不把数据搬入cache,或者既写又搬。对应write back,一般而言需要先把数据搬入主存。</p>
<h4 id="Cache-性能对CPI的影响"><a href="#Cache-性能对CPI的影响" class="headerlink" title="Cache 性能对CPI的影响"></a>Cache 性能对CPI的影响</h4><p><img src="/2024/02/16/Computer-Architecture/image-15.png" alt="Alt text"></p>
<p>例题：<br><img src="/2024/02/16/Computer-Architecture/image-16.png" alt="Alt text"></p>
<p>解：一开始的CPI为1，每条指令耗时1个周期，4Ghz的处理器，每个周期时长为0.25ns，故每条指令的平均耗时为0.25ns。2%的Miss rate,每条指令的平均耗时变为：（$0.02\times 100ns+ 0.25ns &#x3D; 2.25ns$ ）</p>
<p>增加2级cache,每条指令的平均耗时变为：($0.005\times 100ns + 0.02\times 5 ns +  0.25ns &#x3D; 0.85ns$)</p>
<p>加速比： $2.25&#x2F;0.85 &#x3D; 2.6$</p>
<p>或从CPI角度进行计算：一级cache的失效代价为：$100ns&#x2F;0.25ns &#x3D; 400$个clock cycle,<br>因此平均CPI为：$1+0.02\times 400 &#x3D; 9$,</p>
<p>增加2级缓存后，cache2的访问或miss需要：<br>$5ns&#x2F;0.25ns &#x3D; 20$个clock cycle,<br> CPI为：$1+0.02\times 20 + 0.005\times 400&#x3D; 3.4$</p>
<p> 加速比：$9&#x2F;3.4 &#x3D; 2.6$</p>
<h4 id="影响cache性能的4C因素"><a href="#影响cache性能的4C因素" class="headerlink" title="影响cache性能的4C因素"></a>影响cache性能的4C因素</h4><ol>
<li><p>强制性缺失（Compulsory Misses）</p>
<ol>
<li>这些缺失发生在第一次访问数据时，因为这时数据还没有被加载到缓存中。</li>
<li>强制性缺失也被称为“冷启动缺失”或“首次访问缺失”。</li>
<li>减少强制性缺失的方法有限，因为它们是程序运行的必然结果。预取策略（将数据提前加载到缓存中）可以在一定程度上帮助减少这类缺失。</li>
</ol>
</li>
<li><p>容量缺失（Capacity Misses）</p>
<ol>
<li>当缓存的容量不足以存储所有需要的数据时，就会发生容量缺失。</li>
<li>这种缺失表明缓存无法容纳程序工作集（即同时活跃的数据集合）。</li>
<li>增加缓存大小是减少容量缺失的直接方法，但这也会增加成本和可能增加访问延迟。</li>
</ol>
</li>
<li><p>冲突缺失（Conflict Misses）</p>
<ol>
<li>冲突缺失发生在缓存可以容纳更多数据，但由于缓存映射策略（如直接映射或组相联映射）的限2制，不同的数据块争用相同的缓存位置。</li>
<li>在直接映射缓存中，这种情况最为常见。</li>
<li>通过使用更复杂的映射策略（如全相联或更高程度的组相联）可以减少冲突缺失，但这可能增加硬件复杂性和成本。</li>
</ol>
</li>
<li><p>一致性问题（Coherency）</p>
<ol>
<li>在多核或多处理器系统中，维持缓存一致性是一个重要问题。</li>
<li>缓存一致性问题是指当多个缓存副本存储相同数据时，确保所有副本在任何时刻都是一致的。</li>
<li>缓存一致性问题不直接导致缺失，但它会影响系统的整体性能和正确性。</li>
<li>解决方案包括缓存一致性协议，如MESI（修改、独占、共享、无效）协议。(第5章)</li>
</ol>
</li>
</ol>
<h3 id="6种基础的Cache性能优化"><a href="#6种基础的Cache性能优化" class="headerlink" title="6种基础的Cache性能优化"></a>6种基础的Cache性能优化</h3><p>考虑某种优化策略对Cache性能带来的影响，主要分为以下4个维度：  </p>
<ol>
<li>访存(命中)时间(hit time)</li>
<li>未命中率(Miss rate)</li>
<li>未命中的代价(Miss Penalty)</li>
<li>硬件设计复杂度或成本</li>
</ol>
<table>
<thead>
<tr>
<th>Methods</th>
<th>hit time</th>
<th>Miss rate</th>
<th>Miss penalty</th>
<th>Hardware Complexity or Cost</th>
</tr>
</thead>
<tbody><tr>
<td>Larger Block Size</td>
<td>$\uparrow$</td>
<td>$\downarrow$(主要是降低了Copullsory Miss)</td>
<td>$\uparrow$</td>
<td>几乎不变</td>
</tr>
<tr>
<td>Larger Capacity</td>
<td>$\uparrow$</td>
<td>$\downarrow$(主要是降低了Capacity Miss)</td>
<td>几乎不变</td>
<td>$\uparrow$</td>
</tr>
<tr>
<td>High Associativity</td>
<td>$\uparrow$</td>
<td>$\downarrow$(主要是降低了Conflict Miss)</td>
<td>几乎不变</td>
<td>$\uparrow$</td>
</tr>
<tr>
<td>More Cache Levels</td>
<td>不变</td>
<td>对于各级来说保持不变</td>
<td>$\downarrow$</td>
<td>$\uparrow$</td>
</tr>
<tr>
<td>Read misses over Write</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Address Translation(虚拟内存和TLB技术)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="10种进阶优化策略"><a href="#10种进阶优化策略" class="headerlink" title="10种进阶优化策略"></a>10种进阶优化策略</h3><table>
<thead>
<tr>
<th>Methods</th>
<th>hit time</th>
<th>Miss rate</th>
<th>Miss penalty</th>
<th>Hardware Complexity or Cost</th>
</tr>
</thead>
<tbody><tr>
<td>Small and simple L1 Cache</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Way Prediction</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Piplined Cache Accesses</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Non-blocking-Cache</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Multibanked Caches</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Critical word first and early restart</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Merging write buffer</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Compiler optimization</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hardware Prefetching</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Compiler-controled prefetching</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ol>
<li><p><strong>什么是虚拟存储器，为什么要有虚拟存储器？</strong><br> 在实际使用计算机时，一个进程(或程序)可能需要的地址空间过大，使得整个内存都无法装下。或者对于多个进程，每个进程都需要自己的地址空间，超过了内存空间的总量。因此需要虚拟内存技术。<br> 虚拟内存（Virtual Memory）是计算机系统内存管理的一项关键技术。它使得操作系统通过将物理存储器和内存一同抽象为虚拟内存，从而为软件提供比实际物理内存更大的内存空间。(可以理解为，将内存作为硬盘的cache,构成整个虚拟内存空间)虚拟内存的实现方法：MMU(Memory Management Unit)+OS(Operation System)</p>
</li>
<li><p><strong>虚拟内存的优点：</strong></p>
<ol>
<li>更大的内存空间：程序可以使用比实际物理内存更多的内存。</li>
<li>内存保护：每个程序有自己的虚拟地址空间，避免了程序间的内存冲突。</li>
<li>数据共享和内存映射文件：程序可以更容易地共享数据，并将文件直接映射到内存中，以提高数据访问速度。</li>
</ol>
</li>
<li><p><strong>虚拟地址和物理地址</strong>：虚拟地址（virtual address）是程序员看到的虚拟地址空间。物理地址（physical address）是主存或硬盘上的实际地址。虚拟内存为每个程序提供了一种看似独占的内存抽象，称为虚拟地址空间。这意味着每个程序都认为自己拥有连续的、完整的内存空间，而实际上，这些空间可能是非连续的，甚至不完全存在于物理内存中。<br><img src="/2024/02/16/Computer-Architecture/image-17.png" alt="Alt text"></p>
</li>
</ol>
<h4 id="虚拟地址和物理地址的转换"><a href="#虚拟地址和物理地址的转换" class="headerlink" title="虚拟地址和物理地址的转换"></a>虚拟地址和物理地址的转换</h4><ol>
<li><p>页（Paging）：虚拟内存通常以“页”的形式组织，每页是一个固定大小的内存块（例如4K）。虚拟地址空间被分割成多个这样的页，它们可以独立地映射到物理内存中的页，或者在需要时存储到磁盘上。</p>
</li>
<li><p>页表（Page Table）：操作系统维护一个页表来追踪虚拟页和物理页之间的映射关系。当程序访问其虚拟内存中的地址时，页表用来查找相应的物理内存地址。</p>
</li>
</ol>
<p><img src="/2024/02/16/Computer-Architecture/image-18.png" alt="Alt text"><br><img src="/2024/02/16/Computer-Architecture/image-19.png" alt="Alt text"><br>3个关键问题：</p>
<ol>
<li><p>页表放在哪？<br> 放在内存中，通过虚拟地址的virtual page number,进行查表，得到physical page number。</p>
</li>
<li><p>页表放在内存中，怎么找到它？<br> CPU中专门有一个page table register,记录了页表的首地址(相当于一个指针)。</p>
</li>
<li><p>页表如何工作？<br> 每个进程有自己独立的页表（意味着独立的地址空间）、PC以及寄存器的值。存储在内存中的不同位置。当OS进行进程切换时，CPU读入对应进程的页表寄存器，PC以及其它状态寄存器，该进程便转为Active 状态。</p>
</li>
</ol>
<h4 id="缺页中断（Page-Fault）"><a href="#缺页中断（Page-Fault）" class="headerlink" title="缺页中断（Page Fault）"></a>缺页中断（Page Fault）</h4><p>当程序访问的虚拟内存页不在物理内存中时，会发生缺页中断。操作系统将处理这种中断，从磁盘中加载所需的页到物理内存，并更新页表。</p>
<p>由于磁盘的访问时间很长，此时操作系统会进行进程切换。</p>
<p>缺页后的替换策略，通常使用LRU算法。一个由OS实现的伪LRU算法：<br><img src="/2024/02/16/Computer-Architecture/image-20.png" alt="Alt text"></p>
<h4 id="快表TLB-Translation-Look-aside-Buffer"><a href="#快表TLB-Translation-Look-aside-Buffer" class="headerlink" title="快表TLB(Translation Look-aside Buffer)"></a>快表TLB(Translation Look-aside Buffer)</h4><ol>
<li><p><strong>为什么要有TLB？</strong><br>在虚拟内存的背景下，CPU拿到一个在内存中的数据，需要经过以下阶段： </p>
<ol>
<li>访问页表，根据虚拟地址的virtual page number,进行查表，得到physical page number。（相当于访问了一次，内存）。</li>
<li>根据Physical page number，和virtual address中的page offset结合，得到实际的物理地址，根据这个物理地址，再次访问内存。</li>
</ol>
<p>这个过程的问题在于，每当想要拿到一个在内存中的数据，需要访问2次内存。能否加速这个过程？</p>
</li>
<li><p><strong>TLB的原理</strong><br> TLB的原理就一句话，将部分使用频繁的页表表项建立为一个cache。TLB是一个小型、高速的缓存，存储了最近使用的一小部分虚拟地址到物理地址的映射关系。</p>
<p> <img src="/2024/02/16/Computer-Architecture/image-21.png" alt="Alt text"></p>
<p> <strong>注意：不是说TLB放在cache里，而是TLB自己就是一个cache。是专门针对页表建立的cache。</strong></p>
</li>
<li><p><strong>TLB Miss</strong><br> 只要是cache，就会有cache miss。TLB miss 的情况和cache miss类似，但是需要考虑页表中也不存在对应页的情况(相当于2级缓存全部miss)（缺页中断）</p>
</li>
</ol>
<h4 id="TLB和cache的交互"><a href="#TLB和cache的交互" class="headerlink" title="TLB和cache的交互"></a>TLB和cache的交互</h4><p>在使用了虚拟内存和TLB后，引入一个新的问题，TLB和cache之间如何交互？<br>具体来讲，CPU通过一个地址访问cache时，这个地址是虚拟地址，还是物理地址？</p>
<ol>
<li><p>PIPT（Physically Indexed, Physically Tagged）<br><img src="/2024/02/16/Computer-Architecture/image-22.png" alt="Alt text"></p>
<ol>
<li>在这种方式中，缓存使用物理地址进行索引和标记。  </li>
<li>这要求在访问缓存之前，必须先通过TLB将虚拟地址翻译成物理地址。</li>
<li>物理寻址的优势在于它避免了缓存别名问题（即多个虚拟地址映射到同一物理地址的情况），但它增加了访问缓存之前的延迟。<br>优点是简单，缺点是相当于访问了2次cache。</li>
</ol>
</li>
<li><p>VIVT（Virtually Indexed, Virtually Tagged）</p>
<ol>
<li>在这种方式中，缓存使用虚拟地址进行索引和标记。</li>
<li>这允许直接使用虚拟地址访问缓存，无需等待TLB翻译，从而减少了访问延迟。</li>
<li>但虚拟寻址带来了缓存一致性的问题，因为不同的虚拟地址可能映射到相同的物理地址。</li>
</ol>
</li>
<li><p>VIPT（Virtually Indexed, Physically Tagged）</p>
<ol>
<li><p>索引（Indexing）：缓存使用虚拟地址进行索引。这意味着在访问缓存以确定一个缓存行是否存在时，不需要等待虚拟地址到物理地址的转换。这样可以减少访问缓存的延迟，因为索引操作可以并行于TLB的地址翻译。</p>
</li>
<li><p>标记（Tagging）：缓存使用物理地址的标记。这意味着一旦确定了缓存行的位置，缓存使用物理地址的标签来确定是否命中。这样做的好处是维护缓存一致性和避免缓存别名问题，因为物理地址是全局唯一的。</p>
</li>
<li><p>地址转换：在VIPT缓存中，地址转换（即从虚拟地址到物理地址的转换）仍然需要进行，但其时间可以与访问缓存的索引过程重叠。</p>
</li>
</ol>
</li>
<li><p>PIVT（Physically Indexed, Virtually Tagged）<br> 理论上存在，但没啥用</p>
</li>
</ol>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>首先考虑一个页表大小的问题：假设有32位虚拟地址，每页大小为4KB, 每个页表表项(PTE, Page Table Entry)大小为4B。</p>
<p>32位地址能够编码的页数为： $2^{32}&#x2F;4K &#x3D; 2^{20}$<br>而每个页表表项大小为4B,为了存储所有这些表项，页表的大小为：$2^{20}\times4B &#x3D; 4MB$<br>也就是说，仅存储页表，就需要消耗主存中4MB中的空间。</p>
<p>如果是64位，这个数字变成 $2^{54}MB&#x3D;2^{44}GB$远远超过了内存的全部大小！！</p>
<p>因此需要多级页表。将上述4MB的页表分为1K个小页表。每个小页表大小为4KB，对应1000个页。将每个小页表看作一个需要寻址的地址。对这1k个小页表再建立一个页表，则新的页表有1000个表项，每个表项的索引长度为10。加上标签后表项大小变为4B，这个新的“页表的页表”的大小为1000*4B&#x3D;4KB，这样，只需要将这个二级页表放入主存，然后将部分一级页表(被分割的小页表)也放入主存，就能减少主存中的页表占用大小。</p>
<p>二级页表之所以能减少对主存空间的占用，主要是因为并不是所有的页表都需要常驻在主存中。这种设计允许操作系统按需加载和卸载页表，从而有效地管理大型虚拟地址空间，而不必为每个可能的虚拟地址都保留固定的物理内存空间。</p>
<h2 id="Chapter-3-指令级并行及其扩展"><a href="#Chapter-3-指令级并行及其扩展" class="headerlink" title="Chapter 3 指令级并行及其扩展"></a>Chapter 3 指令级并行及其扩展</h2><p>指令级并行的实现原理：流水线技术(Piplining)</p>
<p>并行的问题：三种Hazard:</p>
<ol>
<li><p><strong>结构冲突（Structural Hazards）</strong></p>
<ol>
<li>定义：当硬件资源不足以支持所有流水线阶段同时进行时，就会发生结构冲突。</li>
<li>举例：如果只有一个内存单元，但在同一时刻，流水线中的一个阶段需要读取指令，而另一个阶段需要读写数据，这就会导致结构冲突。</li>
<li>解决办法：增加资源（如多个内存单元、专用指令和数据缓存等），或者在设计时对资源进行时间复用。</li>
<li></li>
</ol>
</li>
<li><p><strong>数据冲突（Data Hazards）</strong></p>
<ol>
<li>定义：当流水线中的指令依赖于前一条或多条指令的结果时，就会发生数据冲突。</li>
<li>类型：<br> RAW（Read After Write）：后续指令需要读取前一条指令写入的数据。<br> WAR（Write After Read）：写入操作与前面的读取操作冲突。<br> WAW（Write After Write）：两条指令写入同一位置。  </li>
<li>解决办法：数据前递（Data Forwarding）来绕过这些冲突，指令重排（Instruction Reordering），或者在必要时暂停（Stalling）流水线。</li>
</ol>
</li>
<li><p><strong>控制冲突（Control Hazards）</strong> </p>
<ol>
<li>定义：当流水线中的指令修改了程序的控制流（如跳转和分支）时，就会发生控制冲突。</li>
<li>原因：由于流水线中后续的指令已经开始执行，但分支指令的结果尚未确定，因此不清楚这些指令是否应该继续。</li>
<li>解决办法：分支预测（Branch Prediction）来猜测分支的结果，延迟槽（Delay Slot）来填充分支决定之前的空闲周期，或者在分支决策确定前暂停流水线。</li>
</ol>
</li>
</ol>
<h3 id="三种data-hazard"><a href="#三种data-hazard" class="headerlink" title="三种data hazard:"></a>三种data hazard:</h3><h4 id="RAW-read-after-write"><a href="#RAW-read-after-write" class="headerlink" title="RAW(read after write)"></a>RAW(read after write)</h4><p><img src="/2024/02/16/Computer-Architecture/image-24.png" alt="Alt text"></p>
<p>写后读，第一条指令在第五个cycle才能写回结果，而第二条指令在第3个cycle就读了，产生stall.</p>
<p>RAW是真相关，只能通过添加bypassing改善或stall。</p>
<h4 id="WAR（读后写）"><a href="#WAR（读后写）" class="headerlink" title="WAR（读后写）"></a>WAR（读后写）</h4><p><img src="/2024/02/16/Computer-Architecture/image-25.png" alt="Alt text"></p>
<p>其实不影响，只是名字重了，所以也叫名相关(name dependent)，或者反相关，名相关的唯一问题在于，编译器进行指令重排的时候会产生问题，因此需要进行寄存器的重命名。</p>
<h4 id="WAW（写后写）"><a href="#WAW（写后写）" class="headerlink" title="WAW（写后写）"></a>WAW（写后写）</h4><p>同理，也是一种名称相关，可以通过寄存器重命名解决。</p>
<h4 id="解决真相关：bypassing和-forwarding"><a href="#解决真相关：bypassing和-forwarding" class="headerlink" title="解决真相关：bypassing和 forwarding"></a>解决真相关：bypassing和 forwarding</h4><p><img src="/2024/02/16/Computer-Architecture/image-26.png" alt="Alt text"></p>
<p>通过前递解决了一般的计算指令的RAW</p>
<p>对应load类指令的写后读，则还需要1周期的stall:<br><img src="/2024/02/16/Computer-Architecture/image-27.png" alt="Alt text"></p>
<p>增加相关单元后的流水线：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-29.png" alt="Alt text"></p>
<p>forwarding 单元的原理：通过比较MEM阶段和wb阶段的目的寄存器以及id阶段的源寄存器判断是否需要进行前递。</p>
<p>Hazard detection 单元主要负责检查是否存在ld,alu类型的RAW,这种类型的hazard需要stall流水线一个周期。</p>
<h3 id="Control-Hazard"><a href="#Control-Hazard" class="headerlink" title="Control Hazard"></a>Control Hazard</h3><p>1.control Hazard产生的原因：PC总是按顺序取指令，而分支条件跳转指令要到EX阶段才能判断具体要取的指令，此时已经取了新的指令进来，而新取的指令可能是错的。</p>
<p>无任何硬件优化下，每次分支产生3个cycle的penalty:<br><img src="/2024/02/16/Computer-Architecture/image-33.png" alt="Alt text"><br>解决思路：</p>
<ol>
<li><p>直接暂停流水线：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-30.png" alt="Alt text"></p>
<p>由于需要译码之后才能知道这是一条分支指令，因此还是多取了1条指令。</p>
</li>
<li><p>predict-not-taken<br> <img src="/2024/02/16/Computer-Architecture/image-31.png" alt="Alt text"></p>
<p> 每次都假设不发生跳转，如果猜对了，则不会有stall,猜错了则冲刷流水线，取相应的指令。猜测了的开销和每次停顿是一样的。</p>
<p> <img src="/2024/02/16/Computer-Architecture/image-32.png" alt="Alt text"></p>
<p> 在ID阶段添加一些硬件，使得提前一个周期得到分支结果和目标的PC值。(这样就只用冲刷1条指令，就是上面表格的结果。)</p>
</li>
</ol>
<h3 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h3><ol>
<li><p>为什么需要分支预测？已经分支预测为什么有效？</p>
<ol>
<li>对于更深的流水线，分支指令对性能的影响增大。而现代的面向对象编程(Object-oriented Programming)中，存在大量分支场景。</li>
<li>分支预测能够工作的原因：程序的运行总是有某种规律，使得分支的发生与否能够被预测（时间上的局部性原理）。指令序列总是不可避免的带有人类思维的痕迹，因此是可预测的。</li>
</ol>
</li>
<li><p>分支预测预测什么？<br> <strong>分支跳转的方向</strong>(taken or not taken),<strong>目标PC的地址</strong>(address)。</p>
</li>
</ol>
<h3 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h3><h4 id="BTB（Branch-Target-Buffer）-和BHT（Branch-History-Table）"><a href="#BTB（Branch-Target-Buffer）-和BHT（Branch-History-Table）" class="headerlink" title="BTB（Branch Target Buffer） 和BHT（Branch History Table）:"></a>BTB（Branch Target Buffer） 和BHT（Branch History Table）:</h4><p><img src="/2024/02/16/Computer-Architecture/image-34.png" alt="Alt text"></p>
<p>BHT：每条不同的PC指令映射为BHT中的一个条目，记录了该条指令跳转还是不跳转。通过branch指令的历史行为(taken or not taken)，来预测指令本次是否跳转。</p>
<p>BTB：BHT只负责预测指令发生与否，而BTB存储了指令的目标地址。这样，如果BHT预测指令跳转，BTB就提供相应的PC地址，从而实现快速的指令切换。<br><img src="/2024/02/16/Computer-Architecture/image-40.png" alt="Alt text"><br>BTB的问题：只记录了PC值，还是要走一遍取值，译码，执行的过程。</p>
<p>一种改进策略：<br><img src="/2024/02/16/Computer-Architecture/image-41.png" alt="Alt text"></p>
<p>不讲武德，直接把指令取好。不是记录PC的值，而是记录指令本身，这样如果BHT预测发生跳转，BTB直接可以拿出相应的指令，跳过了IF阶段。</p>
<h4 id="一位分支预测的缺点："><a href="#一位分支预测的缺点：" class="headerlink" title="一位分支预测的缺点："></a>一位分支预测的缺点：</h4><p><img src="/2024/02/16/Computer-Architecture/image-36.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;++<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">        loop...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑这样的一个两层循环。一开始（j&#x3D;(0,n-1)），内层循环每次都taken，外层循环每次都not taken，当内层循环结束时(j&#x3D;n)，会执行一次外层循环，此时实际的执行效果变为：内层循环not taken,外层循环taken。而根据BHT的历史记录，会连续预测错误2次分支指令，造成性能损失。</p>
<h4 id="改进：2位分支预测"><a href="#改进：2位分支预测" class="headerlink" title="改进：2位分支预测"></a>改进：2位分支预测</h4><p><img src="/2024/02/16/Computer-Architecture/image-37.png" alt="Alt text"></p>
<p><strong>2位分支预测的核心思路</strong>：通过2位比特编码，得到四个预测状态（taken,weak taken,weak not taken, not taken）。同样考虑上面的那个例子：<br>当进行一遍内层循环时，由于内层循环每次都taken,会被记录为(taken),外层循环由于只进行了一次，所以被记录为(weak not taken)，这样，当内外循环交替时，只有内层循环的预测出现错误，而外层循环能正确预测。</p>
<h4 id="高级预测方法：Correlating-Branch-Predictor（相关分支预测器）"><a href="#高级预测方法：Correlating-Branch-Predictor（相关分支预测器）" class="headerlink" title="高级预测方法：Correlating Branch Predictor（相关分支预测器）"></a>高级预测方法：Correlating Branch Predictor（相关分支预测器）</h4><p><strong>核心思路：</strong>：不止关心本条分支指令的历史，而是关心全局的（或其它与本条指令相关的）分支指令的历史，从而实现更好的预测。（从$y_{n+1} &#x3D; f(y_{n})$变为：$y_{n+1}^{(1)} &#x3D; f(y_{n}^{(1)},y_{n}^{(2)},y_{n}^{(3)},…,y_{n}^{(m)})$）</p>
<p>实现方法：  (m,n)预测：用前m条指令和n位的状态来预测本次分支。<br>举例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-38.png" alt="Alt text"></p>
<ol>
<li>(1,1)相当于一个BHT,没啥好说的。</li>
<li>(m,1)相当于记录下m条指令的历史状态，对应一个1位的预测器。</li>
<li>(m,2)每个m位预测历史对应一个n位的编码，通过对n位编码进行某种解释，得到跳转与否的预测。<br><img src="/2024/02/16/Computer-Architecture/image-39.png" alt="Alt text"></li>
</ol>
<h4 id="Tournament-Predictor-（锦标赛预测器）"><a href="#Tournament-Predictor-（锦标赛预测器）" class="headerlink" title="Tournament Predictor （锦标赛预测器）"></a>Tournament Predictor （锦标赛预测器）</h4><p><strong>核心思路：</strong> 养蛊，让几种不同的预测方法自己内卷，哪个效果好就用哪个。</p>
<h3 id="Software-Scheduling-for-Exposing-ILP（软件调度的ILP）"><a href="#Software-Scheduling-for-Exposing-ILP（软件调度的ILP）" class="headerlink" title="Software Scheduling for Exposing ILP（软件调度的ILP）"></a>Software Scheduling for Exposing ILP（软件调度的ILP）</h3><p><strong>核心思路：</strong> 聪明的编译器会根据代码的结构尽量减少stall。</p>
<p>举例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-42.png" alt="Alt text"><br>每次add前要等load把数据读出来，需要一个周期stall（加了forwarding单元后）。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-43.png" alt="Alt text"><br>通过循环内指令的重排，减少了stall。 (区别就是把 DADDUI R1,R1, #-8 这条判断循环跳转的指令挪到上面去了)</p>
<p><img src="/2024/02/16/Computer-Architecture/image-44.png" alt="Alt text"></p>
<p>更近一步，把循环4倍展开。可以有更多指令用于重排。进一步减少stall。问题在于使用了更多的寄存器，需要保证寄存器够用。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-45.png" alt="Alt text"></p>
<h3 id="Dynamic-Scheduling-动态调度"><a href="#Dynamic-Scheduling-动态调度" class="headerlink" title="Dynamic Scheduling 动态调度"></a>Dynamic Scheduling 动态调度</h3><p>首先考虑一个顺序发射，顺序执行(in order issue, in order execution)的例子：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-46.png" alt="Alt text"><br>F0存在经典的RAW，因而会有stall（没有forwarding单元，或者流水深度过长的时候）。</p>
<p>如果将第二条指令和第三条指令交换顺序执行，则不存在上述问题。能这么做的原因在于，两条指令直接不存在相关性。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-47.png" alt="Alt text"><br>对于WAW,WAR,简单的寄存器重命名就可以解决依赖问题。</p>
<h4 id="OOO-out-of-order-的思想"><a href="#OOO-out-of-order-的思想" class="headerlink" title="OOO(out of order)的思想"></a>OOO(out of order)的思想</h4><p>stall会出现的本质原因，在于指令被译码结束后，其操作数因为各种原因还没有准备好(比如需要等其它指令计算结束，或相关操作数在memory中需要load)。既然如此，指令译码结束后，可以检测其操作数状态，只有操作数准备好的指令，才将其放入对应的计算资源中执行相应操作。从而最大程度减小stall。</p>
<p>另外，尽管指令是乱序执行的，但让处理器在指令完成后对结果进行重排序，以确保与程序指定的顺序一致，就可以保证程序的正确性。</p>
<p>这方面的一个典型例子是Tomasulo 算法。</p>
<h4 id="Tomasulo-Algorithm"><a href="#Tomasulo-Algorithm" class="headerlink" title="Tomasulo Algorithm"></a>Tomasulo Algorithm</h4><p>实现OOO的关键在于硬件支持：一个典型的Tomasulo算法需要以下功能单元：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-48.png" alt="Alt text"></p>
<ol>
<li><p><strong>保留站（Reservation Stations）</strong></p>
<ol>
<li>作用：保留站用于暂存即将执行的指令，同时跟踪指令所需的操作数是否已经可用。</li>
<li>功能：每个保留站都与一个特定的执行单元相关联，并存储指令、操作数、操作数的来源以及执行状态等信息。保留站还负责检测操作数的可用性，并在操作数准备就绪时触发指令的执行。</li>
</ol>
</li>
<li><p><strong>寄存器重命名（Register Renaming）</strong></p>
<ol>
<li>作用：减少WAR（Write After Read）和WAW（Write After Write）冲突，提高指令流的并行度。</li>
<li>功能：使用保留站中的标签而非真实的寄存器名称，从而允许多个指令同时对同一寄存器进行操作，而不会相互干扰。</li>
</ol>
</li>
<li><p><strong>公共数据总线（Common Data Bus，CDB）</strong></p>
<ol>
<li>作用：用于广播执行单元完成的操作结果，同时通知等待这些结果的其它保留站和寄存器。</li>
<li>功能：任何执行单元完成操作后，会将结果放在CDB上。保留站和寄存器监听CDB，以获取它们需要的数据。</li>
</ol>
</li>
<li><p><strong>执行单元（Execution Units）</strong></p>
<ol>
<li>作用：执行具体的计算任务，如加法、乘法、逻辑操作等。</li>
<li>功能：根据保留站提供的指令和操作数进行计算，并将结果发送到CDB。</li>
</ol>
</li>
<li><p><strong>指令队列（Instruction Queue）</strong></p>
<ol>
<li>作用：暂存尚未处理的指令。</li>
<li>功能：指令队列按照程序顺序存储指令，然后将指令分发到相应的保留站。</li>
</ol>
</li>
<li><p><strong>load Buffers</strong></p>
<ol>
<li>作用：Load Buffers用于处理来自内存的加载（load）操作。</li>
<li>功能：当指令队列中出现一个加载操作时，该操作被放置在Load Buffer中。Load Buffer负责跟踪加载操作的地址计算，并在地址计算完成后从内存中获取数据。一旦数据加载完成，它就可以被送往执行单元或者直接写入寄存器。</li>
</ol>
</li>
<li><p><strong>Store Buffers</strong></p>
<ol>
<li>作用：Store Buffers用于处理写入内存的存储（store）操作。</li>
<li>功能：当指令队列中出现一个存储操作时，该操作被放置在Store Buffer中。Store Buffer负责跟踪存储操作的地址计算和待存储的数据。一旦地址和数据都准备好，存储操作就可以被提交到内存。</li>
</ol>
</li>
<li><p><strong>重排序缓冲区（Reorder Buffer，ROB，可选）</strong></p>
<ol>
<li>作用：确保即使在乱序执行的情况下，指令的结果也能按照程序顺序提交（commit），维护程序的正确性。</li>
<li>功能：ROB跟踪指令的执行状态，并在所有先行指令完成后按序提交结果。</li>
</ol>
</li>
</ol>
<h4 id="进一步理解："><a href="#进一步理解：" class="headerlink" title="进一步理解："></a>进一步理解：</h4><p><img src="/2024/02/16/Computer-Architecture/image-49.png" alt="Alt text"></p>
<p>一个Tomasulo 的算法表。其中各部分的解释如下：</p>
<ol>
<li><p><strong>Instruction status:</strong> 一条指令包含多种状态。Issue代表已经发射(放入了执行队列)，Execute表示被执行(放入了对应的执行单元)，Write Result表示执行完毕且结果已写回。 这部分只是便于理解算法本身，硬件中并不存在真实的结构。</p>
</li>
<li><p><strong>Reservation Stations:</strong> 保留站中指令的状态。</p>
<ol>
<li>Op：表示对应的操作。</li>
<li>Busy: 对应的执行单元处于忙碌状态，指令正在执行，或者对应的发射槽被占用。</li>
<li>Vj,Vk: 左右操作数的值。表示操作数具体放在哪个寄存器。如果Vj,Vk都有数，且对应的执行单元不busy,说明指令可以被执行。</li>
<li>Qj,Qk:即将产生Vj,Vk的操作。表示指令直接的依赖关系。也就是说，Qj和Vj互斥，Qk和Vk互斥，2个中只同时有一个有数。</li>
</ol>
</li>
<li><p><strong>Register Status：</strong> 寄存器与对应指令的关系，表明那条指令将写哪个寄存器。</p>
</li>
</ol>
<h4 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h4><p><img src="/2024/02/16/Computer-Architecture/image-50.png" alt="Alt text"><br>    初始状态</p>
<p><img src="/2024/02/16/Computer-Architecture/image-51.png" alt="Alt text"></p>
<p>第一条指令被发射，进入loads buffer，同时对应的寄存器F6处记录下Load1，表示Load1的结构将写入F6。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-52.png" alt="Alt text"></p>
<p>发射指令load2，和前面差不多</p>
<p><img src="/2024/02/16/Computer-Architecture/image-53.png" alt="Alt text"></p>
<p>第一条load指令执行完毕，拿到了操作数，但还没来得及写回。第三条mul指令被发射，进入保留站，对应的发射槽变为Busy。其右操作数F4是现成的，因此写在Vk，而左操作数依赖Load2的结果，写在Qj。由于此时load2还没执行完，因此这条乘法指令没发被执行。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-54.png" alt="Alt text"></p>
<p>下一条减法指令发射。第一条load指令已经将结果写入F6寄存器。因此减法指令可以直接拿到这个操作数Vj,而另一个操作数需要等待Load2写回。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-55.png" alt="Alt text"></p>
<p>Load2写回， Mul和sub指令都拿到了2个操作数，下一个周期就可以开始执行了。其余类似。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-56.png" alt="Alt text"><br>注意看上面的2条运算指令进入了complete阶段。</p>
<h4 id="Tumasulo的总结"><a href="#Tumasulo的总结" class="headerlink" title="Tumasulo的总结"></a>Tumasulo的总结</h4><p>很经典，体现了OOO的精髓。很有效率，但是硬件开销比较大。体</p>
<p>同时Common Data Bus的设计存在很大限制。因为它需要广播通知所有的保留站对应的操作数到了，从而存在以下几个问题：</p>
<ol>
<li>扇出（Fan-out）问题<br>挑战：CDB需要将数据同时广播给多个保留站和寄存器文件，这就导致了较大的扇出。高扇出会增加电路的负载，从而影响信号的传播时间和电路的响应速度。<br>影响：高扇出可能限制处理器的时钟频率，因为信号需要在一个时钟周期内在整个CDB上稳定下来。</li>
<li>功耗<br>挑战：广播机制意味着CDB在每次操作时都需要激活多个接收点，这增加了功耗。<br>影响：在功耗敏感的应用场景中，如移动设备或高性能计算，这可能是一个显著的问题。</li>
<li>硬件复杂性<br>挑战：实现一个高效且可靠的CDB需要复杂的硬件设计，尤其是在处理高速、高密度信号时。<br>影响：这增加了处理器设计的复杂性和成本。</li>
<li>争用和冲突<br>挑战：当多个执行单元几乎同时完成计算时，可能会出现对CDB的争用。<br>影响：必须有机制来处理这种争用，否则可能导致性能下降。</li>
</ol>
<h4 id="Dynamic-Scheduling的总结"><a href="#Dynamic-Scheduling的总结" class="headerlink" title="Dynamic Scheduling的总结"></a>Dynamic Scheduling的总结</h4><p><strong>优点</strong></p>
<ol>
<li><p>提高性能：通过允许指令乱序执行，动态调度可以减少因数据依赖性引起的延迟，提高处理器的执行效率。</p>
</li>
<li><p>提高资源利用率：动态调度允许处理器更有效地利用其执行单元，减少因指令等待而空闲的情况。</p>
</li>
<li><p>减少冲突：动态调度可以减少流水线中的结构冲突和数据冲突，尤其是在超标量和乱序执行的处理器中。</p>
</li>
<li><p>自适应性：动态调度可以根据指令流的实际情况动态调整，适应不同的程序和工作负载。</p>
</li>
<li><p>隐藏延迟：它可以有效地隐藏长延迟操作（如缓存未命中）的影响，通过执行其他独立指令来填充等待时间。</p>
</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><p>硬件复杂性：实现动态调度需要复杂的硬件支持，如保留站、重排序缓冲区和复杂的控制逻辑。</p>
</li>
<li><p>功耗增加：由于需要更多的硬件资源和更高的运算速度，动态调度的处理器通常消耗更多的功率。</p>
</li>
<li><p>设计挑战：设计一个高效且准确的动态调度算法是非常具有挑战性的，需要精确处理指令间的依赖和冲突。</p>
</li>
<li><p>成本增加：与简单的顺序执行处理器相比，动态调度处理器的制造成本更高。</p>
</li>
<li><p>时钟频率的限制：由于动态调度的复杂性，可能对处理器的最高时钟频率造成限制。</p>
</li>
</ol>
<h3 id="推断（Speculation）"><a href="#推断（Speculation）" class="headerlink" title="推断（Speculation）"></a>推断（Speculation）</h3><pre><code>Speculation = Dynamic Scheduling + Prediction
</code></pre>
<p>动态调度结合分支预测技术，提前执行一些可能用得到的指令。如果判断对了，皆大欢喜，如果判断失误，丢弃对应的指令结果，进行回滚(Roll back)。可以总结为: Out of order execution, in order commit.</p>
<h4 id="关键硬件-ROB（Reorded-Buffer）"><a href="#关键硬件-ROB（Reorded-Buffer）" class="headerlink" title="关键硬件: ROB（Reorded Buffer）"></a>关键硬件: ROB（Reorded Buffer）</h4><p><img src="/2024/02/16/Computer-Architecture/image-57.png" alt="Alt text"></p>
<h5 id="ROB的工作原理"><a href="#ROB的工作原理" class="headerlink" title="ROB的工作原理"></a>ROB的工作原理</h5><ol>
<li><p>指令进入ROB：当指令被分派（Dispatched）到流水线时，它们会进入ROB。每条指令在ROB中都有一个对应的条目。</p>
</li>
<li><p>指令执行：指令可以乱序执行，即按照数据依赖和执行单元的可用性进行执行，而不是严格按照程序顺序。执行过程中，指令的结果（如计算结果或加载的数据）暂时存储在ROB中，而不是直接写入寄存器或内存。</p>
</li>
<li><p>维护程序顺序：尽管指令是乱序执行的，ROB确保按照原始程序顺序“提交”（Commit）指令的结果。这意味着只有当ROB中所有先前的指令都已正确完成，一条指令的结果才能被提交到寄存器或内存。</p>
</li>
<li><p>处理分支和异常：如果处理器遇到分支预测错误或异常，ROB可以用来撤销或回滚错误预测的指令，并从正确的点重新开始执行。</p>
</li>
<li><p>结果提交：一旦确认指令可以安全提交，其结果就从ROB转移到相应的目的地，如寄存器文件或内存。这个提交过程保证了即使发生乱序执行，外部观察到的效果仍然符合程序的顺序执行。</p>
</li>
</ol>
<h5 id="ROB的重要性"><a href="#ROB的重要性" class="headerlink" title="ROB的重要性"></a>ROB的重要性</h5><ol>
<li>支持乱序执行：ROB使得处理器可以在保持程序语义的前提下自由地重排指令的执行顺序。</li>
<li>支持推测执行：ROB存储推测执行的结果，并在确定这些推测是正确的之后才进行提交。</li>
<li>保证异常处理的正确性：在发生异常或分支预测错误时，ROB提供了一种机制来撤销或回滚已经执行但尚未提交的指令。</li>
<li>隐藏延迟：通过允许后续独立指令先于前面的长延迟指令执行，ROB有助于隐藏延迟，提高处理器效率。</li>
</ol>
<h3 id="Multi-Issue多发射"><a href="#Multi-Issue多发射" class="headerlink" title="Multi Issue多发射"></a>Multi Issue多发射</h3><p>首先思考CPI这个概念：顾名思义，Clock Per Instruction，在流水下，最优的情况是每个周期就能执行一条指令，也就是说CPI&#x3D;1.那么问题来了，能不能进一步挖掘指令的并行性能，使CPI小于1？</p>
<p><strong>Multi Issue（多发射）</strong>技术是指处理器能够在每个时钟周期内发射（即开始执行）多条指令的能力。这种技术是超标量架构的一个关键特征，它允许处理器并行地执行多个操作，从而提高整体性能和处理器的吞吐量。</p>
<p>一个解决方法是，使用超长指令字(Very Long Instruction Word)VLIW。<br>每条超长指令是一系列简单指令的拼接。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-58.png" alt="Alt text"></p>
<h3 id="多线程Multi-Thread"><a href="#多线程Multi-Thread" class="headerlink" title="多线程Multi Thread"></a>多线程Multi Thread</h3><p>（待补充）</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="Chapter-4-DLP-in-Vector-SIMD-and-GPU-Architectures"><a href="#Chapter-4-DLP-in-Vector-SIMD-and-GPU-Architectures" class="headerlink" title="Chapter 4 DLP in Vector, SIMD, and GPU  Architectures"></a>Chapter 4 DLP in Vector, SIMD, and GPU  Architectures</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><h4 id="数据级并行（Data-level-parallelism-DLP）"><a href="#数据级并行（Data-level-parallelism-DLP）" class="headerlink" title="数据级并行（Data level parallelism, DLP）"></a>数据级并行（Data level parallelism, DLP）</h4><p>数据级并行是指同时对多个数据项执行相同的操作。这种并行性主要体现在在单个操作中处理多个数据项，而不是在多个操作上。在处理大量数据时，DLP特别有效，因为它可以显著加快数据处理速度。</p>
<h4 id="单指令多数据流（Single-Instruction-Multi-Data-SIMD）"><a href="#单指令多数据流（Single-Instruction-Multi-Data-SIMD）" class="headerlink" title="单指令多数据流（Single Instruction Multi Data,SIMD）"></a>单指令多数据流（Single Instruction Multi Data,SIMD）</h4><p>SIMD是实现数据级并行的一种常见方式。在SIMD架构中，单个指令控制多个处理单元同时对不同的数据执行相同的操作。这种方法在多媒体处理、科学计算和机器学习等领域非常有效，因为这些领域常常涉及到对大量数据执行重复的操作。</p>
<p>同时，由于SIMD的编程模型仍然是串行的，比较符合人类的思维逻辑，减小了编程的难度。</p>
<h4 id="向量处理器（Vector-Processor）"><a href="#向量处理器（Vector-Processor）" class="headerlink" title="向量处理器（Vector Processor）"></a>向量处理器（Vector Processor）</h4><p>向量处理器是一种专门的处理器，设计用来高效地执行SIMD操作。在向量处理器中，指令不是对单个数据项进行操作，而是对一个数据集合（向量）进行操作。每个向量指令可以同时对多个数据元素执行相同的操作，这使得向量处理器特别适合于那些需要大规模数值计算的应用。</p>
<h3 id="一个典型例子-VMIPS"><a href="#一个典型例子-VMIPS" class="headerlink" title="一个典型例子:VMIPS"></a>一个典型例子:VMIPS</h3><p><img src="/2024/02/16/Computer-Architecture/image-60.png" alt="Alt text"><br>在硬件上对寄存器和运算单元进行扩展，同时设计了新的指令，支持向量操作</p>
<p><img src="/2024/02/16/Computer-Architecture/image-59.png" alt="Alt text"></p>
<p>使用vector后，64个数据的操作指令减少到6条。</p>
<h5 id="向量体系结构的运行时间分析"><a href="#向量体系结构的运行时间分析" class="headerlink" title="向量体系结构的运行时间分析"></a>向量体系结构的运行时间分析</h5><p><img src="/2024/02/16/Computer-Architecture/image-61.png" alt="Alt text"><br>假设只有1个执行单元，多条指令可以同时发射，但需要顺序执行，此时执行时间约等于向量的长度。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-62.png" alt="Alt text"></p>
<p>在这张图上我们假设乘法单元和加法单元各有一个，则通过前递(forwarding)二者可以几乎并行的执行。</p>
<ol>
<li><p>Convoy<br>在向量处理器的上下文中，“Convoy”通常指一组可以同时发射（即开始执行）的向量指令。在某些向量处理器设计中，一组指令被打包成一个Convoy，这组指令共享相同的执行资源。Convoy的概念有助于优化指令流水线，提高处理器的吞吐量。</p>
</li>
<li><p>Chaining<br>“Chaining”是向量处理器中一种重要的性能优化技术。在Chaining中，一个向量指令的输出直接作为另一个向量指令的输入，而无需等待第一个指令完全完成。这种方法可以减少存储器访问和中间结果写回的开销，从而加速整个计算过程。</p>
</li>
<li><p>chime<br>向量处理器处理一个convoy的用时。m个convey则需要m个chime。<br>对应长度为$n$的向量，则需要$m\times$个周期来执行。</p>
<p>例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-63.png" alt="Alt text"></p>
</li>
</ol>
<h4 id="提升Vector性能的方法"><a href="#提升Vector性能的方法" class="headerlink" title="提升Vector性能的方法"></a>提升Vector性能的方法</h4><p><img src="/2024/02/16/Computer-Architecture/image-64.png" alt="Alt text"></p>
<h5 id="multiple-lanes"><a href="#multiple-lanes" class="headerlink" title="multiple lanes"></a>multiple lanes</h5><p><img src="/2024/02/16/Computer-Architecture/image-65.png" alt="Alt text"></p>
<p>最简单粗暴的方法：直接做多硬件资源，使各种功能单元数量翻倍。</p>
<h5 id="Vector-Length-Register"><a href="#Vector-Length-Register" class="headerlink" title="Vector Length Register"></a>Vector Length Register</h5><p>使用向量长度寄存器，达到能够支持任意长度向量的效果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">low = <span class="number">0</span>;</span><br><span class="line">VL = (n % MVL); <span class="comment">/*find odd-size piece using modulo op % */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= (n/MVL); j=j+<span class="number">1</span>) &#123; <span class="comment">/*outer loop*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt; (low+VL); i=i+<span class="number">1</span>) <span class="comment">/*runs for length VL*/</span></span><br><span class="line">        Y[i] = a * X[i] + Y[i] ; <span class="comment">/*main operation*/</span></span><br><span class="line">    low = low + VL; <span class="comment">/*start of next vector*/</span></span><br><span class="line">    VL = MVL; <span class="comment">/*reset the length to maximum vector length*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中MVL为Maximum Vector Length,即硬件支持的最大向量长度（如64）。这个大小对程序员来说是已知的。</p>
<h5 id="Vertor-Mask-Register"><a href="#Vertor-Mask-Register" class="headerlink" title="Vertor Mask Register"></a>Vertor Mask Register</h5><p>考虑如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i=i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (X[i] != <span class="number">0</span>)</span><br><span class="line">        X[i] = X[i] – Y[i];</span><br></pre></td></tr></table></figure>

<p>对一个向量中符合某种条件的代码进行操作。</p>
<p>此时可以使用Mask Vector</p>
<p>对应的汇编指令可以设计为：<br><img src="/2024/02/16/Computer-Architecture/image-67.png" alt="Alt text"></p>
<p>而在硬件支持方面，只需要在所有运算单元上增加一个enable信号，只有接收到enable信号的功能单元才执行操作，即可支持mask功能。</p>
<h5 id="Memory-Banks"><a href="#Memory-Banks" class="headerlink" title="Memory Banks"></a>Memory Banks</h5><p>使用多bank的内存，支持高带宽的并行存取。</p>
<p>此时需考虑bank conflict的情况。</p>
<p>如矩阵乘：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i=i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j=j+<span class="number">1</span>) &#123;</span><br><span class="line">        A[i][j] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k=k+<span class="number">1</span>)</span><br><span class="line">            A[i][j] = A[i][j] + B[i][k] * D[k][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于D矩阵的数据，如果存储在同一个bank中，会出现比较严重的bank conflict。例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-68.png" alt="Alt text"></p>
<h5 id="Scatter-Gather-对稀疏的支持。"><a href="#Scatter-Gather-对稀疏的支持。" class="headerlink" title="Scatter-Gather 对稀疏的支持。"></a>Scatter-Gather 对稀疏的支持。</h5><p>考虑计算2个稀疏矩阵A和C的加法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">    A[K[i]] = A[K[i]]+C[K[i]];</span><br><span class="line">    A[M[i]] = A[M[i]]+C[M[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>K和M分别是A与C中非0元素位置的索引。需要的指令支持为：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-69.png" alt="Alt text"></p>
<h4 id="向量处理器的优缺点"><a href="#向量处理器的优缺点" class="headerlink" title="向量处理器的优缺点"></a>向量处理器的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>对于取值来说，向量处理器能够用更少的指令实现同样的功能，因此简化了取指。</li>
<li>简化了指令的发射执行。对于分支指令，由于向量指令能够合并分支，避免了一部分分支预测的开销。同时对于数据依赖检测的硬件实现也更简单。</li>
<li>更有效的内存访问。向量结构的访存地址通常更规则，结合memory的bank结构，能够更有效的存取数据，使得访存的延迟被摊销掉不少。</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>对于一些标量操作，仍然需要传统的标量单元来执行</li>
<li>难以进行精确的中断控制。因为是向量操作，无法进行有效的数据回滚</li>
<li>对编译器和程序员带来一定挑战，必须将原本的程序向量化</li>
<li>如果向量长度比较小，向量处理器通常并不高效</li>
<li>对某些特殊的应用类型的性能很一般(数据并行度比较差的程序)</li>
<li>需要对内存系统进行优化</li>
</ol>
<h3 id="GPGPU-General-Purpose-Graphics-Processing-Unit-通用图形处理器"><a href="#GPGPU-General-Purpose-Graphics-Processing-Unit-通用图形处理器" class="headerlink" title="GPGPU General Purpose Graphics Processing Unit 通用图形处理器"></a>GPGPU General Purpose Graphics Processing Unit 通用图形处理器</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>GPGPU</strong>（General-Purpose computing on Graphics Processing Units）指的是在图形处理单元（GPU）上进行的通用计算。这种技术利用了GPU的高并行处理能力来执行非图形相关的计算任务，特别是那些可以通过数据并行性来显著加速的任务。</p>
<p><strong>背景</strong><br>最初，GPU被设计用来处理计算机图形和图像相关的任务，例如渲染3D图形和处理视频内容。然而，人们逐渐意识到GPU强大的并行处理能力也非常适合进行科学计算、工程模拟、数据分析等任务。</p>
<p><strong>GPGPU的特点</strong><br>高度的数据并行性：GPU含有数百到数千个小型、高效的处理核心，能够同时处理大量数据。</p>
<p><strong>专用硬件加速</strong>：GPU包含专门设计的硬件，适用于执行浮点运算和向量运算。</p>
<p><strong>适用于特定类型的计算</strong>：GPGPU非常适合执行可以被分解为小的、独立的并行任务的计算，如矩阵运算、信号处理等。</p>
<p><strong>编程模型</strong>：利用GPGPU进行计算通常需要特定的编程模型和编程语言，如CUDA（Compute Unified Device Architecture，由NVIDIA开发）和OpenCL（Open Computing Language）。</p>
<h4 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h4><p>什么是编程？</p>
<p>编程模型（Programming Model）是指用于指导和简化特定类型程序设计的一套规则、概念和结构。它定义了程序中的数据和控制流结构，以及程序员与计算系统（如处理器、操作系统或整个计算平台）之间的交互方式。编程模型是编程范式（如面向对象编程、函数式编程）和具体技术实现（如API或编程框架）之间的中间层。</p>
<p>一般而言，编程模型包含以下3个方面：</p>
<ol>
<li>How to compute the wanted function(计算过程、算法)</li>
<li>How to organize the memory to serve the computation（存储管理）</li>
<li>How to map the function to the real hardware（控制、硬件配置）</li>
</ol>
<p>对于GPU这类并行架构来说，编程模型更关心以下几个方面：</p>
<ol>
<li>How to divide the workload (任务的切分)</li>
<li>How to communicate between the divided work（任务间通信）</li>
<li>How to synchronize the divided work（任务同步）</li>
</ol>
<h5 id="异构计算-Heterogeneous-computing"><a href="#异构计算-Heterogeneous-computing" class="headerlink" title="异构计算 Heterogeneous computing"></a>异构计算 Heterogeneous computing</h5><p>在程序员的视角，GPU编程是一种异构计算：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-70.png" alt="Alt text"></p>
<p>异构计算（Heterogeneous Computing）是一种计算范式，它涉及到在单个系统中结合使用多种类型的处理器或核心来提高计算效率和性能。这种系统通常包含不同种类的处理单元，如传统的中央处理器（CPU）、图形处理器（GPU）、数字信号处理器（DSP）和其他类型的专用加速器。</p>
<h5 id="GPGPU的线程模型："><a href="#GPGPU的线程模型：" class="headerlink" title="GPGPU的线程模型："></a>GPGPU的线程模型：</h5><p>NVIDIA GPU的线程模型是一个专门为其CUDA（Compute Unified Device Architecture）平台设计的并行计算架构。这个模型使得开发者能够有效地利用GPU的强大并行处理能力。在这个模型中，关键概念包括内核（Kernel）、网格（Grid）、块（Block）和线程（Thread）。</p>
<p><strong>Kernel（内核）</strong><br>含义：内核是在GPU上执行的一个函数。当你启动一个内核时，实际上是在告诉GPU同时执行许多线程的实例。<br>角色：每个内核代表了一个在GPU上并行执行的任务。在CUDA编程中，内核由特定的CUDA C&#x2F;C++函数构成，使用__global__声明修饰符标记。</p>
<p><strong>Grid（网格）</strong><br>含义：网格是一组块的集合。当一个内核被启动时，它会以网格的形式组织。<br>角色：网格代表了所有线程的总体组织结构，它定义了执行内核所需要的所有线程块。</p>
<p><strong>Block（块）</strong><br>含义：块是一组线程的集合，这些线程可以协同执行，并能够通过共享内存进行通信。<br>角色：每个块中的线程可以同步执行，并共享一定量的快速但容量有限的共享内存。一个块内的所有线程都在同一个GPU上执行。</p>
<p><strong>Thread（线程）</strong><br>含义：线程是执行内核代码的基本单位。每个线程执行内核中的一部分操作。<br>角色：在CUDA中，每个线程都有其唯一的线程ID，用于计算数据的位置和执行特定的操作。线程是实际执行计算的实体。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-71.png" alt="Alt text"></p>
<p><img src="/2024/02/16/Computer-Architecture/image-72.png" alt="Alt text"></p>
<h5 id="SMIT-和SMID的区别"><a href="#SMIT-和SMID的区别" class="headerlink" title="SMIT 和SMID的区别"></a>SMIT 和SMID的区别</h5><p><img src="/2024/02/16/Computer-Architecture/image-73.png" alt="Alt text"></p>
<p>SMID是一个线程同时操作多个标量操作。<br>SMIT是多个线程同时进行单个的标量操作。</p>
<h5 id="GPU的优势"><a href="#GPU的优势" class="headerlink" title="GPU的优势"></a>GPU的优势</h5><p>branch, memory bandwidth, multi-bank, coalescing</p>
<h4 id="GPU控制架构"><a href="#GPU控制架构" class="headerlink" title="GPU控制架构"></a>GPU控制架构</h4><p><img src="/2024/02/16/Computer-Architecture/image-74.png" alt="Alt text"></p>
<p>一个SM(Streaming Multiprocessor)可编程多处理器 的架构如图。</p>
<h5 id="Warp的概念"><a href="#Warp的概念" class="headerlink" title="Warp的概念"></a>Warp的概念</h5><p>线程组：一个 Warp 通常包含32个线程。这些线程在硬件上被同时调度执行，共享同一个指令流。</p>
<p>并行执行：Warp 中的所有线程都执行相同的指令，但是每个线程可以在不同的数据上操作。这是一种单指令多数据（SIMD）的并行处理方式。</p>
<p>效率：通过将多个线程组织成一个 Warp，GPU 能够高效地利用其并行处理单元，尤其是在处理类似的数据或执行重复任务时。</p>
<p>SM上的指令调度全部以warp为单位进行。<br><img src="/2024/02/16/Computer-Architecture/image-75.png" alt="Alt text"></p>
<p>warp只有在ready的情况下才会被调度。warp的标志位包括：</p>
<ol>
<li>ID：表示线程数的identity</li>
<li>PC: PC值，warp的指令地址</li>
<li>Decoded instruction:需要执行的指令类型</li>
<li>Ready: 可以被调度</li>
<li>Valid: 是否有效</li>
</ol>
<p>warp的调度方法包括 轮询(round-robin),贪心GTO(greedy-then-oldest)。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-76.png" alt="Alt text"></p>
<p>轮询存在的问题： 每个线程都是先访存再计算，导致计算效率低。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-77.png" alt="Alt text"></p>
<p>使用2级轮询可以进行改善。</p>
<h5 id="线程的发散"><a href="#线程的发散" class="headerlink" title="线程的发散"></a>线程的发散</h5><p>(略，复习不完了)</p>
<h4 id="GPU-存储架构"><a href="#GPU-存储架构" class="headerlink" title="GPU 存储架构"></a>GPU 存储架构</h4><p>不同于CPU，GPU中的存储器呈倒三角结构</p>
<p><img src="/2024/02/16/Computer-Architecture/image-78.png" alt="Alt text"></p>
<h4 id="运算单元架构"><a href="#运算单元架构" class="headerlink" title="运算单元架构"></a>运算单元架构</h4><p>(略，复习不完了)</p>
<h4 id="张量核心架构"><a href="#张量核心架构" class="headerlink" title="张量核心架构"></a>张量核心架构</h4><p>(略，复习不完了)</p>
<h2 id="Chapter-5-Multiprocess-and-Thread-Level-Parallelism"><a href="#Chapter-5-Multiprocess-and-Thread-Level-Parallelism" class="headerlink" title="Chapter 5 Multiprocess and Thread-Level Parallelism"></a>Chapter 5 Multiprocess and Thread-Level Parallelism</h2><h3 id="多处理器的概念"><a href="#多处理器的概念" class="headerlink" title="多处理器的概念"></a>多处理器的概念</h3><p>在计算机架构中，多处理器（Multiprocessor）指的是包含多个处理单元（通常是CPU核心）的系统。这些处理单元可以并行处理多个任务，提高系统的总体计算能力和吞吐率。多处理器系统可以是对称的（SMP，Symmetric Multiprocessing）或不对称的（Asymmetric Multiprocessing），具体取决于各个处理器之间的角色和功能是否相同。</p>
<p>多处理器的特点<br>并行处理能力：多处理器系统能够同时执行多个计算任务，提高了处理效率和吞吐量。</p>
<p>增强的性能：相较于单处理器系统，多处理器系统通常提供更高的性能，特别是在处理并行化良好的任务时。</p>
<p>可扩展性：多处理器架构允许更灵活地扩展计算能力，可以通过增加更多的处理器来提高系统性能。</p>
<p>容错能力：在一些设计中，多处理器系统可以提供更好的容错能力，当一个处理器失败时，其他处理器可以接管其任务。</p>
<p>资源共享：多处理器通常共享系统资源，如内存、I&#x2F;O设备等。这要求有效的资源管理和调度策略，以避免冲突和瓶颈。</p>
<p>高效的数据处理：对于需要大量数据处理的应用（如数据库服务器、科学计算应用），多处理器系统可以提供显著的性能优势。</p>
<h3 id="SMP和DMP"><a href="#SMP和DMP" class="headerlink" title="SMP和DMP"></a>SMP和DMP</h3><h4 id="SMP-Symmetric-multiprocessors"><a href="#SMP-Symmetric-multiprocessors" class="headerlink" title="SMP(Symmetric multiprocessors)"></a>SMP(Symmetric multiprocessors)</h4><p><img src="/2024/02/16/Computer-Architecture/image-79.png" alt="Alt text"></p>
<p>多个处理器共享同一个内存地址。(目前大部分Intel和AMD处理器的架构)</p>
<p>地址是一致的(Uniformed Memory Access)</p>
<h4 id="DMP"><a href="#DMP" class="headerlink" title="DMP"></a>DMP</h4><p><img src="/2024/02/16/Computer-Architecture/image-80.png" alt="Alt text"></p>
<p>每个处理器具有独立的内存和地址，需要考虑数据一致性。</p>
<h3 id="多处理器的并行挑战"><a href="#多处理器的并行挑战" class="headerlink" title="多处理器的并行挑战"></a>多处理器的并行挑战</h3><h4 id="并行效率"><a href="#并行效率" class="headerlink" title="并行效率"></a>并行效率</h4><p>例：如果使用100个核，想要达到单核80倍的加速比，根据阿姆达尔定律：</p>
<p>speed up  &#x3D; $\frac{1}{a%+(1-a%)\div100}$</p>
<p>其中a为并行指令的百分比。解的a为0.25，也就是说串行指令只能占0.25%。</p>
<h4 id="通信开销"><a href="#通信开销" class="headerlink" title="通信开销"></a>通信开销</h4><p><img src="/2024/02/16/Computer-Architecture/image-81.png" alt="Alt text"></p>
<p>200ns的通信时间相当于660个时钟周期，0.002的通信频率使CPI变为：<br>$0.5+660\times0.002&#x3D;1.82$</p>
<h4 id="缓存一致性-Cache-Coherence"><a href="#缓存一致性-Cache-Coherence" class="headerlink" title="缓存一致性(Cache Coherence)"></a>缓存一致性(Cache Coherence)</h4><p><img src="/2024/02/16/Computer-Architecture/image-82.png" alt="Alt text"></p>
<p>AB二者缓存中都有数据X，A写了自己的cachee,并通过write through写了Memory,B不知道，造成不一致。</p>
<p>一般来说有3中解决方案：<br><img src="/2024/02/16/Computer-Architecture/image-83.png" alt="Alt text"></p>
<ol>
<li>软件调度，直接禁止所有对Shared Memory的缓存操作</li>
<li>某个处理器写了一个数据后，其它cache中的该数据失效。</li>
<li>通过协议及时更新数据。</li>
</ol>
<h5 id="Snoopy-监听-Coherence-Protocol"><a href="#Snoopy-监听-Coherence-Protocol" class="headerlink" title="Snoopy(监听) Coherence Protocol"></a>Snoopy(监听) Coherence Protocol</h5><p><img src="/2024/02/16/Computer-Architecture/image-84.png" alt="Alt text"></p>
<p>还是上面那个例子，当A写了之后，B再读自己cache中的X会显示cache miss，因为相应数据已经失效了。</p>
<p>实现方式： 通过一个BUS广播告诉所有Cache数据的状态。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-85.png" alt="Alt text"></p>
<p>cache 中，每个数据有3中不同状态：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-86.png" alt="Alt text"></p>
<h6 id="协议内容"><a href="#协议内容" class="headerlink" title="协议内容"></a>协议内容</h6><p><img src="/2024/02/16/Computer-Architecture/image-87.png" alt="Alt text"></p>
<p>分类讨论read hit,read miss,write hit,write miss。</p>
<p>同时在read miss,write hit,write miss的情况下，考虑被替换的数据状态是invalid,shared 还是modified,相应的bus要做出对应的行为。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-88.png" alt="Alt text"><br>Snoopy协议下cache的状态转换图</p>
<p><img src="/2024/02/16/Computer-Architecture/image-89.png" alt="Alt text"><br>Snoopy协议下bus的状态转换图</p>
<h5 id="Snoopy协议的扩展："><a href="#Snoopy协议的扩展：" class="headerlink" title="Snoopy协议的扩展："></a>Snoopy协议的扩展：</h5><h6 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h6><p><img src="/2024/02/16/Computer-Architecture/image-90.png" alt="Alt text"></p>
<p>添加一个新的状态 Exclusive,表示数据在只有本cache中有，而且还没有被写过(clean)</p>
<p>当其它cache读这个数据时，转变为S<br>当本processor写这个cache时，变为M状态，此时不需要广播其它cache。</p>
<h6 id="MOSI"><a href="#MOSI" class="headerlink" title="MOSI"></a>MOSI</h6><p><img src="/2024/02/16/Computer-Architecture/image-91.png" alt="Alt text"></p>
<p>应用场景：处理器之间交换数据速度比处理器与Memory之间交换数据快时，添加一个状态叫Owned</p>
<p>状态为O说明只有这个Cache中的数据是最新的，其它cache都不从memory中拿数据而是从该cache中拿。</p>
<p>O变为M,说明写回Memory的动作完成。</p>
<h5 id="Snoopy总结"><a href="#Snoopy总结" class="headerlink" title="Snoopy总结"></a>Snoopy总结</h5><p>Snoopy协议的基本概念<br>“Snoopy”协议得名于它的工作方式，类似于卡通角色“Snoopy”（史努比）的窥探行为。在这种协议下，每个处理器（或更准确地说，每个处理器的缓存控制器）都会“窥探”（snoop）在共享总线上发生的所有事务（如读取和写入操作），以监控其他处理器对共享内存的访问。</p>
<p>工作机制<br>缓存一致性：Snoopy协议的主要目的是维持缓存一致性，确保所有处理器的缓存中存储的是共享内存的最新数据。</p>
<p>总线监听：当一个处理器执行内存操作（读取或写入）时，其他处理器的缓存控制器会监听总线上的这些操作，并根据需要更新或失效其本地缓存副本。</p>
<p>写入操作：例如，当一个处理器写入共享数据时，其他处理器的缓存可能需要使其缓存中的相应数据无效，以保证一致性。</p>
<p>Snoopy协议的类型<br>写失效（Write Invalidate）：最常见的方式是在写入数据时使其他所有缓存中的该数据无效。<br>写更新（Write Update）：另一种方式是在写入数据时更新所有缓存中的该数据副本。<br>优点与挑战<br>优点：Snoopy协议简单直观，对于中等规模的多处理器系统非常有效。<br>挑战：随着处理器数量的增加，总线流量和协议开销可能会变得过大，影响系统性能。对于大规模的多处理器系统，可能需要更复杂的一致性协议。</p>
<h5 id="Directory-Coherence-Protocol-目录协议"><a href="#Directory-Coherence-Protocol-目录协议" class="headerlink" title="Directory Coherence Protocol 目录协议"></a>Directory Coherence Protocol 目录协议</h5><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>Directory Coherence Protocol是一种用于维护多处理器系统中缓存一致性的协议，特别适用于大规模或者分布式共享内存系统。与基于总线的Snoopy协议不同，Directory协议不依赖于总线广播，而是使用一个中央的存储结构（称为目录）来追踪哪些处理器拥有某个内存位置的副本。</p>
<p>工作原理<br>目录（Directory）：目录是一个数据结构，它存储了每个内存块的共享信息。对于每个内存块，目录记录了哪些缓存拥有该块的副本，以及每个副本的状态（例如，是否被修改）。</p>
<p>状态追踪：当处理器需要读取或写入内存时，它首先与目录通信。目录决定是否需要采取行动，如向其他拥有该数据副本的缓存发送失效（Invalidate）或更新（Update）消息。</p>
<p>消息传递：Directory协议依赖于消息传递机制，用于在处理器、缓存和目录之间传递控制消息。</p>
<p>工作流程<br>读取操作：当处理器发起一个读取请求时，目录检查该内存块的状态，并根据需要更新状态和发送消息。<br>写入操作：当处理器发起写入请求时，目录可能需要向其他拥有该内存块副本的缓存发送失效消息，以保持一致性。<br>优点<br>可扩展性：由于不依赖于总线广播，Directory协议在大规模多处理器系统中比Snoopy协议具有更好的可扩展性。<br>减少网络流量：通过仅向相关的缓存发送消息，Directory协议可以减少网络上的流量和冲突。<br>挑战。</p>
<p>目录开销：目录的维护需要额外的存储空间和管理开销。<br>复杂性：实现和维护Directory协议比Snoopy协议更复杂，特别是在处理大量处理器和缓存时。</p>
<h5 id="-1"><a href="#-1" class="headerlink" title></a></h5><p><img src="/2024/02/16/Computer-Architecture/image-92.png" alt="Alt text"><br>Local Node（本地节点）<br>含义：Local node通常指发起某个特定内存操作（如读取或写入请求）的处理器或缓存。<br>作用：本地节点根据需要读取或修改数据，并与目录节点通信以维护一致性。<br>例子：如果一个处理器尝试写入一个共享变量，那么这个处理器就是该写入操作的本地节点。<br>Home Node（家节点）<br>含义：Home node是存储某个特定内存地址的数据和其目录条目的节点。<br>作用：家节点负责管理目录信息，包括哪些节点拥有该内存地址的副本，以及这些副本的状态（共享、独占、修改等）。<br>例子：对于给定的内存地址，家节点包含该地址的主副本和一个目录条目，用于跟踪其他节点对该地址的缓存情况。<br>Remote Node（远程节点）<br>含义：Remote node指除了本地节点和家节点之外，涉及到特定内存操作的其他节点。<br>作用：远程节点可能包含与操作相关的内存地址的缓存副本。在处理缓存一致性操作时，家节点可能需要向远程节点发送消息，如失效或更新消息。<br>例子：如果多个处理器缓存了同一个内存地址的数据，那么在某个处理器（本地节点）写入该地址时，其他拥有该地址副本的节点就是远程节点。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-93.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>CA</tag>
      </tags>
  </entry>
  <entry>
    <title>笨办法学C</title>
    <url>/2024/04/19/%E7%AC%A8%E5%8A%9E%E6%B3%95%E5%AD%A6C/</url>
    <content><![CDATA[<h1 id="Learn-C-the-hard-way"><a href="#Learn-C-the-hard-way" class="headerlink" title="Learn C the hard way"></a>Learn C the hard way</h1><h2 id="C语法"><a href="#C语法" class="headerlink" title="C语法"></a>C语法</h2><p>略</p>
<h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>使用宏定义构建语法糖。<br><code>&quot;语法糖&quot;是一种编程术语，用来描述那些没有给编程语言添加新功能，但是可以使代码更易读或易写的语法。这些语法通过提供更加方便、简洁的编写方式，使得程序员能够更加快速、更加直观地表达程序设计的意图。 在C语言中，也存在一些语法糖。例如，数组的下标运算就是一种语法糖。例如，array[i]实际上就是*(array + i)的简化写法。另一个例子是for循环，它实际上可以使用while循环和一些额外的语句来实现，但for循环提供了一种更加简洁、易读的方式来编写循环。 虽然语法糖可以使代码更简洁、易读，但并不会影响程序的功能或效率。使用或不使用语法糖，都不会影响程序的运行结果。</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法糖, 写入obj-&gt;_(N), 等价于 obj-&gt;proto.N</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _(N) proto.N</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEW(T, N) Object_new(sizeof(T), T##Proto, N)</span></span><br></pre></td></tr></table></figure>


<h3 id="assert宏"><a href="#assert宏" class="headerlink" title="assert宏"></a>assert宏</h3><p>&lt;assert.h&gt; 是 C 语言的一个标准库，主要提供了一个名为 assert 的宏，用于在程序开发和调试过程中进行条件测试。<br>assert 宏允许程序员在代码中插入诊断信息。如果在运行时，assert 的条件测试失败（即，测试的表达式结果为假），那么程序会立即终止，并显示一条错误消息。这条消息通常包括文件名、源代码行号以及测试失败的表达式。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person *<span class="title function_">Person_create</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span> weight)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">who</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Person));</span><br><span class="line">    assert(who != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    who-&gt;name = strdup(name);</span><br><span class="line">    who-&gt;age = age;</span><br><span class="line">    who-&gt;height = height;</span><br><span class="line">    who-&gt;weight = weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> who;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用assert宏来检查内存是否被成功分配。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>众所周知C不支持面向对象，但是可以通过一些技巧实现类似继承的功能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个基类 Object</span></span><br><span class="line"><span class="comment">//注意这里使用了函数指针，从而可以实现函数重载</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *description;</span><br><span class="line">    <span class="type">int</span> (*init)(<span class="type">void</span> *self);</span><br><span class="line">    <span class="type">void</span> (*describe)(<span class="type">void</span> *self);</span><br><span class="line">    <span class="type">void</span> (*destroy)(<span class="type">void</span> *self);</span><br><span class="line">    <span class="type">void</span> *(*move)(<span class="type">void</span> *self, Direction direction);</span><br><span class="line">    <span class="type">int</span> (*attack)(<span class="type">void</span> *self, <span class="type">int</span> damage);</span><br><span class="line">&#125; Object;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//基类的构造函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Object_new</span><span class="params">(<span class="type">size_t</span> size, Object proto, <span class="type">char</span> *description)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// setup the default functions in case they aren&#x27;t set</span></span><br><span class="line">    <span class="keyword">if</span>(!proto.init) proto.init = Object_init;</span><br><span class="line">    <span class="keyword">if</span>(!proto.describe) proto.describe = Object_describe;</span><br><span class="line">    <span class="keyword">if</span>(!proto.destroy) proto.destroy = Object_destroy;</span><br><span class="line">    <span class="keyword">if</span>(!proto.attack) proto.attack = Object_attack;</span><br><span class="line">    <span class="keyword">if</span>(!proto.move) proto.move = Object_move;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this seems weird, but we can make a struct of one size,</span></span><br><span class="line">    <span class="comment">// then point a different pointer at it to &quot;cast&quot; it</span></span><br><span class="line">    Object *el = <span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">    *el = proto;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the description over</span></span><br><span class="line">    el-&gt;description = strdup(description);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize it with whatever init we were given</span></span><br><span class="line">    <span class="keyword">if</span>(!el-&gt;init(el)) &#123;</span><br><span class="line">        <span class="comment">// looks like it didn&#x27;t initialize properly</span></span><br><span class="line">        el-&gt;destroy(el);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// all done, we made an object of any type</span></span><br><span class="line">        <span class="keyword">return</span> el;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个需要继承基类的子类，用以下方法定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Map</span> &#123;</span></span><br><span class="line">    Object proto;</span><br><span class="line">    Room *start;</span><br><span class="line">    Room *location;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定需要重载的方法：</span></span><br><span class="line">Object MapProto = &#123;</span><br><span class="line">    .init = Map_init,</span><br><span class="line">    .move = Map_move,</span><br><span class="line">    .attack = Map_attack</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用之前的语法糖进行初始化：</span></span><br><span class="line">Map *game = NEW(Map, <span class="string">&quot;The Hall of the Minotaur.&quot;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Programming Language</tag>
      </tags>
  </entry>
  <entry>
    <title>System Verilog Notes</title>
    <url>/2024/02/12/System-Verilog-Notes/</url>
    <content><![CDATA[<h1 id="System-Verilog期末复习"><a href="#System-Verilog期末复习" class="headerlink" title="System Verilog期末复习"></a>System Verilog期末复习</h1><p><strong>题型：<br>简答（填空、代码解析、电路图、波形）<br>编程<br>共20题</strong></p>
<h2 id="SV中的数据类型"><a href="#SV中的数据类型" class="headerlink" title="SV中的数据类型"></a>SV中的数据类型</h2><p><strong>线网</strong>：<code>net tpye</code>  与verilog类似</p>
<p><strong>变量</strong> <code>variable</code><br>大多数变量本身不用来描述电路，只用于更高抽象层面的验证</p>
<p>Reg&#x2F;<strong>logic&#x2F;Bit</strong>&#x2F;byte&#x2F;shortint&#x2F;int&#x2F;longint</p>
<p><strong>增加了2值数据类型</strong></p>
<p><code>logic</code>: <strong>4值数据类型</strong><br>用来代替verilog中的reg和wire<br>（<strong>其中reg被logic完全代替，但logic不能被多驱动</strong>）<br>举例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> a;</span><br><span class="line"><span class="keyword">assign</span> a = xxx; <span class="comment">///wrong</span></span><br><span class="line"><span class="keyword">logic</span> a;</span><br><span class="line"><span class="keyword">assign</span> a = xxx;  <span class="comment">//  acceptable</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LDT(<span class="keyword">input</span> <span class="keyword">logic</span> res);</span><br><span class="line"><span class="keyword">logic</span> q, qn, d, clk, resl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">forever</span> #<span class="number">5</span> clk=~clk;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> resl=~res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">not</span> a(qn,q);</span><br><span class="line">DFF D(q, d, clk, resl);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>logic的使用更加自由，用作端口连接信号时不受限制。</p>
<p><strong>2值数据类型</strong>  （用于testbench）<br>Bit<br>• 1 bit, 2 state integer, scalable to vector</p>
<p>byte<br>• 8 bit, 2 state integer (similar to char in C)  </p>
<p>shortint<br>• 16 bit, 2 state integer (similar to short in C)  </p>
<p>int<br>• 32 bit, 2 state integer (similar to int in C)  </p>
<p>longint<br>• 64 bit, 2 state integer (similar to longlong in C)  </p>
<p>注意区分<code>logic[7:0] x</code> 与 <code>byte x</code> 的区别</p>
<p>1.byte是有符号的，并且只有2值(0和1)</p>
<p><img src="/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_14-08-17.png"><br>4值和2值类型之间如何相互转化？<br>4值的x和z都被转化为2值的0（导致信息丢失）</p>
<p>使用<code>$isunknown</code>来判断x和z</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">$isunknown</span>(iport)==<span class="number">1</span>)</span><br><span class="line"><span class="built_in">$display</span> (“ <span class="number">4</span>-state variable detected”);</span><br></pre></td></tr></table></figure>


<h3 id="Array-Dynamic-arrays-Associative-arrays-Queues"><a href="#Array-Dynamic-arrays-Associative-arrays-Queues" class="headerlink" title="Array&#x2F; Dynamic arrays&#x2F;Associative arrays&#x2F;Queues"></a>Array&#x2F; Dynamic arrays&#x2F;Associative arrays&#x2F;Queues</h3><p>verilog中的向量：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span>[msb:lsb] data;</span><br><span class="line"><span class="comment">//msb 和lsb为常数，二者之间的大小关系没有要求</span></span><br><span class="line"><span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] data_in;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] data_out;<span class="comment">//recommend grammar</span></span><br></pre></td></tr></table></figure>

<p>寄存器组可以用来建模 ROM,RAM（6个晶体管实现1位存储）,RF(register file，26个晶体管实现1位存储)。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[msb:lsb] memory[upper:lower];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] memory1 [<span class="number">0</span>:<span class="number">63</span>]; <span class="comment">//64个8位的存储器</span></span><br><span class="line"><span class="keyword">reg</span> mema [<span class="number">1</span>:<span class="number">5</span>]; <span class="comment">//5个一位的存储器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">5</span>] rega; <span class="comment">//1个5位的寄存器</span></span><br><span class="line"><span class="comment">//区别：对于存储器的访问须指定地址，不能实现同时的所有地址访问。</span></span><br><span class="line">rega = <span class="number">0</span>; <span class="comment">// Legal syntax</span></span><br><span class="line">mema = <span class="number">0</span>; <span class="comment">// illegal syntax，不能同时读</span></span><br><span class="line">mema[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//Assigns 0 to the first element of mema。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> arrayb[<span class="number">7</span>:<span class="number">0</span>][<span class="number">0</span>:<span class="number">255</span>]; <span class="comment">// declare a two-dimensional array of one bit registers 不推荐的写法(找不到对应的硬件)</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，初始化操作mema&#x3D;0不合法，同时对硬件(SRAM)来说,初始化同样没有实现机制。</p>
<p>在设计中，对memeory的单比特访问同样不推荐(mem[a][b])，因为对硬件来说一般会直接读整个字。</p>
<p><strong>对向量的赋值</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_vector();</span><br><span class="line"><span class="keyword">parameter</span> SIZE=<span class="number">64</span>;</span><br><span class="line"><span class="keyword">reg</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] data1;</span><br><span class="line"><span class="keyword">logic</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] data2;</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">data1=<span class="number">0</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br><span class="line">data1=<span class="number">&#x27;bz</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br><span class="line">data1=<span class="number">&#x27;bx</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br><span class="line">data1=<span class="number">64&#x27;hFFFFFFFFFFFFFFFF</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br></pre></td></tr></table></figure>

<p><strong>packed和unpacked Array：</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] c1; <span class="comment">// packed array of scalar bit types</span></span><br><span class="line"><span class="keyword">real</span> u [<span class="number">7</span>:<span class="number">0</span>]; <span class="comment">// unpacked array of real types</span></span><br></pre></td></tr></table></figure>

<p>一维的packed Array相当于vector</p>
<p>Packed Array只能被声明为单比特的数据类型。<br>packed: 存储的时候被打包在一起，可以被当作一个一元变量处理（直接整体赋值）。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>]bytes;</span><br><span class="line">bytes=<span class="number">32</span>’habcd_efab;</span><br><span class="line"><span class="built_in">$displayh</span>(bytes</span><br><span class="line">        bytes[<span class="number">3</span>]</span><br><span class="line">        bytes[<span class="number">3</span>][<span class="number">7</span>]);</span><br></pre></td></tr></table></figure>

<p>Unpacked Array可以被声明为任何数据类型,一般用于一些比较复杂的数据结构。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> lo_hi[<span class="number">0</span>:<span class="number">15</span>]; <span class="comment">//16 ints [0]..[15], Verilog style</span></span><br><span class="line"><span class="keyword">int</span> lo_hi[<span class="number">16</span>]; <span class="comment">//16 ints [0]..[15]，SV style (C’s style)</span></span><br></pre></td></tr></table></figure>

<p>读写问题：<br>越界写被忽略，越界读则得到：（x for 4-state,0 for 2 state）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_outboundry();</span><br><span class="line"><span class="keyword">byte</span> array1 [<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] array2 [<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">array1[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">255</span>;</span><br><span class="line">array2[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">255</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%d&quot;</span>,array1[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// -1 for byte is signed</span></span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%d&quot;</span>,array2[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 255</span></span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,array1[<span class="number">3</span>][<span class="number">3</span>]); <span class="comment">// 8&#x27;b00000000</span></span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,array2[<span class="number">3</span>][<span class="number">3</span>]);<span class="comment">// 8&#x27;bxxxxxxxxx</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>Unpacked Array 的初始化</p>
<p><img src="/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_15-23-40.png"></p>
<p>顺序为：从左往右从低到高<br><img src="/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_15-24-38.png"></p>
<p><strong>混合使用： mixed Array</strong></p>
<p>举例：<br><img src="/2024/02/12/System-Verilog-Notes/image-37.png" alt="内存布局"></p>
<p>理解，每一行(连续的内存空间)，是一个[3:0][7:0]的packed array，而纵向是unpacked 的。<br>索引方式： unpacked 在前，packed在后。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-38.png" alt="Alt text"></p>
<p><strong>Packed Array 和Unpacked Array比较</strong>：</p>
<ol>
<li><p>Packed Array：</p>
<ol>
<li>紧凑存储：Packed array 的所有元素都是紧密排列的，没有间隙。这意味着整个数组可以被视为一个单一的、连续的位向量。</li>
<li><strong>位级操作</strong>：由于其连续的存储方式，可以对整个 packed array 进行位级操作，如位移、逻辑运算等。</li>
<li>定义方式：在声明数组时，packed 维度紧随数据类型之后。例如：bit [3:0] packedArray; 表示一个4位的 packed array。</li>
<li>应用场景：通常用于硬件建模，如总线接口、寄存器等，因为它们可以映射到硬件中的连续位。</li>
</ol>
</li>
<li><p>Unpacked Array：</p>
<ol>
<li>分散存储：Unpacked array 的元素在内存中可能是分散存储的，每个元素可以独立寻址。</li>
<li><strong>元素级操作</strong>：通常对 unpacked array 的操作是在元素级别进行的，如数组的遍历和单个元素的访问。</li>
<li>定义方式：在声明数组时，unpacked 维度跟在变量名之后。例如：int unpackedArray [10]; 表示一个有10个整数的 unpacked array。</li>
<li>应用场景：常用于表示复杂的数据结构，如队列、堆栈、记录等，以及在验证和建模过程中处理大量数据。</li>
</ol>
</li>
</ol>
<h3 id="quiz"><a href="#quiz" class="headerlink" title="quiz"></a>quiz</h3><ol>
<li><p>What is the basic difference between logic and reg?<br> logic的功能几乎完全取代reg和wire.因此区别主要在于，logic可以被连续赋值，而reg不行。</p>
</li>
<li><p>What is the difference between logic and bit?<br> 四值逻辑和二值逻辑的区别。</p>
</li>
<li><p>Should the 2-state variable be used with the DUT?<br>不行，二值逻辑不可综合，无法用于电路的建模</p>
</li>
</ol>
<h3 id="动态数组-Dynamic-Array"><a href="#动态数组-Dynamic-Array" class="headerlink" title="动态数组 Dynamic Array"></a>动态数组 Dynamic Array</h3><p>定义方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] nibble[]; <span class="comment">// Dynamic array of 4-bit vectors</span></span><br><span class="line"><span class="keyword">integer</span> mem[<span class="number">2</span>][]; <span class="comment">// Fixed-size unpacked array composed</span></span><br><span class="line"><span class="comment">// of 2 dynamic subarrays of integers</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Dynamic Array是unpacked的。</p>
<p>用法：本质是一个内置的对象类型，具有new,size,delete等方法。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_da();</span><br><span class="line">    <span class="keyword">int</span> dyn[], d2[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    dyn=<span class="keyword">new</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (dyn[j]) dyn[j]=j;<span class="comment">//[0,1,2,3,4]</span></span><br><span class="line"></span><br><span class="line">    d2=dyn;</span><br><span class="line">    d2[<span class="number">0</span>]=<span class="number">5</span>; [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">$display</span>(dyn[<span class="number">0</span>],d2[<span class="number">0</span>]); <span class="comment">//0,5</span></span><br><span class="line">    dyn=<span class="keyword">new</span>[<span class="number">10</span>](dyn);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%p&quot;</span>,dyn);<span class="comment">//[0,1,2,3,4,0,0,0,0,0]  </span></span><br><span class="line">    dyn=<span class="keyword">new</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%p&quot;</span>,dyn);<span class="comment">//[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span></span><br><span class="line">    dyn<span class="variable">.delete</span>();</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot; %d&quot;</span>,dyn<span class="variable">.size</span>());  <span class="comment">//0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意以上2中new的区别，是用原来的array初始化还是重新初始化。</p>
<h3 id="关联数组-Associate-Array"><a href="#关联数组-Associate-Array" class="headerlink" title="关联数组 Associate Array"></a>关联数组 Associate Array</h3><p>语法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> name [*];</span><br></pre></td></tr></table></figure>

<p>用一个星号进行声明。</p>
<p>与动态数组的比较：<br><img src="/2024/02/12/System-Verilog-Notes/image-39.png" alt="Alt text"><br>可以分配稀疏的存储空间(本质是哈希表)，且索引形式更自由，支持任何形式数据类型的索引。</p>
<p>应用场景：</p>
<ol>
<li>存储稀疏数据：当数据集是非连续的或稀疏的，关联数组是一个理想的选择。</li>
<li>查找表：在需要快速查找的场景下，如实现映射或字典功能。</li>
<li>动态数据处理：在验证环境中，经常需要处理动态变化的数据集，关联数组在这方面非常有用。</li>
</ol>
<h3 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h3><p>语法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> name[$]</span><br></pre></td></tr></table></figure>

<p>参考C++的vector.<br>基础操作：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Size()</span><br><span class="line">Insert()</span><br><span class="line">Delete()</span><br><span class="line">Pop_front()</span><br><span class="line">Pop_back()</span><br><span class="line">Push_front()</span><br><span class="line">Push_back()</span><br></pre></td></tr></table></figure>

<h3 id="Array-Methods"><a href="#Array-Methods" class="headerlink" title="Array Methods:"></a>Array Methods:</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$left</span></span><br><span class="line"><span class="built_in">$right</span></span><br><span class="line"><span class="built_in">$low</span></span><br><span class="line"><span class="built_in">$high</span></span><br><span class="line"><span class="built_in">$increment</span></span><br><span class="line"><span class="built_in">$size</span></span><br><span class="line"><span class="built_in">$dimensions</span></span><br><span class="line"><span class="built_in">$unpacked_dimensions</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举-enumerated"><a href="#枚举-enumerated" class="headerlink" title="枚举 enumerated"></a>枚举 enumerated</h3><p>语法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;red, green, blue&#125; RGB</span><br></pre></td></tr></table></figure>
<p>枚举类型的特性：枚举中的每个变量是默认自增的，当人为定义各类型的值时，需要注意不能违背自增原则。<br><img src="/2024/02/12/System-Verilog-Notes/image-41.png" alt="Alt text"></p>
<h3 id="结构体-Structure"><a href="#结构体-Structure" class="headerlink" title="结构体 Structure"></a>结构体 Structure</h3><p>语法：类似C</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">    <span class="keyword">bit</span> error;</span><br><span class="line">&#125; Instruction_Word</span><br></pre></td></tr></table></figure>

<p>同时还有一种 packed的定义方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> valid;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] tag;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; data_word</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-42.png" alt="Alt text"></p>
<p>packed定义的结构体在内存上是连续的。<br>同时Packed 支持成员索引和按位索引：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">data_word<span class="variable">.tag</span> = <span class="number">8</span>’hf0;</span><br><span class="line">data_word [<span class="number">39</span>:<span class="number">32</span>]=<span class="number">8</span>’hf0;</span><br></pre></td></tr></table></figure>

<h2 id="System-Verilog-Programming-Basic-I"><a href="#System-Verilog-Programming-Basic-I" class="headerlink" title="System Verilog Programming Basic I"></a>System Verilog Programming Basic I</h2><h3 id="verilog-style"><a href="#verilog-style" class="headerlink" title="verilog style"></a>verilog style</h3><p>一个常见的状态机的写法：  </p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> fsm1a (ds, rd, go, ws, clk, rst_n);</span><br><span class="line"><span class="keyword">output</span> ds, rd;</span><br><span class="line"><span class="keyword">input</span> go, ws,clk, rst_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">1</span>:<span class="number">0</span>] IDLE = <span class="number">2&#x27;b00</span>,READ = <span class="number">2&#x27;b01</span>,DLY =<span class="number">2&#x27;b10</span>,DONE = <span class="number">2&#x27;b11</span>;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] state, next;<span class="comment">//reg也可用于描述组合逻辑</span></span><br><span class="line"><span class="keyword">wire</span> rd, ds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) </span><br><span class="line">        state &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        state &lt;= next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(state <span class="keyword">or</span> go <span class="keyword">or</span> ws) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (state)</span><br><span class="line">        IDLE: <span class="keyword">if</span> (go) next = READ;</span><br><span class="line">            <span class="keyword">else</span> next = IDLE;</span><br><span class="line">        READ: next = DLY;</span><br><span class="line">        DLY: <span class="keyword">if</span> (ws) next = READ;</span><br><span class="line">            <span class="keyword">else</span> next = DONE;</span><br><span class="line">        DONE: next = IDLE;</span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> rd = (state==READ || state==DLY);</span><br><span class="line"><span class="keyword">assign</span> ds = (state==DONE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>SV中对端口的数据类型不做限制</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p><code>== !=</code>逻辑判断<br>当x或z参与比较时，返回x</p>
<p><code>=== !==</code><br>将x或z当成独立的状态进行比较</p>
<p><code>==?  !=?</code><br>通配操作，对右边的操作数放宽比较的限制。在通配中，右边的x和z会被忽略。左边有x或z则结果直接变成x。<br><img src="/2024/02/12/System-Verilog-Notes/image-44.png" alt="Alt text"><br>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_wildcard();</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] a, b,c;</span><br><span class="line">    <span class="keyword">logic</span> le1,le2,ce1,ce2,we1,we2,we3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    a=<span class="number">4&#x27;b010z</span>;</span><br><span class="line">    b=<span class="number">4&#x27;b0101</span>;</span><br><span class="line">    c=<span class="number">4&#x27;b010z</span>;</span><br><span class="line"></span><br><span class="line">    le1=(a==b);</span><br><span class="line">    le2=(a==c);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%b,%b&quot;</span>,le1,le2); <span class="comment">//#x,x</span></span><br><span class="line"></span><br><span class="line">    ce1=(a===b);</span><br><span class="line">    ce2=(a===c);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%b,%b&quot;</span>,ce1,ce2);<span class="comment">//#0,1</span></span><br><span class="line"></span><br><span class="line">    we1=(a==?b);</span><br><span class="line">    we2=(b==?a);</span><br><span class="line">    we3=(a==?c);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%b,%b,%b&quot;</span>,we1,we2,we3);<span class="comment">//#x,1,1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h4 id="递增、递减"><a href="#递增、递减" class="headerlink" title="递增、递减"></a>递增、递减</h4><p><code>++  --</code></p>
<p><code>+=  -=</code></p>
<p>注意：+&#x3D;是一种阻塞赋值。</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> test();</span><br><span class="line"><span class="keyword">int</span> dat0,dat1,dat00,dat01,dat02,dat10,dat11,dat12;<span class="comment">//默认值为0</span></span><br><span class="line"><span class="keyword">bit</span> tik=<span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">bit</span> clk;</span><br><span class="line"><span class="keyword">always</span> #<span class="number">1</span> clk=!clk;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat00 &lt;= dat0 + tik; <span class="comment">// 1</span></span><br><span class="line">    dat0 = dat0 + tik; <span class="comment">// 1  (阻塞语句优先执行)</span></span><br><span class="line">    dat01 &lt;= dat0 + tik; <span class="comment">// 2</span></span><br><span class="line">    dat02 &lt;= dat01 + tik; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat10 &lt;= dat1 + tik; <span class="comment">// 1</span></span><br><span class="line">    dat1 += tik; <span class="comment">// 1</span></span><br><span class="line">    dat11 &lt;= dat1 + tik; <span class="comment">// 2</span></span><br><span class="line">    dat12 &lt;= dat11 + tik; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>即 <code>a+=b</code>和<code>a = a+b</code>的效果完全相同。</p>
<p>example</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> test();</span><br><span class="line"><span class="keyword">int</span> dat0,dat1,dat3,dat30,dat31;</span><br><span class="line"><span class="keyword">int</span> tik0,tik1,tik3;</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat0 =tik0++;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;dat0=%d,tik0=%d&quot;</span>,dat0,tik0); <span class="comment">//0, 1</span></span><br><span class="line">    dat1=++tik1;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;dat1=%d,tik1=%d&quot;</span>,dat1,tik1); <span class="comment">//1, 1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat30&lt;=tik3;</span><br><span class="line">    dat3 =++tik3;</span><br><span class="line">    dat31&lt;=tik3;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;dat30=%d,dat3=%d,dat31=%d,tik3=%d&quot;</span>,</span><br><span class="line">    dat30,dat3,dat31,tik3); <span class="comment">// 0,  1,  0(实际上是1),   1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="comment">//display语句比非阻塞赋值的执行要早。</span></span><br></pre></td></tr></table></figure>

<h4 id="inside"><a href="#inside" class="headerlink" title="inside"></a>inside</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] a;</span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">inside</span> &#123;<span class="number">3</span>’b001, <span class="number">3</span>’b010, <span class="number">3</span>’b100&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//与下面的写法等价：</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] a;</span><br><span class="line"><span class="keyword">if</span> ((a==?<span class="number">3</span>’b001)||(a==?<span class="number">3</span>’b010)||(a==?<span class="number">3</span>’b100))</span><br></pre></td></tr></table></figure>
<p>顾名思义，inside用于检查一个变量是否在一个集合中。<br>inside可用于随机数生成。</p>
<p>同时, inside 可以用作通配操作：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> r;</span><br><span class="line"><span class="keyword">assign</span> r=<span class="number">3&#x27;bz11</span> <span class="keyword">inside</span> &#123;<span class="number">3&#x27;b1</span>?<span class="number">1</span>, <span class="number">3&#x27;b011</span>&#125;; <span class="comment">// r = 1&#x27;bx</span></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> r = (<span class="number">3&#x27;bz11</span>==?<span class="number">3&#x27;b1</span>?<span class="number">1</span> || <span class="number">3&#x27;bz11</span>==?<span class="number">3&#x27;b011</span> )</span><br></pre></td></tr></table></figure>

<h4 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h4><p>产生某种统计分布</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> distribution ();</span><br><span class="line">    <span class="keyword">class</span> frame_t;</span><br><span class="line">        <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">constraint</span> len &#123;</span><br><span class="line">        length <span class="keyword">dist</span> &#123;</span><br><span class="line">        [<span class="number">0</span>:<span class="number">7</span>] := <span class="number">8</span>,</span><br><span class="line">        [<span class="number">8</span>:<span class="number">15</span>] := <span class="number">8</span>,</span><br><span class="line">        [<span class="number">16</span>:<span class="number">31</span>] := <span class="number">16</span>&#125;;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="keyword">void</span> post_randomize();</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;length : %d&quot;</span>,length);</span><br><span class="line">        <span class="keyword">endfunction</span> </span><br><span class="line">    <span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    frame_t frame = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">integer</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j &lt; <span class="number">32</span>; j++)</span><br><span class="line">        i = frame<span class="variable">.randomize</span>();</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-5.png" alt="Alt text"></p>
<h4 id="streaming"><a href="#streaming" class="headerlink" title="streaming"></a>streaming</h4><p><code>&#123;&lt;&lt;&#123;&#125;&#125;     &#123;&gt;&gt;&#123;&#125;&#125;</code></p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> streaming();</span><br><span class="line"><span class="keyword">int</span> j = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Value of j %0x&quot;</span>,j);</span><br><span class="line">    <span class="built_in">$monitor</span>(<span class="string">&quot;@%0dns stream value is %x&quot;</span>,<span class="built_in">$time</span>, stream);</span><br><span class="line">    #<span class="number">1</span> stream = &#123; &gt;&gt; &#123;j&#125;&#125;; <span class="comment">// generates stream &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot;</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="keyword">byte</span> &#123;j&#125;&#125;; <span class="comment">// generates stream &quot;D&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; (little endian)</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="number">16</span> &#123;j&#125;&#125;; <span class="comment">// generates stream &quot;C&quot; &quot;D&quot; &quot;A&quot; &quot;B&quot;</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; &#123; <span class="number">8&#x27;b0011_0101</span> &#125;&#125;; <span class="comment">// generates stream &#x27;b1010_1100 (bit reverse)</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="number">4</span> &#123; <span class="number">6&#x27;b11_0101</span> &#125;&#125;; <span class="comment">// generates stream &#x27;b0101_11</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &gt;&gt; <span class="number">4</span> &#123; <span class="number">6&#x27;b11_0101</span> &#125;&#125;; <span class="comment">// generates stream &#x27;b1101_01</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="number">2</span> &#123; &#123; &lt;&lt; &#123; <span class="number">4&#x27;b1101</span> &#125;&#125; &#125;&#125;; <span class="comment">// generates stream &#x27;b1110</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-6.png" alt="Alt text"></p>
<h4 id="casting-固定-强制类型转换"><a href="#casting-固定-强制类型转换" class="headerlink" title="casting  固定(强制类型转换)"></a>casting  固定(强制类型转换)</h4><p>具体操作：</p>
<p><code>type’ (expression)</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">longint</span> a,y;</span><br><span class="line"><span class="keyword">real</span> r;</span><br><span class="line">y=a+<span class="keyword">longint</span>’(r**<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>宽度、符号位等也可以进行固定。</p>
<h4 id="Assignment-赋值"><a href="#Assignment-赋值" class="headerlink" title="Assignment 赋值"></a>Assignment 赋值</h4><p>阻塞赋值、非阻塞赋值</p>
<p>不同的电路描述方式会产生不同的电路：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline1(clk,d,q);</span><br><span class="line">    <span class="keyword">input</span> clk,d;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span> q1,q2,q3;</span><br><span class="line">    <span class="keyword">wire</span> clk,d,q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        q1=d;</span><br><span class="line">        q2=q1;</span><br><span class="line">        q3=q2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> q=q3;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>对应的电路：<br><img src="/2024/02/12/System-Verilog-Notes/image-45.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline1(clk,d,q);</span><br><span class="line">    <span class="keyword">input</span> clk,d;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span> q1,q2,q3;</span><br><span class="line">    <span class="keyword">wire</span> clk,d,q;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        q1&lt;=d;</span><br><span class="line">        q2&lt;=q1;</span><br><span class="line">        q3&lt;=q2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> q=q3;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-46.png" alt="Alt text"></p>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p><code>if else</code>    </p>
<p>注意<strong>if else要讨论清楚所有情况。</strong></p>
<p><code>case</code></p>
<p><code>casez</code><br>忽略z状态</p>
<p><code>casex</code><br>忽略x和z状态</p>
<p>当多个分支同时满足条件时，case只选择第一个分支。(即case存在优先级)</p>
<p><code>unique</code> 和 <code>priority</code>用在分支语句之前</p>
<p><strong>unique</strong>会对分支条件有重叠（overlap）或分支不全的情况进行报警。unique 用于 if-else 或 case 语句，以指示只有一个条件或分支应该为真。如果多个条件或分支同时为真，这通常被视为编码错误，可能会在仿真时产生警告或错误。</p>
<p><strong>priority</strong>确保了条件或分支的评估顺序，即使有多个条件或分支为真，也只有第一个为真的会被执行。<br>priority 有助于防止条件重叠时的不确定行为。</p>
<p>举例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> unique_if;</span><br><span class="line"><span class="comment">//variables declaration</span></span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//initialization</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    b=<span class="number">20</span>;</span><br><span class="line">    c=<span class="number">40</span>;</span><br><span class="line">    <span class="keyword">unique</span> <span class="keyword">if</span> ( a &lt; b ) <span class="built_in">$display</span>(<span class="string">&quot;\t a is less than b&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( a &lt; c ) <span class="built_in">$display</span>(<span class="string">&quot;\t a is less than c&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">$display</span>(<span class="string">&quot;\t a is greater than b and c&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-47.png" alt="Alt text"><br>仿真时报错。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_priority();</span><br><span class="line"><span class="keyword">initial</span> </span><br><span class="line">    <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>;a&lt;<span class="number">4</span>;a++) </span><br><span class="line">    <span class="keyword">priority</span> <span class="keyword">casez</span>(a) <span class="comment">// values 4,5,6,7 </span></span><br><span class="line">        cause a warning </span><br><span class="line">        <span class="number">3&#x27;b00</span>?: <span class="built_in">$display</span>(<span class="string">&quot;0 or 1&quot;</span>); </span><br><span class="line">        <span class="number">3&#x27;b0</span>??: <span class="built_in">$display</span>(<span class="string">&quot;2 or 3&quot;</span>); </span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-48.png" alt="Alt text"></p>
<h4 id="过程块-procedural-statements"><a href="#过程块-procedural-statements" class="headerlink" title="过程块 procedural statements"></a>过程块 procedural statements</h4><p><strong>initial</strong><br>    用途： 指示仿真的开始。可以同时存在多个initial并行。</p>
<p><strong>final</strong><br>类似initial，其中定义的行为在仿真结束后执行，用于在仿真结束后收集信息。同时，<strong>final中不能定义延迟。</strong></p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">begin</span></span><br><span class="line"><span class="built_in">$display</span> (“Final value of Data = %h <span class="string">&quot;, data);</span></span><br><span class="line"><span class="string">data = 1; // even assignments can be done</span></span><br><span class="line"><span class="string">$display (&quot;</span> Final value of Data = %h <span class="string">&quot;, data);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">final $display (&quot;</span>display <span class="keyword">final</span> block <span class="number">1</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">final $display (&quot;</span>display <span class="keyword">final</span> block <span class="number">2</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">final $display (&quot;</span>display <span class="keyword">final</span> block <span class="number">3</span> <span class="string">&quot;);</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-7.png" alt="Alt text"></p>
<p>区别在于，final中不能添加任何delay语句(#delay)   </p>
<p><strong>always</strong><br>在verilog中：<br> always @(*)<br> always @(posedge clk)<br> always @(clk)<br> always  </p>
<p>sv 新增：always_ff&#x2F;always_comb&#x2F;always_latch</p>
<p>SV将组合逻辑、时序逻辑和latch严格区分。  </p>
<p>数字设计时，需要避免latch和组合逻辑环。</p>
<h4 id="Loop-循环"><a href="#Loop-循环" class="headerlink" title="Loop 循环"></a>Loop 循环</h4><p><strong>forever</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">clock1 &lt;= <span class="number">0</span>;</span><br><span class="line">clock2 &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">fork</span></span><br><span class="line">    <span class="keyword">forever</span> #<span class="number">10</span> clock1 = ~clock1;</span><br><span class="line">    #<span class="number">5</span> <span class="keyword">forever</span> #<span class="number">10</span> clock2 = ~clock2;</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>for 循环</strong>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">1024</span>; i=i+<span class="number">1</span>)</span><br><span class="line">…</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>sv和verilog的区别在于，sv可以运行循环控制变量i在循环内部定义(接近c语言的风格)</p>
<p><strong>foreach</strong><br>sv新增，面向对象特性。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">string</span> words [<span class="number">2</span>] = &#x27;&#123; <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> prod [<span class="number">1</span>:<span class="number">8</span>] [<span class="number">1</span>:<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">foreach</span>( words [ j ] )</span><br><span class="line"><span class="built_in">$display</span>( j , words[j] ); <span class="comment">// print each index and value</span></span><br><span class="line">    <span class="keyword">foreach</span>( prod[ k, m ] )</span><br><span class="line">    prod[k][m] = k * m; <span class="comment">// initializ</span></span><br></pre></td></tr></table></figure>

<p>很灵活，可以直接用索引代指变量</p>
<p><strong>while&#x2F;do while</strong></p>
<p><strong>break</strong></p>
<p><strong>repeat</strong></p>
<h4 id="functions-and-tasks-SV的重点"><a href="#functions-and-tasks-SV的重点" class="headerlink" title="functions and tasks(SV的重点)"></a>functions and tasks(SV的重点)</h4><p>task:执行需要时间</p>
<p>function: 被看作瞬时完成，不能有延时操作。</p>
<p>task可以调用function,task不能调用function</p>
<p>function只能有1个返回值，task可以通过output产生多个返回值。task不能写return.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> foo(loo);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] loo;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] goo = zero_count(loo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> [<span class="number">3</span>:<span class="number">0</span>] zero_count;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] in_bus;</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            zero_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i= i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (!in_bus[i])</span><br><span class="line">            zero_count = zero_count +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add_and_inc (<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a,b);</span><br><span class="line">    add_and_inc=a+b+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> add ( <span class="keyword">byte</span> a , b );</span><br><span class="line">    val = a + b ;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    add (<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">$display</span> (val); <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>函数值被看作默认的返回值。</p>
<h4 id="变量的静态和动态-static-automatic"><a href="#变量的静态和动态-static-automatic" class="headerlink" title="变量的静态和动态(static&#x2F;automatic)"></a>变量的静态和动态(static&#x2F;automatic)</h4><p>动态：局部的变量<br>静态：全局共享</p>
<p>task 和 function默认是静态的。</p>
<h4 id="SV-的参数传递"><a href="#SV-的参数传递" class="headerlink" title="SV 的参数传递"></a>SV 的参数传递</h4><p>1.<strong>传值</strong><br>    例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add (<span class="keyword">byte</span> a , b );</span><br><span class="line"><span class="keyword">return</span> a + b ;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>2.<strong>传引用</strong><br>    被传递的参数可以在函数中修改（类似C语言的&amp;augment)  </p>
<p>在变量名前面加上关键字<code>ref</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> argument_passing1;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> sum(<span class="keyword">ref</span> <span class="keyword">int</span> x,y);</span><br><span class="line">    x = x+y;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    y = <span class="number">30</span>;</span><br><span class="line">    z = sum(x,y);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;\tValue of x = %0d&quot;</span>,x);<span class="comment">//50</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;\tValue of y = %0d&quot;</span>,y);<span class="comment">//30</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;\tValue of z = %0d&quot;</span>,z);<span class="comment">//80</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>3.<strong>默认参数</strong></p>
<p>例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> add ( <span class="keyword">int</span> a =<span class="number">1</span>; <span class="keyword">int</span> b; <span class="keyword">int</span> c=<span class="number">3</span>);</span><br><span class="line">… …</span><br><span class="line">    add ( ,<span class="number">2</span>, ); <span class="comment">//equivalent to add (1,2,3);</span></span><br><span class="line">    add ( <span class="number">4</span>,<span class="number">2</span>, ); <span class="comment">//equivalent to add (4,2,3);</span></span><br><span class="line">    add ( ); <span class="comment">//error ; b value missing !</span></span><br></pre></td></tr></table></figure>


<h3 id="quiz-1"><a href="#quiz-1" class="headerlink" title="quiz"></a>quiz</h3><ol>
<li>Why a function cannot call a task?</li>
</ol>
<p>• Because of the timing delays allowed in task; Non-Zero time !</p>
<ol start="2">
<li><p>Tasks not synthesizable ?<br>• Timing delays ! However THEY ARE SYNTHESIZABLE if no timing<br>delays inferred</p>
</li>
<li><p>A function should return a value?<br>• Not necessarily !</p>
</li>
<li><p>Why a task cannot return a value?<br>• Same reason, Timing Delays.</p>
</li>
<li><p>Why a function cannot have delays?<br>• Function caller is waiting for a Zero time event</p>
</li>
<li><p>Why disable statements are not allowed in functions?<br>• A prior disable statement may by-pass return statements at the end of<br>function</p>
</li>
</ol>
<h2 id="System-Verilog-Programming-Basic-II"><a href="#System-Verilog-Programming-Basic-II" class="headerlink" title="System Verilog Programming Basic II"></a>System Verilog Programming Basic II</h2><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>主要用途：用作端口通信。可以在其中实现一些比较复杂的通信协议。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-8.png" alt="Alt text"></p>
<p>driver:驱动端，负责数据的产生</p>
<p>传统方法:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> arb_port (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] grant,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] request,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> reset,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk</span><br><span class="line">    );</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] grant,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] request,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> reset,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk</span><br><span class="line">    );</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] grant,request;</span><br><span class="line">    <span class="keyword">logic</span> clk, reset;</span><br><span class="line">    arb_port a1(<span class="variable">.grant</span>(grant), <span class="variable">.request</span>(request), <span class="variable">.reset</span>(reset), <span class="variable">.clk</span>(clk));</span><br><span class="line">    test t1(<span class="variable">.grant</span>(grant), <span class="variable">.request</span>(request), <span class="variable">.reset</span>(reset), <span class="variable">.clk</span>(clk));</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>


<h3 id="使用interface"><a href="#使用interface" class="headerlink" title="使用interface:"></a>使用interface:</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> simple_bus;</span><br><span class="line">    <span class="keyword">logic</span> req,gnt,start,rdy ;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] mode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] addr,data;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mem_mod ( <span class="keyword">input</span> <span class="keyword">bit</span> clk,simple_bus busa);</span><br><span class="line"><span class="comment">//注意，此时module的输入不止是单一的信号，而是可以包含整个interface</span></span><br><span class="line">    <span class="keyword">logic</span> sel_mem = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        busa<span class="variable">.gnt</span> &lt;= busa<span class="variable">.req</span> &amp; sel_mem;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cpu_mod ( <span class="keyword">input</span> <span class="keyword">bit</span> clk,simple_bus busa);</span><br><span class="line">    <span class="keyword">logic</span> sel_cpu;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        busa<span class="variable">.mode</span> &lt;= &#123;busa<span class="variable">.gnt</span>, busa<span class="variable">.gnt</span>&#125;;</span><br><span class="line">        busa<span class="variable">.req</span> &lt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top_mod1;</span><br><span class="line">    <span class="keyword">logic</span> clk = <span class="number">0</span>;</span><br><span class="line">    simple_bus sb( );</span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line">    cpu_mod1 cpu (clk, sb);</span><br><span class="line">    mem_mod1 mem (clk, sb);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Interface-可以包含端口。"><a href="#Interface-可以包含端口。" class="headerlink" title="Interface 可以包含端口。"></a>Interface 可以包含端口。</h3><h3 id="Modport-对Interface的端口方向进行限制"><a href="#Modport-对Interface的端口方向进行限制" class="headerlink" title="Modport:对Interface的端口方向进行限制"></a>Modport:对Interface的端口方向进行限制</h3><p>modport 同时还可以对信号进行分组。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> simple_bus (<span class="keyword">input</span> <span class="keyword">bit</span> clk) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> req, gnt, start, rdy ; <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] mode;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] addr; <span class="keyword">logic</span> [<span class="number">16</span>:<span class="number">0</span>] data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">modport</span> master ( <span class="keyword">input</span>,req,gnt,clk,mode,addr,<span class="keyword">output</span> data, start,</span><br><span class="line">rdy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">modport</span> slave (<span class="keyword">output</span> req,gnt,mode,addr,<span class="keyword">input</span> data, start, rdy);</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mem (simple_bus mbus);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cpu (simple_bus sbus);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top;</span><br><span class="line">    simple_bus busa();</span><br><span class="line">    mem mem_i (<span class="variable">.mbus</span> (busa<span class="variable">.master</span>));</span><br><span class="line">    cpu cpu_i (<span class="variable">.sbus</span> (busa<span class="variable">.slave</span>));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>


<h3 id="Interface中可以申明或调用task-和-function"><a href="#Interface中可以申明或调用task-和-function" class="headerlink" title="Interface中可以申明或调用task 和 function"></a>Interface中可以申明或调用task 和 function</h3><p>使用<code>import</code>,<code>export</code>来调用task。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-9.png" alt="Alt text"></p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-10.png" alt="Alt text"></p>
<p>区分：<br>import: module调用Interface中的task;<br>export: Interface中调用module中的task.  </p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tlm_sender (tlm_intf<span class="variable">.sender_mp</span> send_port);</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    send_port<span class="variable">.put</span>(<span class="string">&quot;n&quot;</span>);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tlm_receiver (tlm_intf<span class="variable">.receiver_mp</span> receive_port);</span><br><span class="line">    <span class="keyword">task</span> receive_port<span class="variable">.put</span>(<span class="keyword">input</span> <span class="keyword">byte</span> b);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;i got data =%0d&quot;</span>,b);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> tlm_intf();</span><br><span class="line">    <span class="keyword">modport</span> sender_mp(<span class="keyword">import</span> <span class="keyword">task</span> put(<span class="keyword">input</span> <span class="keyword">byte</span> b));<span class="comment">//注意import和export的用法。</span></span><br><span class="line">    <span class="keyword">modport</span> receiver_mp(<span class="keyword">export</span> <span class="keyword">task</span> put(<span class="keyword">input</span> <span class="keyword">byte</span> b));</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line">tlm_intf tlm_int0();</span><br><span class="line">tlm_sender tlm_sender0(tlm_int0<span class="variable">.sender_mp</span>);</span><br><span class="line">tlm_receiver tlm_receiver0(tlm_int0<span class="variable">.receiver_mp</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="带参数的Interface"><a href="#带参数的Interface" class="headerlink" title="带参数的Interface"></a>带参数的Interface</h3><p>Interface中可包含参数，用法和module中的参数一样。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> simple_bus <span class="variable">#(dwidth =32, awidth = 8) ( input bit clk )</span>;</span><br><span class="line">    <span class="keyword">logic</span> req,gnt,start,rdy ;</span><br><span class="line">    <span class="keyword">logic</span> [dwidth :<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">logic</span> [awidth:<span class="number">0</span>] addr;</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>


<h3 id="Virtual-Interface"><a href="#Virtual-Interface" class="headerlink" title="Virtual Interface"></a>Virtual Interface</h3><p>Interface作为一个特殊的类，无法在其他类的定义中进行例化。当在一个类中使用interface时，该interface必须被申明为virtual。<br><img src="/2024/02/12/System-Verilog-Notes/image-21.png" alt="Alt text"><br>virtual interface可以看作指向模块中实例化的interface的一个指针。</p>
<p>用法举例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个interface</span></span><br><span class="line"><span class="keyword">interface</span> my_if(<span class="keyword">input</span> clk, <span class="keyword">input</span> rst_n);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line">   <span class="keyword">logic</span> valid;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个UVM driver.</span></span><br><span class="line"><span class="keyword">class</span> my_driver <span class="keyword">extends</span> uvm_driver;</span><br><span class="line">    <span class="comment">//申明一个virtual interface</span></span><br><span class="line">   <span class="keyword">virtual</span> my_if vif;</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_driver)</span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">      `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;new is called&quot;</span>, UVM_LOW);</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">      `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;build_phase is called&quot;</span>, UVM_LOW);</span><br><span class="line">      <span class="comment">//virtual interface使用前必须被设置，类似指针必须赋值后使用</span></span><br><span class="line">      <span class="comment">//使用get函数，进程在调用时，将&quot;vif&quot;的值赋值给vif。</span></span><br><span class="line">      <span class="keyword">if</span>(!uvm_config_db<span class="variable">#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span></span><br><span class="line">         `uvm_fatal(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;virtual interface must be set for vif!!!&quot;</span>)</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> main_phase(uvm_phase phase);</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   phase<span class="variable">.raise_objection</span>(<span class="keyword">this</span>);</span><br><span class="line">   `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;main_phase is called&quot;</span>, UVM_LOW);</span><br><span class="line">   vif<span class="variable">.data</span> &lt;= <span class="number">8&#x27;b0</span>; </span><br><span class="line">   vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!vif<span class="variable">.rst_n</span>)</span><br><span class="line">      @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)<span class="keyword">begin</span></span><br><span class="line">      @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">      vif<span class="variable">.data</span> &lt;= $urandom_range(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">      vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">      `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;data is drived&quot;</span>, UVM_LOW);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">   vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">   phase<span class="variable">.drop_objection</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_if.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_driver.sv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top_tb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"><span class="keyword">reg</span> rst_n;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] rxd;</span><br><span class="line"><span class="keyword">reg</span> rx_dv;</span><br><span class="line"><span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] txd;</span><br><span class="line"><span class="keyword">wire</span> tx_en;</span><br><span class="line"><span class="comment">//例化两个interface</span></span><br><span class="line">my_if input_if(clk, rst_n);</span><br><span class="line">my_if output_if(clk, rst_n);</span><br><span class="line"></span><br><span class="line">dut my_dut(<span class="variable">.clk</span>(clk),</span><br><span class="line">           <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">           <span class="variable">.rxd</span>(input_if<span class="variable">.data</span>),</span><br><span class="line">           <span class="variable">.rx_dv</span>(input_if<span class="variable">.valid</span>),</span><br><span class="line">           <span class="variable">.txd</span>(output_if<span class="variable">.data</span>),</span><br><span class="line">           <span class="variable">.tx_en</span>(output_if<span class="variable">.valid</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">   clk = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">      #<span class="number">100</span> clk = ~clk;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">   rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">   #<span class="number">1000</span>;</span><br><span class="line">   rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//通过run_test例化了一个&quot;my driver&quot;</span></span><br><span class="line">   run_test(<span class="string">&quot;my_driver&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//设置虚拟端口的指向。使用的是UMV中的config_db操作，通过进程间通信的方式，将&quot;vif&quot;指向input_if</span></span><br><span class="line">   uvm_config_db<span class="variable">#(virtual my_if)::set(null, &quot;uvm_test_top&quot;, &quot;vif&quot;, input_if)</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h3><p>在设计中，顶层模块是一个module,在验证中，为了构建某种仿真环境，设计出program。program的目的是将testbench与DUT独立开来。</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test (<span class="keyword">input</span> clk, <span class="keyword">input</span> [<span class="number">16</span>:<span class="number">1</span>]</span><br><span class="line">    addr, <span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data);</span><br><span class="line">    <span class="keyword">initial</span> ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p>program与module的关系：<br>module中可以例化program,反之program不能例化module</p>
<p>program中不需要always块，例化module，申明interface,或申明其他program。只有initial和methods是允许的。</p>
<h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h3><p>目的：通过Package在不同module之间来共享代码。</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pack;</span><br><span class="line">    <span class="keyword">integer</span> global_counter ;</span><br><span class="line">    <span class="keyword">task</span> incr ;</span><br><span class="line">    … …</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endpackage</span> : pack</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mod1;</span><br><span class="line">    <span class="keyword">import</span> pack::* ;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    global_counter = <span class="number">567</span> ;</span><br><span class="line">    incr(); <span class="comment">// use as if it is locally</span></span><br><span class="line">    declared</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> : mod1</span><br></pre></td></tr></table></figure>

<h3 id="Clocking-block"><a href="#Clocking-block" class="headerlink" title="Clocking block"></a>Clocking block</h3><p>目的：调整数据和时钟的关系，使其满足建立时间和保持时间</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">clocking</span> cb1 @(<span class="keyword">posedge</span> clk); <span class="comment">// clocking block with clocking event</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">10</span>ns <span class="comment">//输入信号在翻转前10ns进行采样</span></span><br><span class="line">    <span class="keyword">output</span> #<span class="number">2</span>ns ; <span class="comment">// default timing skew for input/output，</span></span><br><span class="line">    <span class="comment">//输出信号在翻转后2ns开始输出</span></span><br><span class="line">    <span class="keyword">output</span> data; <span class="comment">// output from the clocking block</span></span><br><span class="line">    <span class="keyword">output</span> sel;</span><br><span class="line"><span class="keyword">endclocking</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-50.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] a0,a2, a3, a4; <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] a1;</span><br><span class="line"><span class="keyword">logic</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">clk=<span class="number">0</span>; <span class="keyword">for</span>( <span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) clk = #<span class="number">5</span> ~clk;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">for</span>( <span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) a1 = #<span class="number">2</span> ~a1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clocking</span> cb @(<span class="keyword">posedge</span> clk);</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">2</span> <span class="keyword">output</span> #<span class="number">3</span>;</span><br><span class="line"><span class="keyword">input</span> #<span class="number">2</span> a1;</span><br><span class="line"><span class="keyword">output</span> a0,a2 , a3 ;</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">negedge</span> a4;</span><br><span class="line"><span class="keyword">endclocking</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    @(cb);</span><br><span class="line">    cb<span class="variable">.a2</span> &lt;= <span class="number">3&#x27;b11</span>;</span><br><span class="line">    cb<span class="variable">.a4</span> &lt;= <span class="number">3&#x27;b10</span>;</span><br><span class="line">    cb<span class="variable">.a3</span> &lt;= a1;</span><br><span class="line">    cb<span class="variable">.a0</span> &lt;= cb<span class="variable">.a1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Race"><a href="#Race" class="headerlink" title="Race"></a>Race</h3><p>Two expressions scheduled to execute at same time, if order<br>of the execution is not determined, race condition occurs !</p>
<p>使用串行仿真器处理并行语言时遇到的困境。</p>
<p>想要避免race,需要理解仿真器对不同操作的<strong>调度顺序</strong></p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-12.png" alt="Alt text"></p>
<h2 id="LEC-8-面向对象设计"><a href="#LEC-8-面向对象设计" class="headerlink" title="LEC 8 面向对象设计"></a>LEC 8 面向对象设计</h2><p>为什么采用面向对象来构建testbench？</p>
<p>1.用于集成一些不同的数据类型。<br>2.提高可重用性，提升效率。<br>3.UVM&#x2F;OVM是基于OOP的。</p>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>类：包含一组数据类型和对应的操作方法(task和function)<br>对象：对象是类的一个例化。</p>
<p>类在定义时不占用内存。当对应的对象被例化时才占用。</p>
<h4 id="HDL与OOP的比较："><a href="#HDL与OOP的比较：" class="headerlink" title="HDL与OOP的比较："></a>HDL与OOP的比较：</h4><p><img src="/2024/02/12/System-Verilog-Notes/image-13.png" alt="Alt text"></p>
<h4 id="一个class的例子："><a href="#一个class的例子：" class="headerlink" title="一个class的例子："></a>一个class的例子：</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet ;</span><br><span class="line"><span class="comment">//data or class properties</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] command;</span><br><span class="line">    <span class="keyword">integer</span> time_requested;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; ERR_OVERFLOW= <span class="number">10</span>, ERR_UNDERFLOW = <span class="number">1123</span>&#125; PCKT_TYPE;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">integer</span> buffer_size = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        command = <span class="number">4&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="comment">// methods</span></span><br><span class="line">    <span class="keyword">task</span> clean();</span><br><span class="line">        command = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> issue_request( <span class="keyword">int</span> delay );</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">integer</span> current_status();</span><br><span class="line">        current_status = status;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h4 id="null类型"><a href="#null类型" class="headerlink" title="null类型"></a>null类型</h4><p>未被初始化的类型默认为null值(类似C++)</p>
<p>对象名被看作是对所分配内存的指针(或句柄(handle))</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> BusTran;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, crc, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">function</span> calc_crc;</span><br><span class="line">        calc_crc=addr^data;</span><br><span class="line">        endfuntion: calc_crc</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> display;</span><br><span class="line">        <span class="built_in">$display</span>(“BusTran: %h”, addr);</span><br><span class="line">    <span class="keyword">endfunction</span>:  display</span><br><span class="line"><span class="keyword">endclass</span>: BusTran</span><br><span class="line"></span><br><span class="line">BusTran b1,b2;</span><br><span class="line">    b1= <span class="keyword">new</span>();<span class="comment">//开辟新的空间</span></span><br><span class="line">    b2=b1;  <span class="comment">//b2指向上一步开辟的空间</span></span><br><span class="line">    b1 = <span class="keyword">new</span>(); <span class="comment">//b1指向新的空间</span></span><br><span class="line">    b1<span class="variable">.addr</span>=<span class="number">32</span>’h42;</span><br><span class="line">    b1<span class="variable">.display</span>();</span><br><span class="line">b2 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>


<p>class 中的方法只有<strong>function</strong>和<strong>task</strong></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line"><span class="keyword">integer</span> command;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">    command = IDLE;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>内建的构造函数命名为new。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> my_class;</span><br><span class="line">    <span class="keyword">integer</span> count ;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span> ();</span><br><span class="line">        count = <span class="number">5</span> ;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">my_class c1 = <span class="keyword">new</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my_class;</span><br><span class="line">    <span class="keyword">integer</span> count ;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">input</span> <span class="keyword">int</span> temp);</span><br><span class="line">        count = temp ;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line">my_class c1 = <span class="keyword">new</span> (<span class="number">44</span>) ;</span><br></pre></td></tr></table></figure>
<p>区分new()和new[]:<br>分别用于类和数组。</p>
<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>用途：在不同对象之间建立联系。相当于class中的公共空间。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        id = count++;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction b1,b2;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    b1=<span class="keyword">new</span>; <span class="comment">//first instance, id=0</span></span><br><span class="line">    b2=<span class="keyword">new</span>; <span class="comment">//second instance, id=1</span></span><br><span class="line">    <span class="built_in">$display</span>(b2<span class="variable">.id</span>, b2<span class="variable">.count</span>);<span class="comment">//1,2;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>也可以定义 static的方法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">function</span> <span class="keyword">int</span> next_id();</span><br><span class="line">        next_id = ++current; <span class="comment">// OK to access static class property</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>对static方法的每次调用都会独立的执行一次该方法。example:</p>
<p>static 方法中的变量仍然是动态的。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> A ;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">task</span> incr();</span><br><span class="line">        <span class="keyword">int</span> j; <span class="comment">//automatic variable</span></span><br><span class="line">        j++;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;J is %d&quot;</span>,j);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> main ;</span><br><span class="line">    A obj_1;</span><br><span class="line">    A obj_2;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;static task with automatic variables&quot;</span>);</span><br><span class="line">        obj_1 = <span class="keyword">new</span>();</span><br><span class="line">        obj_2 = <span class="keyword">new</span>();</span><br><span class="line">        obj_1<span class="variable">.incr</span>();</span><br><span class="line">        obj_2<span class="variable">.incr</span>();</span><br><span class="line">        obj_1<span class="variable">.incr</span>();</span><br><span class="line">        obj_2<span class="variable">.incr</span>();</span><br><span class="line">        A::incr();</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Each call to task will create a separate</span></span><br><span class="line"><span class="string">        copy of &#x27;j&#x27; and increment it&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p>result：<img src="/2024/02/12/System-Verilog-Notes/image-14.png" alt="Alt text">  </p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>内建语句，用于表示当前的对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>使用关键词 <code>extends</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">1024</span>], crc;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BadTr <span class="keyword">extends</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> bad_crc;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">BadTr bt;</span><br><span class="line">bt = <span class="keyword">new</span>;</span><br><span class="line">bt<span class="variable">.src</span> = <span class="number">42</span>;</span><br><span class="line">bt<span class="variable">.bad_crc</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>继承使得一个类可以在父类的基础特性上增加新的特性。<br><img src="/2024/02/12/System-Verilog-Notes/image-51.png" alt="Alt text"></p>
<p>使用关键词<code>super</code>调用父类的方法。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data[<span class="number">1024</span>], crc;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> calc_crc();</span><br><span class="line">        crc = src ^ dst ^ data<span class="variable">.xor</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BadTr <span class="keyword">extends</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> bad_crc;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> calc_crc();</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.calc_crc</span>();</span><br><span class="line">    <span class="keyword">if</span> (bad_crc) crc = ~crc;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h3 id="虚函数和虚方法-virtual"><a href="#虚函数和虚方法-virtual" class="headerlink" title="虚函数和虚方法(virtual)"></a>虚函数和虚方法(virtual)</h3><p>用途:用于构建模板，只有被继承时才可以例化。</p>
<p>虚函数在被重构后产生多态，不同继承对象调用同一函数时，产生不同的效果。</p>
<p>使用虚函数的好处</p>
<ol>
<li>灵活性：允许在运行时根据对象的实际类型调用正确的方法。</li>
<li>可扩展性：可以在不修改现有代码的情况下，通过添加新的派生类来扩展功能。</li>
<li>封装：允许派生类修改或扩展基类的行为，而不影响使用基类引用的代码。</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> BasePacket;</span><br><span class="line">    <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> B = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> printA;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;BasePacket::A is %d&quot;</span>, A);</span><br><span class="line">    <span class="keyword">endfunction</span> : printA</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> printB;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;BasePacket::B is %d&quot;</span>, B);</span><br><span class="line">    <span class="keyword">endfunction</span> : printB</span><br><span class="line"><span class="keyword">endclass</span> : BasePacket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> My_Packet <span class="keyword">extends</span> BasePacket;</span><br><span class="line">    <span class="keyword">int</span> A = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> B = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> printA;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;My_Packet::A is %d&quot;</span>, A);</span><br><span class="line">    <span class="keyword">endfunction</span>: printA</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> printB;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;My_Packet::B is %d&quot;</span>, B);</span><br><span class="line">    <span class="keyword">endfunction</span> : printB</span><br><span class="line"><span class="keyword">endclass</span> : My_Packet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Program test_virtual_method()</span><br><span class="line"></span><br><span class="line">BasePacket P1 = <span class="keyword">new</span>;</span><br><span class="line">My_Packet P2 = <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    P1<span class="variable">.printA</span>; <span class="comment">// displays &#x27;BasePacket::A is 1&#x27;</span></span><br><span class="line">    P1<span class="variable">.printB</span>; <span class="comment">// displays &#x27;BasePacket::B is 2&#x27;</span></span><br><span class="line">    P1 = P2; <span class="comment">// P1 has a handle to a My_packet object ，一个upcasting操作</span></span><br><span class="line">    P1<span class="variable">.printA</span>; <span class="comment">// displays &#x27;BasePacket::A is 1&#x27;</span></span><br><span class="line">    P1<span class="variable">.printB</span>; <span class="comment">// displays &#x27;My_Packet::B is 4&#x27; – latest derived method</span></span><br><span class="line">    P2<span class="variable">.printA</span>; <span class="comment">// displays &#x27;My_Packet::A is 3&#x27;</span></span><br><span class="line">    P2<span class="variable">.printB</span>; <span class="comment">// displays &#x27;My_Packet::B is 4&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理解：虚函数运行多态，当基类被upcasting给派生类后，可以调用派生类的方法。相反，如果不是虚函数，则还是调用原来自己有的方法。</p>
<h3 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h3><p>upcasting: 将子类的对象赋值给父类</p>
<p>downcasting: 不合法的操作。子类被看作是独立于父类的对象。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> father_class;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] fsrc=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">input</span> <span class="keyword">string</span> prefix=<span class="string">&quot;f* &quot;</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%sfather_class:fsrc=%d&quot;</span>,prefix,fsrc);</span><br><span class="line">    <span class="keyword">endfunction</span> </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> child_class <span class="keyword">extends</span> father_class;</span><br><span class="line">    <span class="keyword">bit</span> csrc=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">input</span> <span class="keyword">string</span> prefix=<span class="string">&quot;c* &quot;</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%schild_class:csrc=%b&quot;</span>,prefix,csrc);</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.display</span>(prefix);</span><br><span class="line">    <span class="keyword">endfunction</span> </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> test_cast();</span><br><span class="line">    father_class fhandler;</span><br><span class="line">    child_class chandler;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//Construct childclass extended object</span></span><br><span class="line">        chandler=<span class="keyword">new</span>(); </span><br><span class="line">        <span class="comment">//Base handle points to extended obj </span></span><br><span class="line">        fhandler=chandler;  <span class="comment">//父给子是合法的。</span></span><br><span class="line">        <span class="comment">// Display variable in base classCalls</span></span><br><span class="line">        <span class="built_in">$display</span>(fhandler<span class="variable">.fsrc</span>); </span><br><span class="line">        fhandler<span class="variable">.display</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_cast();</span><br><span class="line">    father_class fhandler;</span><br><span class="line">    child_class chandler;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//Construct childclass extended object</span></span><br><span class="line">        fhandler =<span class="keyword">new</span>(); </span><br><span class="line">        <span class="comment">//Base handle points to extended obj </span></span><br><span class="line">        Chandler= fhandler; </span><br><span class="line">        <span class="comment">// Display variable in base classCalls</span></span><br><span class="line">        <span class="built_in">$display</span>(fhandler<span class="variable">.fsrc</span>); </span><br><span class="line">        fhandler<span class="variable">.display</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>产生编译错误：</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-52.png" alt="Alt text"></p>
<h2 id="LEC9-跨进程同步与通信"><a href="#LEC9-跨进程同步与通信" class="headerlink" title="LEC9 跨进程同步与通信"></a>LEC9 跨进程同步与通信</h2><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>与进程类似，不同之处在于线程是进程的一个更小单位。线程共享内存资源。</p>
<h3 id="SV中的过程："><a href="#SV中的过程：" class="headerlink" title="SV中的过程："></a>SV中的过程：</h3><p>一个过程块中的代码可以被独立看作一个线程。<br>如：</p>
<p>initial<br>always<br>final<br>fork … join  (创建并行语句)<br>task&#x2F;function<br>assign </p>
<h4 id="begin-…-end"><a href="#begin-…-end" class="headerlink" title="begin … end"></a>begin … end</h4><p> 两种赋值方式：阻塞赋值和非阻塞赋值。非阻塞赋值可以看作是并行的。</p>
<h4 id="fork-join"><a href="#fork-join" class="headerlink" title="fork join"></a>fork join</h4><p> example:<br> <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">module</span> inline_ tb;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>: <span class="number">0</span>] data_ bus;</span><br><span class="line"><span class="comment">// instance of DUT</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">        data_bus = <span class="number">8&#x27;b00</span>;</span><br><span class="line">        #<span class="number">10</span> data_bus = <span class="number">8&#x27;h45</span>;</span><br><span class="line">        #<span class="number">20</span> <span class="keyword">repeat</span> (<span class="number">10</span>) #<span class="number">10</span> data_bus = data_bus + <span class="number">1</span>;</span><br><span class="line">        #<span class="number">25</span> <span class="keyword">repeat</span> (<span class="number">5</span>) #<span class="number">20</span> data_bus = data_bus &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        #<span class="number">140</span> data_bus = <span class="number">8&#x27;h0f</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>SV中新增的特性：<br>fork join_any 和 fork join_none<br><img src="/2024/02/12/System-Verilog-Notes/image-16.png" alt="Alt text"></p>
<p>join_any:父进程阻塞，直到fork中的任意一个线程结束(exit(0));</p>
<p>join_none:父进程不管子进程是否结束，继续执行。<br>需要注意的是：fork join_none创建的子进程只会被调度，而不会被执行。除非下一个事件发生。</p>
<p>如:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_fork_joinnone;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;First Block \n&quot;</span>);<span class="comment">//不会被执行</span></span><br><span class="line">    # <span class="number">20</span>ns;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Second Block \n&quot;</span>);<span class="comment">//不会被执行</span></span><br><span class="line">    # <span class="number">30</span>ns;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join_none</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;continue main process&quot;</span>);</span><br><span class="line">    <span class="comment">//#0 $display(&quot;finish for_join&quot;); 除非加上这句。</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p>使用fork join创建多线程时，需要注意变量的值的变化：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_join_none_var;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; <span class="number">3</span>;j++ )</span><br><span class="line">        <span class="comment">//automatic int k=j;</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">automatic</span> <span class="keyword">int</span> k=j;</span><br><span class="line">            <span class="built_in">$display</span>(k);</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">        #<span class="number">0</span> <span class="built_in">$display</span>(<span class="string">&quot;finish_forjoin&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-17.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_join_none_var;</span><br><span class="line">    <span class="keyword">int</span> k,j;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; <span class="number">3</span>;j++ ) <span class="keyword">begin</span></span><br><span class="line">            k=j;</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="built_in">$display</span>(k);</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">0</span> <span class="built_in">$display</span>(<span class="string">&quot;finish_forjoin&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-55.png" alt="Alt text"><br>    二者的区别在于automic关键字</p>
<p>辨析：任务或函数被声明为 automatic 时，每次调用都会在堆栈上创建新的存储空间。这意味着每个调用都有自己的局部变量副本，这些变量在调用之间是独立的。这种行为对于递归调用和在并发进程中调用任务或函数非常重要，因为它防止了不同调用之间的数据冲突。</p>
<p>SV中，线程是被动态构造出来的。</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="wait-事件触发。"><a href="#wait-事件触发。" class="headerlink" title="wait: 事件触发。"></a>wait: 事件触发。</h4><p>使用<strong>wait fork</strong>确保所有的子进程都被执行完毕:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> do_test;</span><br><span class="line"><span class="comment">//begin</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        exec1();</span><br><span class="line">        exec2();</span><br><span class="line">        <span class="keyword">join_any</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        exec3();</span><br><span class="line">        exec4();</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    <span class="keyword">wait</span> <span class="keyword">fork</span>;</span><br><span class="line"><span class="comment">//end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>


<p><strong>wait_order()</strong>:指定事件的发生顺序。</p>
<h4 id="disable"><a href="#disable" class="headerlink" title="disable"></a>disable</h4><p>使用disable结束特定的线程。</p>
<h4 id="EVENTS"><a href="#EVENTS" class="headerlink" title="EVENTS"></a>EVENTS</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">event</span> e1;</span><br></pre></td></tr></table></figure>
<p>event被看作是一种<strong>数据类型</strong>，但其本身没有数据值，仅用作同步信号。可以用作进程或线程之间通信的手段。一个进程可以<strong>等待（wait）</strong>一个事件，而另一个进程可以<strong>触发（trigger）</strong>这个事件。</p>
<p><code>@</code>操作符用于<strong>等待</strong>某个事件发生，当使用<code>@</code>操作符后的进程被阻塞，直到相应的event被触发。</p>
<p><code>-&gt;</code>和<code>-&gt;&gt;</code>用于触发事件，其区别在于前者是阻塞的，后者是非阻塞的。<br>使用 <code>-&gt; </code>触发事件时，事件会立即被触发。这意味着在当前时间点，所有等待该事件的进程都会被唤醒。<br>使用 <code>-&gt;&gt;</code> 时，事件的触发会被安排在当前时间点之后的最近的未来时间点。这是一种非阻塞触发，它允许当前进程继续执行，而不是立即切换到等待该事件的进程。</p>
<p>需要注意的是，某个事件的触发必须在等待之后，而不是之前。否则对应的进程无法被调度。</p>
<h5 id="example"><a href="#example" class="headerlink" title="example:"></a>example:</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> p_event;</span><br><span class="line"><span class="keyword">event</span> ev;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">fork</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">wait</span>(ev<span class="variable">.triggered</span>)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            @(ev)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block2&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            -&gt;ev;</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;trigger ev&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            @(ev)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block3&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">wait</span>(ev<span class="variable">.triggered</span>)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block4&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">join</span> </span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-18.png" alt="Alt text"></p>
<h5 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h5><p>block2触发但是1没触发。说明@的机制是串行的，虽然写在fork中，但是并不能真的并行。实际上，同一个fork制造的并行语句<code>@(ev)</code>和<code>-&gt;ev;</code>构成了一种竞争(race)，同一个时刻内事件到底是先触发还是先观测，构成了一种<strong>冲突</strong>。</p>
<p>在 SystemVerilog 或任何并发编程环境中，”race condition”（竞争条件）是指两个或多个进程（或线程）在访问共享资源时，最终结果依赖于进程执行的精确时序或顺序。当进程以不可预测的方式相互干扰时，就会发生竞争条件，这可能导致不一致或错误的行为。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享变量</span></span><br><span class="line"><span class="keyword">int</span> shared_var;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 1</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    shared_var = shared_var + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 2</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    shared_var = shared_var + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，最终 shared_var 的值取决于两个进程执行的相对时序，这就是一个竞争条件。使用同步机制（如信号量）可以解决这个问题。(见下节)</p>
<h5 id="triggered机制"><a href="#triggered机制" class="headerlink" title="triggered机制"></a>triggered机制</h5><p> SystemVerilog 中，每个 event 类型的对象都有一个名为 triggered 的内置属性。这个属性用于检查事件是否已经被触发。</p>
<p>triggered 属性的作用：</p>
<ol>
<li>状态检查：triggered 属性返回一个布尔值，指示自上次检查以来事件是否被触发。如果事件被触发，它返回 true；否则返回 false。</li>
<li>重置行为：一旦 triggered 属性被读取，事件的触发状态就会被重置。这意味着如果你再次检查 triggered 属性，除非事件在此期间再次被触发，否则它将返回 false。</li>
</ol>
<h5 id="event之间可以相互赋值。"><a href="#event之间可以相互赋值。" class="headerlink" title="event之间可以相互赋值。"></a>event之间可以相互赋值。</h5><p>当一个事件被赋值给另一个时，原来的事件不会再被触发执行。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_merge_event;</span><br><span class="line">    <span class="keyword">event</span> E1,E2,E3;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        E2 = E1;</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            T1: <span class="keyword">begin</span></span><br><span class="line">                @ E1;</span><br><span class="line">                <span class="built_in">$display</span>(“unblock T1”);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            T2: <span class="keyword">begin</span></span><br><span class="line">                @ E2;</span><br><span class="line">                <span class="built_in">$display</span>(“unblock T2”);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            T3: <span class="keyword">begin</span> </span><br><span class="line">                @ E3;</span><br><span class="line">                <span class="built_in">$display</span>(“unblock T3”);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            T4: <span class="keyword">begin</span> </span><br><span class="line">                E2 = E3;</span><br><span class="line">                -&gt; E3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>理解：当一个进程被阻塞，等待某个event被触发时，如果原本的envent被赋值给了另一个event，则原来的envent永远不会被触发，对应的进程一直处于阻塞状态。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-19.png" alt="Alt text"></p>
<h4 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore  信号量"></a>Semaphore  信号量</h4><p>信号量（semaphores）是一种同步机制，用于控制对共享资源的访问，特别是在并发环境中。信号量主要用于解决竞争条件，确保在任何给定时间只有一个特定数量的进程可以访问共享资源。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>互斥访问：信号量可以确保对共享资源的互斥访问，防止多个进程同时修改同一资源。<br>控制资源访问：可以限制同时访问某个资源的进程数量，这对于管理有限资源（如内存、文件句柄等）非常有用。</p>
<h5 id="SV中信号量的定义："><a href="#SV中信号量的定义：" class="headerlink" title="SV中信号量的定义："></a>SV中信号量的定义：</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> semaphore;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> keyCount = <span class="number">0</span>);</span><br><span class="line"><span class="comment">//keycount specifies number of keys initially allocated</span></span><br><span class="line"><span class="comment">//default 0</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> put(<span class="keyword">int</span> keyCount = <span class="number">1</span>);</span><br><span class="line"><span class="comment">//returns specified number of keys to semaphore waiting</span></span><br><span class="line"><span class="comment">//process can grab these keys,</span></span><br><span class="line"><span class="comment">//default 1</span></span><br><span class="line"><span class="keyword">task</span> get(<span class="keyword">int</span> keyCount = <span class="number">1</span>);</span><br><span class="line"><span class="comment">//if specified number of keys are not available, process blocks !</span></span><br><span class="line"><span class="comment">//default 1</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> try_get(<span class="keyword">int</span> keyCount = <span class="number">1</span>);</span><br><span class="line"><span class="comment">//if specified number of keys available, method returns 1 and</span></span><br><span class="line"><span class="comment">//execution continues, if not, method returns 0.</span></span><br><span class="line"><span class="comment">//default 1</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>new用于构造一个新的信号量。<br>get相当于C语言中的semwait()<br>put相当于C语言中的semsignal()</p>
<h5 id="example-1"><a href="#example-1" class="headerlink" title="example:"></a>example:</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> semaphore_ex;</span><br><span class="line">    semaphore semBus = <span class="keyword">new</span>(<span class="number">1</span>);<span class="comment">//构造一个新的信号量，初始值为1，代表只有一个资源。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">fork</span></span><br><span class="line">                agent(<span class="string">&quot;AGENT 0&quot;</span>,<span class="number">5</span>);</span><br><span class="line">                agent(<span class="string">&quot;AGENT 1&quot;</span>,<span class="number">20</span>);</span><br><span class="line">            <span class="comment">// 使用fork 构造并行，使2个函数抢占同一个资源。</span></span><br><span class="line">            <span class="keyword">join</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> <span class="keyword">automatic</span> agent(<span class="keyword">string</span> name, <span class="keyword">integer</span> nwait);</span><br><span class="line">        <span class="keyword">integer</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">4</span>; i ++ ) <span class="keyword">begin</span></span><br><span class="line">            semBus<span class="variable">.get</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;[%0d] Lock semBus for %s&quot;</span>, <span class="built_in">$time</span>,name);</span><br><span class="line">            <span class="variable">#(nwait)</span>;</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;[%0d] Release semBus for %s&quot;</span>, <span class="built_in">$time</span>,name);</span><br><span class="line">            semBus<span class="variable">.put</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="variable">#(nwait)</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-20.png" alt="Alt text"></p>
<h4 id="Mailbox"><a href="#Mailbox" class="headerlink" title="Mailbox"></a>Mailbox</h4><p>邮箱，用于进行进程中的数据通信。相当于C中的pipe。  邮箱（Mailbox）是一种用于进程间通信的同步机制。它允许一个进程向邮箱发送（put）消息，而另一个或多个进程可以从邮箱接收（get）这些消息。邮箱在并发编程中非常有用，特别是当需要在不同进程间安全地传递数据时。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-56.png" alt="Alt text"><br>可以看作是一个FIFO。</p>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> mailbox <span class="variable">#(type T = dynamic_singular_type)</span> ;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> bound = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// mail box constructor, optionally specifies the max size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> num();</span><br><span class="line">    <span class="comment">// returns the number of messages currently in mailbox</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> put( T message);</span><br><span class="line">    <span class="comment">// places a message in mailbox; blocks if mailbox full</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> try_put( T message);</span><br><span class="line">    <span class="comment">// places a message in mailbox; returns 0 if mailbox full</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> get( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">// retrieves message from mailbox; blocks if mailbox empty; error if type mismatch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> try_get( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">// retrieves message from mailbox; returns 0/+1/-1; empty/success/type mismatch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> peek( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">// copies message from mailbox; blocks if mailbox empty; error if type mismatch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> try_peek( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">//copies message from mailbox; returns 0/+1/-1; empty/success/type mismatch</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h5 id="example-2"><a href="#example-2" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_mailbox1 ;</span><br><span class="line">    mailbox <span class="variable">#(string) my_mailbox = new(4)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (my_mailbox) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">fork</span></span><br><span class="line">                put_data();</span><br><span class="line">                get_data();</span><br><span class="line">            <span class="keyword">join</span> </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> get_data();</span><br><span class="line">        <span class="keyword">string</span> rdata;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) <span class="keyword">begin</span></span><br><span class="line">                #<span class="number">2</span>;</span><br><span class="line">                my_mailbox<span class="variable">.get</span> (rdata);</span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">&quot;Reading Data %s @time %d&quot;</span>,rdata, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> put_data();</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">string</span> t;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) <span class="keyword">begin</span></span><br><span class="line">                #<span class="number">2</span>;</span><br><span class="line">                <span class="built_in">$sformat</span>(t,<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">                my_mailbox<span class="variable">.put</span>(t);</span><br><span class="line">                my_mailbox<span class="variable">.put</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;Writing Data %d @time %d&quot;</span>,i, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-57.png" alt="Alt text"></p>
<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><ol>
<li>阻塞行为：get 方法在等待消息时会阻塞进程。如果需要非阻塞行为，可以使用 try_get 或 get_nb 方法。</li>
<li>数据类型：邮箱可以传递任何类型的数据，但发送者和接收者必须对如何解释数据达成一致。</li>
<li>同步和异步：邮箱提供了一种同步机制，但它也可以用于异步通信，取决于如何使用 get 和 put 方法。</li>
</ol>
<h4 id="Semaphore和Mailbox的比较"><a href="#Semaphore和Mailbox的比较" class="headerlink" title="Semaphore和Mailbox的比较"></a>Semaphore和Mailbox的比较</h4><pre><code>1. 目的：信号量用于控制资源访问（主要是互斥），而邮箱用于数据传递。
2. 机制：信号量通过计数来控制资源访问，邮箱通过存储和传递消息来实现通信。
3. 数据处理：信号量不处理数据，邮箱则用于具体的数据传递。
4. 阻塞条件：在信号量中，进程阻塞是因为没有可用资源；在邮箱中，进程阻塞是因为没有消息可读。
</code></pre>
<h2 id="Assertions-断言"><a href="#Assertions-断言" class="headerlink" title="Assertions 断言"></a>Assertions 断言</h2><h3 id="什么是assertion"><a href="#什么是assertion" class="headerlink" title="什么是assertion?"></a>什么是assertion?</h3><p>一些检查性的代码，可以用于检测代码的功能覆盖率，做形式化验证等。assertion用于验证设计的行为是否符合预期。断言主要用于动态验证，即在仿真运行时检查特定的条件或属性。它们是确保设计符合其规范的关键组成部分，特别是在复杂的硬件设计和验证过程中。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-22.png" alt="Alt text"></p>
<h4 id="断言的用途"><a href="#断言的用途" class="headerlink" title="断言的用途"></a>断言的用途</h4><pre><code>1. 检测错误：在设计早期发现错误，如逻辑错误、时序问题。例如FIFO的读空写满，FSM一些非法状态的跳转，协议的握手等。
2.文档化设计意图：断言可以作为设计意图的一部分，帮助其他工程师理解代码的预期行为。
2. 提高验证覆盖率：使用断言可以更全面地验证设计，确保覆盖各种边缘情况。
3. 减少调试时间：当断言失败时，它们提供了关于错误位置和原因的即时反馈。
</code></pre>
<h4 id="example-3"><a href="#example-3" class="headerlink" title="example:"></a>example:</h4><p>检查a的上升沿的3个时钟周期内，b是否到达上升沿。<br><strong>verilog 的写法：</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> a) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">repeat</span> (<span class="number">1</span>) @(<span class="keyword">posedge</span> clk);</span><br><span class="line">    <span class="keyword">fork</span>： a_to_b</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> b)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;SUCCESS： b arrived in time\n&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">disable</span> a_to_b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">repeat</span> (<span class="number">3</span>) @(<span class="keyword">posedge</span> clk);</span><br><span class="line">            <span class="built_in">$display</span></span><br><span class="line">            (<span class="string">&quot;ERROR：b did not arrive in time\n&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">disable</span> a_to_b;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">join</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>assertion的写法：</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a_to_b_chk：</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span></span><br><span class="line">@(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(a) |-&gt; ##[<span class="number">1</span>：<span class="number">3</span>] <span class="built_in">$rose</span>(b);</span><br></pre></td></tr></table></figure>

<h3 id="Assertion-Based-Verification"><a href="#Assertion-Based-Verification" class="headerlink" title="Assertion Based Verification"></a>Assertion Based Verification</h3><p>对于时序检查很有用 ，同时可以检查功能覆盖率</p>
<p>例，宏定义</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test();</span><br><span class="line">…</span><br><span class="line"><span class="meta">`<span class="keyword">ifndef</span> NO_INLINED_ASSERTION</span></span><br><span class="line">    st_hold: <span class="keyword">assert</span> <span class="keyword">property</span>( @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    (!reset &amp;&amp; (!st_in &amp;&amp; ready_in))</span><br><span class="line">    |-&gt; ##<span class="number">1</span> (st_in [*<span class="number">1</span>:$]) ##<span class="number">0</span> accepted_in)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">$display</span>(“st_in did <span class="keyword">not</span> hold till accepted_in”);</span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Assertion-库"><a href="#Assertion-库" class="headerlink" title="Assertion 库"></a>Assertion 库</h3><p>Open Verification Library (OVL)<br>Formal Property Language Sugar<br>OpenVera<br>SystemVerilog Assertions  </p>
<p>Assertion优缺点：</p>
<p>1.更容易DEBUG<br>2.可以和C联用<br>3.设计意图可以更好体现</p>
<p>会降低仿真速度。</p>
<h3 id="Assertion的分类："><a href="#Assertion的分类：" class="headerlink" title="Assertion的分类："></a>Assertion的分类：</h3><p><strong>即时断言（Immediate Assertions）：</strong><br>    类似组合逻辑<br>    在表达式求值后立即检查条件。<br>    如果条件为假，则断言失败。<br>    通常用于检查在特定代码点必须为真的条件。</p>
<p><strong>并发断言（Concurrent Assertions）:</strong><br>    类似时序逻辑<br>    在仿真过程中连续检查条件。<br>    使用序列（sequence）和属性（property）来描述复杂的时序行为。<br>    适用于验证设计的时序特性。<br><img src="/2024/02/12/System-Verilog-Notes/image-23.png" alt="Alt text"></p>
<h4 id="Immediate-Assertions举例："><a href="#Immediate-Assertions举例：" class="headerlink" title="Immediate Assertions举例："></a>Immediate Assertions举例：</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">assertion_label : <span class="keyword">assert</span> (expression)</span><br><span class="line">    pass block code;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fail block code;<span class="comment">//0,x,z</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> assert_immediate();</span><br><span class="line">    <span class="keyword">reg</span> clk, grant, request;</span><br><span class="line">    <span class="keyword">time</span> current_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        grant = <span class="number">0</span>;</span><br><span class="line">        request = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">4</span> request = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">4</span> grant = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">4</span> request = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">4</span> <span class="built_in">$finish</span>; </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">1</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (grant == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            CHECK_REQ_WHEN_GNT : <span class="keyword">assert</span> (grant &amp;&amp; request) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">&quot;Seems to be working as expected&quot;</span>);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                current_time = <span class="built_in">$time</span>;</span><br><span class="line">                #<span class="number">1</span> <span class="built_in">$error</span>(<span class="string">&quot;assert failed at time %0t&quot;</span>, current_time);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-24.png" alt="Alt text"><br>绿色三角：assertion通过<br>红色三角：assertion失败</p>
<h5 id="SV的调度顺序"><a href="#SV的调度顺序" class="headerlink" title="SV的调度顺序"></a>SV的调度顺序</h5><p><img src="/2024/02/12/System-Verilog-Notes/image-25.png" alt="Alt text">  </p>
<p><strong>preponed</strong>: 这个阶段发生在仿真时间步的最开始，进行变量的取值。<br><strong>observed</strong>:在这个阶段，可以观察到所有信号和变量的状态，但不应该产生任何新的活动或更改状态。这主要用于监控和检查目的。<br><strong>reactive</strong>:在这个阶段，可以根据之前阶段的观察结果做出反应。(pass&#x2F;fail)</p>
<p><strong>Active Phase</strong>：在这个阶段执行大部分代码，包括非阻塞赋值的右侧表达式和大多数程序语句。</p>
<p><strong>Inactive Phase</strong>：在这个阶段，非阻塞赋值的左侧被更新。</p>
<p><strong>NBA (Non-Blocking Assignment) Update Phase</strong>：在这个阶段，所有非阻塞赋值的更新发生。</p>
<p><strong>Preponed Phase</strong>：这是一个特殊的阶段，用于处理一些特殊的建模需求，如在所有其他活动之前读取信号的最终值。</p>
<p><strong>Observed Phase</strong>：在这个阶段，可以观察到所有赋值的结果，但不允许更改任何状态。</p>
<p><strong>Reactive Phase</strong>：在这个阶段，可以根据之前阶段的观察结果来做出反应，如调整内部状态或发出新的输出。</p>
<p><strong>Postponed Phase</strong>：这是仿真时间步的最后阶段，通常用于处理仿真结束等特殊情况。</p>
<h4 id="并发断言-Concurrent-assertions："><a href="#并发断言-Concurrent-assertions：" class="headerlink" title="并发断言 Concurrent assertions："></a>并发断言 Concurrent assertions：</h4><h5 id="example-4"><a href="#example-4" class="headerlink" title="example:"></a>example:</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> request</span><br><span class="line">    Req;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> acknowledge</span><br><span class="line">    ##[<span class="number">1</span>:<span class="number">2</span>] Ack;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> handshake;</span><br><span class="line">    @(<span class="keyword">posedge</span> Clock) request |-&gt; acknowledge;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span> (handshake);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-58.png" alt="Alt text"><br>构造sequence和property,之后用assert来检查。</p>
<h3 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> name_of_sequence;</span><br><span class="line">    &lt;test expression&gt;;</span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>
<p>sequence 用于描述一系列事件发生的顺序。它定义了一组在时间上相关的条件，这些条件必须按特定的顺序发生。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> seq_A_before_B;</span><br><span class="line">    A ##<span class="number">1</span> B;</span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>

<h4 id="时序检查"><a href="#时序检查" class="headerlink" title="时序检查"></a>时序检查</h4><p>两个井号代表一个时钟周期。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">##<span class="number">3</span> <span class="comment">//3个clock</span></span><br><span class="line"></span><br><span class="line">req ##<span class="number">1</span> gnt ##<span class="number">1</span> !req</span><br><span class="line"><span class="comment">//req should be trueon the current clock tick</span></span><br><span class="line"><span class="comment">//gnt should be true on the subsequent clock tick,</span></span><br><span class="line"><span class="comment">//req shall be false on the next clock tick after that</span></span><br></pre></td></tr></table></figure>

<h5 id="example-5"><a href="#example-5" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_clk_dly;</span><br><span class="line">    <span class="keyword">reg</span> a,b,clk;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">        clk=<span class="number">1&#x27;b0</span>; a=<span class="number">1&#x27;b0</span>;b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">1</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">3</span> <span class="keyword">begin</span></span><br><span class="line">            a=<span class="number">1&#x27;b0</span>; b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        #<span class="number">5</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">7</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">9</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">11</span> b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">13</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">15</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">17</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">21</span> b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">23</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">25</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">27</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">29</span> b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">31</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">1</span> clk=!clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sequence</span> s1;</span><br><span class="line">        @(<span class="keyword">posedge</span> clk) a ##<span class="number">2</span> b;</span><br><span class="line">    <span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">property</span> p1;</span><br><span class="line">        s1;</span><br><span class="line">    <span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">    assertion1: <span class="keyword">assert</span> <span class="keyword">property</span>(p1);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-59.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:<span class="number">3</span>] c;</span><br><span class="line">    <span class="comment">//The sequence requires that c occurs 0,1,2 or 3 cycles after b</span></span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:$] c;</span><br><span class="line">    <span class="comment">//The sequence requires that c occurs 0,1,2… or infinite cycles after b</span></span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>

<h4 id="重复-repetition"><a href="#重复-repetition" class="headerlink" title="重复(repetition)"></a>重复(repetition)</h4><h5 id="consecutive-repetition"><a href="#consecutive-repetition" class="headerlink" title="consecutive repetition"></a>consecutive repetition</h5><p>consecutive 重复指的是事件必须连续发生，没有间隔。<br>用法：使用简单的重复操作符（如 [*n]）表示连续重复。</p>
<h6 id="example-6"><a href="#example-6" class="headerlink" title="example"></a>example</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a ##<span class="number">1</span> b ##<span class="number">1</span> b ##<span class="number">1</span> b ##<span class="number">1</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment">//can be writen as:</span></span><br><span class="line">a ##<span class="number">1</span> b[*<span class="number">3</span>] ##<span class="number">1</span> c</span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p21;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(start) |-&gt; ##<span class="number">2</span> (a[*<span class="number">3</span>]) ##<span class="number">2</span> stop ##<span class="number">1</span> !stop;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a21:<span class="keyword">assert</span> <span class="keyword">property</span>(p21);</span><br></pre></td></tr></table></figure>
<h5 id="Goto-Repetition"><a href="#Goto-Repetition" class="headerlink" title="Goto Repetition"></a>Goto Repetition</h5><p>goto 重复允许在重复的事件之间有间隔，但一旦开始，后续事件必须连续发生。<br>用法：使用 -&gt; 操作符表示 goto 重复。<br><img src="/2024/02/12/System-Verilog-Notes/image-28.png" alt="Alt text"><br>中间会有2到10个b的高电平，但不要求这些电平连续。但b的最后一个高电平一定和c连续。</p>
<h6 id="example-7"><a href="#example-7" class="headerlink" title="example"></a>example</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p25;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(start) |-&gt; ##<span class="number">2</span> (a[-&gt;<span class="number">3</span>]) ##<span class="number">1</span> stop;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a25: <span class="keyword">assert</span> <span class="keyword">property</span>(p25);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-63.png" alt="Alt text"><br>a的3个上升沿后，stop没有在下一个周期立刻上升，故断言失败。</p>
<h5 id="Nonconsecutive-Repetition"><a href="#Nonconsecutive-Repetition" class="headerlink" title="Nonconsecutive Repetition"></a>Nonconsecutive Repetition</h5><p>nonconsecutive 重复允许事件之间有任意数量的时钟周期间隔。相当于Goto Repetition最后一个重复周期与后面的信号序列不用连续。<br><img src="/2024/02/12/System-Verilog-Notes/image-62.png" alt="Alt text"><br>用法：使用 &#x3D; 操作符表示 nonconsecutive 重复。</p>
<h6 id="example-8"><a href="#example-8" class="headerlink" title="example"></a>example</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p26;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(start) |-&gt; ##<span class="number">2</span> (a[=<span class="number">3</span>]) ##<span class="number">1</span> stop ##<span class="number">1</span> !stop;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a26:<span class="keyword">assert</span> <span class="keyword">property</span>(p26);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-64.png" alt="Alt text"><br>与p25一样的信号，使用Nonconsecutive Repetition可以断言成功。</p>
<h4 id="throughout-持续"><a href="#throughout-持续" class="headerlink" title="throughout 持续"></a>throughout 持续</h4><p>在 SystemVerilog 的序列（sequence）中，throughout 是一个关键字，用于描述一种强制性的关系，即一个事件在另一个事件发生的整个持续时间内必须为真。这种构造在描述复杂的时序关系时非常有用，特别是当一个条件必须在另一个条件的整个持续期间内持续成立时。</p>
<h5 id="example-9"><a href="#example-9" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> burst_rule1;</span><br><span class="line">    @(<span class="keyword">posedge</span> mclk)</span><br><span class="line">        <span class="built_in">$fell</span>(burst_mode) ##<span class="number">0</span>(!burst_mode) <span class="keyword">throughout</span> (##<span class="number">2</span> ((trdy==<span class="number">0</span>)&amp;&amp;(irdy==<span class="number">0</span>)) [*<span class="number">7</span>]);</span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-65.png" alt="Alt text"></p>
<h4 id="within"><a href="#within" class="headerlink" title="within"></a>within</h4><p>在 SystemVerilog 的序列（sequence）中，within 是一个关键字，用于描述一个序列必须完全发生在另一个序列的持续时间内的关系。(注意和throughout的区别)</p>
<h5 id="example-10"><a href="#example-10" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s32a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        ((!a&amp;&amp;!b) ##<span class="number">1</span> (c[-&gt;<span class="number">3</span>]) ##<span class="number">1</span> (a&amp;&amp;b));</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s32b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        <span class="built_in">$fell</span>(start) ##[<span class="number">5</span>:<span class="number">10</span>] <span class="built_in">$rose</span>(start);</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s32;</span><br><span class="line">@(<span class="keyword">posedge</span> clk) s32a <span class="keyword">within</span> s32b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p32;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$fell</span>(start) |-&gt; s32;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">a32: <span class="keyword">assert</span> <span class="keyword">property</span>(p32);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-66.png" alt="Alt text"></p>
<h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p>在 SystemVerilog 的序列（sequence）中，and 关键字用于描述两个或多个序列必须同时发生的关系。两个seq必须同时开始,但不必同时结束。</p>
<h5 id="example-11"><a href="#example-11" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s27a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##[<span class="number">1</span>:<span class="number">2</span>] b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s27b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c ##[<span class="number">2</span>:<span class="number">3</span>] d;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p27;</span><br><span class="line">    s27a <span class="keyword">and</span> s27b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a27: <span class="keyword">assert</span> <span class="keyword">property</span>(p27);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-67.png" alt="Alt text"></p>
<h4 id="intersect-交集"><a href="#intersect-交集" class="headerlink" title="intersect 交集"></a>intersect 交集</h4><p>在 SystemVerilog 的序列（sequence）中，intersect 关键字用于描述两个序列在某个时间点上有重叠的关系。intersect 用于指定两个序列在某个时间点上必须有重叠。这意味着这些序列中的事件或条件必须在某个时刻同时为真，它们的开始和结束时间相同。</p>
<h5 id="example-12"><a href="#example-12" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s28a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a##[<span class="number">1</span>:<span class="number">2</span>] b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s28b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c##[<span class="number">2</span>:<span class="number">3</span>] d;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p28;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) s28a <span class="keyword">intersect</span> s28b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a28:<span class="keyword">assert</span> <span class="keyword">property</span>(p28);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-68.png" alt="Alt text"></p>
<h5 id="和throughout的区别"><a href="#和throughout的区别" class="headerlink" title="和throughout的区别"></a>和throughout的区别</h5><p>throughout 要求一个序列在另一个序列的整个时间范围内持续为真。<br>intersect 只要求两个序列在某个时间点上有重叠，而不需要覆盖整个时间范围。</p>
<h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p>在 SystemVerilog 的序列（sequence）中，or 关键字用于描述两个或多个序列中的任意一个满足条件即可的关系。</p>
<h5 id="example-13"><a href="#example-13" class="headerlink" title="example"></a>example</h5><p><img src="/2024/02/12/System-Verilog-Notes/image-69.png" alt="Alt text"></p>
<h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>property 用于表达更复杂的断言条件，它可以包含一个或多个 sequence，并支持逻辑运算（如 AND、OR、NOT）和其他控制结构（如 if-then-else）。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> name_of_property;</span><br><span class="line">    &lt;test expression&gt;;</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">    &lt;complex <span class="keyword">sequence</span> expressions&gt;;</span><br><span class="line"><span class="keyword">endproperty</span></span><br></pre></td></tr></table></figure>


<h4 id="example-14"><a href="#example-14" class="headerlink" title="example:"></a>example:</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_sequence1;</span><br><span class="line">    <span class="keyword">reg</span> a,clk;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">        clk=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">1</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">13</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">15</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">19</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">21</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">25</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">27</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">29</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">31</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">33</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">35</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> #<span class="number">1</span> clk=!clk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断每个时钟上升沿，a是否为1</span></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p1;</span><br><span class="line">    s1;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">assertion1: <span class="keyword">assert</span> <span class="keyword">property</span>(p1);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-26.png" alt="Alt text"></p>
<h4 id="系统函数："><a href="#系统函数：" class="headerlink" title="系统函数："></a>系统函数：</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$rose</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否从低到高跳变（0到1）。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$fell</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否从高到低跳变（1到0）。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$stable</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否保持不变。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$changed</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否发生了变化。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$past</span>(signal[, n])<span class="comment">//返回 n 个时钟周期之前 signal 的值。如果 n 省略，默认为1。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$countones</span>(expression)<span class="comment">//计算表达式中值为1的位数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$onehot</span>(expression)<span class="comment">//检测表达式是否恰好只有一个位为1（独热编码）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$onehot0</span>(expression)<span class="comment">//检测表达式是否为零或恰好只有一个位为1。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">first_match</span>()<span class="comment">//用于在一系列可能的事件中识别第一个匹配特定条件的事件。</span></span><br></pre></td></tr></table></figure>

<h4 id="property-的否定"><a href="#property-的否定" class="headerlink" title="property 的否定"></a>property 的否定</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s6;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">2</span> b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p6;</span><br><span class="line">    <span class="keyword">not</span> s6;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a6 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p6);</span><br></pre></td></tr></table></figure>


<h4 id="蕴含操作："><a href="#蕴含操作：" class="headerlink" title="蕴含操作："></a>蕴含操作：</h4><p>等同于逻辑学中的蕴含。真值表：</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>a-&gt;b</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>a|-&gt;b &#x3D; a&amp;b | ~a</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p8;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; b;<span class="comment">//a发生后b也发生</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">a8 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p8);</span><br></pre></td></tr></table></figure>




<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p9;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |=&gt; b;<span class="comment">//a发生一个周期后b发生</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a9 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p9);</span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p10;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; ##<span class="number">2</span> b;<span class="comment">//a发生2个周期后b发生</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a10 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p10);</span><br></pre></td></tr></table></figure>


<h4 id="ended关键词控制断言检查的时间"><a href="#ended关键词控制断言检查的时间" class="headerlink" title="ended关键词控制断言检查的时间"></a>ended关键词控制断言检查的时间</h4><p>ended 关键词用于检测一个序列是否已经到达了其结束点。这对于确定某个特定的时序模式是否已经完整地发生非常有用。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> sl5a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> sl5b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c ##<span class="number">1</span> d;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> pl5a;</span><br><span class="line">    sl5a |=&gt; sl5b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> pl5b;</span><br><span class="line">    sl5a<span class="variable">.ended</span> |-&gt; ##<span class="number">2</span> sl5b<span class="variable">.ended</span>; <span class="comment">//终点的对齐，p15a与p15b起点不同，结果一致</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">al5a: <span class="keyword">assert</span> <span class="keyword">property</span>(@(<span class="keyword">posedge</span> clk) pl5a);</span><br><span class="line">al5b: <span class="keyword">assert</span> <span class="keyword">property</span>(@(<span class="keyword">posedge</span> clk) pl5b);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-60.png" alt="Alt text"></p>
<h4 id="disable-iff"><a href="#disable-iff" class="headerlink" title="disable iff"></a>disable iff</h4><p>iff:if and only if<br>disable iff（如果…则禁用）是一个关键的构造，用于定义在某些特定条件下断言不应该被评估或应该被禁用的情况。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p34;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">disable</span> <span class="keyword">iff</span> (reset) </span><br><span class="line">        <span class="built_in">$rose</span>(start) |=&gt; a[=<span class="number">2</span>] ##<span class="number">1</span> b[=<span class="number">2</span>] ##<span class="number">1</span> !start ;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a34： <span class="keyword">assert</span> <span class="keyword">property</span>(p34);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-70.png" alt="Alt text"></p>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>assert 语句用于实际应用断言。它将 property 应用于设计中的特定点，以验证在那个点上 property 是否为真。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span> (prop_X_implies_Y) <span class="keyword">else</span> <span class="built_in">$error</span>(<span class="string">&quot;Assertion failed&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="sequence-property-assert的关系："><a href="#sequence-property-assert的关系：" class="headerlink" title="sequence,property,assert的关系："></a>sequence,property,assert的关系：</h4><pre><code>sequence 提供了描述事件顺序的基础。
property 利用 sequence（可能是多个）来表达更复杂的逻辑条件。
assert 将 property 应用于实际的硬件设计，以确保在运行时满足这些条件。
</code></pre>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>理解以下sequence,property和assert的作用：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s4;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">2</span> b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s2;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(a);</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s3_lib (a，b);</span><br><span class="line">    a || b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##<span class="number">1</span> c;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:<span class="number">3</span>] c;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:$] c;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p6;</span><br><span class="line">    <span class="keyword">not</span> s6;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p8;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a8 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p9;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |=&gt; b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a9 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p9);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p12;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) (a &amp;&amp; b) |-&gt; ##[<span class="number">1</span>:<span class="number">3</span>] c;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a12 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p12);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p10;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; ##<span class="number">2</span> b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a10 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p10);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p13;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) (a &amp;&amp; b) |-&gt; ##[<span class="number">0</span>：<span class="number">2</span>] c;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a13 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p13);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p14;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; ##[<span class="number">1</span>：$] b ##[<span class="number">0</span>：$] c;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a14 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p14);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p17;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c ? d == a：d == b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a17： <span class="keyword">assert</span> <span class="keyword">property</span>(p17);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p19;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) (c &amp;&amp; d) |-&gt; (<span class="built_in">$past</span>((a&amp;&amp;b)，<span class="number">2</span>) == <span class="number">1&#x27;b1</span>);</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a19： <span class="keyword">assert</span> <span class="keyword">property</span>(p19);</span><br></pre></td></tr></table></figure>


<h3 id="如何在仿真中加入assertion"><a href="#如何在仿真中加入assertion" class="headerlink" title="如何在仿真中加入assertion"></a>如何在仿真中加入assertion</h3><p>命令行：<br><img src="/2024/02/12/System-Verilog-Notes/image-61.png" alt="Alt text"><br>gui界面：<br><img src="/2024/02/12/System-Verilog-Notes/image-27.png" alt="Alt text"></p>
<h3 id="如何在testbench中绑定assertion模块"><a href="#如何在testbench中绑定assertion模块" class="headerlink" title="如何在testbench中绑定assertion模块"></a>如何在testbench中绑定assertion模块</h3><h2 id="Random-coverage"><a href="#Random-coverage" class="headerlink" title="Random coverage"></a>Random coverage</h2><h3 id="使用ramdom的原因"><a href="#使用ramdom的原因" class="headerlink" title="使用ramdom的原因"></a>使用ramdom的原因</h3><p>传统的directed test case无法覆盖所有情况，同时，directed test case只能验证设计时的预期功能。</p>
<p>因此需要引入随机。</p>
<p>random应用场景：<br>1.devices configuration<br>2.sequence order<br>3.environment config<br>4.delays within a constrained range<br>5.dynamic config<br>6.protocol exceptions,error and violations<br>…</p>
<h3 id="sv-中的random"><a href="#sv-中的random" class="headerlink" title="sv 中的random"></a>sv 中的random</h3><h4 id="关键字rand"><a href="#关键字rand" class="headerlink" title="关键字rand"></a>关键字rand</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> [<span class="number">3</span>:<span class="number">0</span>]  data</span><br></pre></td></tr></table></figure>

<h4 id="randc-random-cycle"><a href="#randc-random-cycle" class="headerlink" title="randc (random cycle)"></a>randc (random cycle)</h4><p><img src="/2024/02/12/System-Verilog-Notes/image-31.png" alt="Alt text"></p>
<p>每个循环调用时，自动变更为与上一个值不同的随机数，并且遍历取值范围。</p>
<h4 id="constraint-block"><a href="#constraint-block" class="headerlink" title="constraint block"></a>constraint block</h4><p>在 SystemVerilog 中，约束块（Constraint Block）是一种用于随机化测试中的强大机制，它允许你为类的成员变量指定特定的约束条件。这些约束用于控制随机生成的数据，以满足特定的测试需求或设计规范。</p>
<p>constraint 可以定义在class 之外。例：  </p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> XYPair;</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="comment">// external constraint body declaration</span></span><br><span class="line"><span class="keyword">constraint</span> XYPair::c &#123; x &lt; y; &#125;</span><br></pre></td></tr></table></figure>

<p>constraint 可以被继承，例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> A;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">integer</span> x;</span><br><span class="line">    <span class="keyword">constraint</span> c &#123; x &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">class</span> B <span class="keyword">extends</span> A;</span><br><span class="line">    <span class="keyword">constraint</span> c &#123; x &gt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h4 id="求解器randomize"><a href="#求解器randomize" class="headerlink" title="求解器randomize()"></a>求解器randomize()</h4><p>randomize() 方法用于随机化类中标记为 rand 或 randc 的成员变量。它根据定义在类中的约束（如果有的话）生成随机值。</p>
<p>randomize()是一个虚函数，每当constraint被继承时，原函数被重载。</p>
<h4 id="pre-randomize-和post-randomize"><a href="#pre-randomize-和post-randomize" class="headerlink" title="pre_randomize()和post_randomize()"></a>pre_randomize()和post_randomize()</h4><p>如其名，是在randomize()前后执行的2个函数。可以被重载。<br>pre_randomize() 方法在每次调用 randomize() 方法之前自动执行。<br>用途：它用于设置随机化操作之前需要的任何状态或条件，比如初始化变量、清除状态、设置默认值等。</p>
<p>post_randomize() 方法在每次调用 randomize() 方法之后自动执行。<br>用途：它用于在随机化之后执行任何必要的操作，比如校验或调整随机化结果、更新依赖于随机值的状态等。</p>
<p>在被重载时，pre_randomize()和post_randomize()都会先执行父类的方法，然后执行重载的内容。<br>The pre_randomize() and post_randomize() methods are not virtual. However, because they are automatically called by the randomize() method, which is virtual, they appear to behave as virtual method.</p>
<h4 id="inside-指定表达式的范围"><a href="#inside-指定表达式的范围" class="headerlink" title="inside 指定表达式的范围"></a>inside 指定表达式的范围</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Bus</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">15</span>:<span class="number">0</span>] addr;</span><br><span class="line"><span class="keyword">randc</span> <span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line"><span class="keyword">constraint</span> range1</span><br><span class="line">&#123;</span><br><span class="line">    addr <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">100</span>],[<span class="number">1024</span>:<span class="number">16384</span>]&#125;;</span><br><span class="line">    data &gt; <span class="number">1000</span>;</span><br><span class="line">    data &lt; <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h4 id="dist-指定权重分布"><a href="#dist-指定权重分布" class="headerlink" title="dist 指定权重分布"></a>dist 指定权重分布</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">int</span> src, dst;</span><br><span class="line">costraint c1 &#123;</span><br><span class="line">    src <span class="keyword">dist</span> &#123;<span class="number">0</span>:=<span class="number">40</span>, [<span class="number">1</span>:<span class="number">3</span>]:=<span class="number">60</span>&#125;;</span><br><span class="line">    dst <span class="keyword">dist</span> &#123;<span class="number">0</span>:=<span class="number">40</span>, [<span class="number">1</span>:<span class="number">3</span>]:/<span class="number">60</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-32.png" alt="Alt text"></p>
<p>:&#x3D; 用于相同分布<br>:&#x2F;用于均匀分布</p>
<h4 id="多维约束"><a href="#多维约束" class="headerlink" title="多维约束"></a>多维约束</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] b,c,d;</span><br><span class="line">costraint c1 &#123;</span><br><span class="line">    b&lt;d;</span><br><span class="line">    c==b;</span><br><span class="line">    d&lt;<span class="number">30</span>;</span><br><span class="line">    c&gt;=<span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件约束"><a href="#条件约束" class="headerlink" title="条件约束"></a>条件约束</h4><p>可以包含蕴含操作：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] a,b;</span><br><span class="line"><span class="keyword">constraint</span> c &#123;(a==<span class="number">0</span>)-&gt;(b==<span class="number">1</span>);&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="约束的概率问题"><a href="#约束的概率问题" class="headerlink" title="约束的概率问题"></a>约束的概率问题</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Unconstrained;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> x;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] y;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-33.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Imp1;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> x;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] y;</span><br><span class="line">    <span class="keyword">constraint</span> c_xy &#123; (x==<span class="number">0</span>)-&gt;y==<span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-34.png" alt="Alt text"></p>
<h4 id="迭代约束"><a href="#迭代约束" class="headerlink" title="迭代约束"></a>迭代约束</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Class C;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">byte</span> A[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">constraint</span> C1&#123; <span class="keyword">foreach</span> (A[i]) A[i]<span class="keyword">inside</span> &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>&#125;;&#125;</span><br><span class="line">    <span class="keyword">constraint</span> C2&#123; <span class="keyword">foreach</span> (A[j]) A[j]&gt; <span class="number">2</span>*j;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C1 constraints each element of an array to be in the set [2,4,8,16]</span></span><br><span class="line"><span class="comment">//C2 constraints each element of an array to be greater than twice its index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h4 id="solve-before-控制求解顺序"><a href="#solve-before-控制求解顺序" class="headerlink" title="solve before :控制求解顺序"></a>solve before :控制求解顺序</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> B;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> s;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] d;</span><br><span class="line">    <span class="keyword">constraint</span> c &#123; s -&gt; d == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">constraint</span> order &#123; <span class="keyword">solve</span> s <span class="keyword">before</span> d; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-35.png" alt="Alt text"></p>
<h4 id="function-in-constraints"><a href="#function-in-constraints" class="headerlink" title="function in constraints"></a>function in constraints</h4><p>用途：使用function来表示一些复杂的分布情况。<br>例：编码中1的个数。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> count_ones ( <span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>] w );</span><br><span class="line">    <span class="keyword">for</span>( count_ones = <span class="number">0</span>; w != <span class="number">0</span>; w = w &gt;&gt; <span class="number">1</span> )</span><br><span class="line">        count_ones += w &amp; <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> C1 &#123; length == count_ones( v ) ; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="constraint-mode-控制约束的开启和关闭"><a href="#constraint-mode-控制约束的开启和关闭" class="headerlink" title="constraint mode: 控制约束的开启和关闭"></a>constraint mode: 控制约束的开启和关闭</h4><p>内建函数：constraint_mode()，默认0 为inactive,1为activate</p>
<h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><p>2个方面：<strong>代码覆盖率</strong>和<strong>功能覆盖率</strong>。</p>
<p>代码覆盖率可以被自动收集量化。<br>功能覆盖率需要一定的方法学评估。<br><img src="/2024/02/12/System-Verilog-Notes/image-36.png" alt="Alt text"></p>
<h4 id="代码覆盖率的类型："><a href="#代码覆盖率的类型：" class="headerlink" title="代码覆盖率的类型："></a>代码覆盖率的类型：</h4><ol>
<li><p>行覆盖率（Line Coverage&#x2F;Statement Coverage）：<br> 测量测试用例是否执行了设计中的每一行代码。<br> 用于确保代码的每一行至少被执行一次。  </p>
</li>
<li><p>块覆盖率(Block Coverage)<br> 通常指的是测试用例是否执行了代码中的每个基本块。一个基本块是一个直线代码序列，没有分支，只有入口和出口。<br> 确保每个代码块至少被执行一次。</p>
</li>
<li><p>表达式覆盖率（Expression Coverage）：<br> 检查是否测试了代码中的每个表达式的所有可能结果。<br> 用于确保所有的逻辑表达式都被充分测试。</p>
</li>
<li><p>分支覆盖率（Branch Coverage）：<br> 测量是否测试了代码中的每个决策点（如 if、case 语句）的每个可能分支。<br> 用于确保每个决策点的每个分支都至少被执行一次。</p>
</li>
<li><p>条件覆盖率（Condition Coverage）：<br> 检查是否测试了决策点中每个单独条件的所有可能结果。<br> 用于确保复合条件（如逻辑与&#x2F;或）中的每个单独条件都被充分测试。</p>
</li>
<li><p>切换覆盖率（Toggle Coverage）：<br>测量是否测试了设计中每个数据位的翻转（从0到1和从1到0）。<br>用于确保寄存器、线网等的每个位至少翻转一次。</p>
</li>
<li><p>状态机覆盖率（FSM Coverage）：<br>检查是否测试了状态机的所有状态和转换。<br>用于确保状态机的每个状态和状态转换都被测试。</p>
</li>
<li><p>路径覆盖率（Path Coverage）：<br>测量是否测试了代码中所有可能的执行路径。<br>用于确保从函数入口到出口的每个可能路径都被执行。</p>
</li>
<li><p>断言覆盖率（Assertion Coverage）：<br>检查是否测试了代码中的每个断言。<br>用于确保设计中的每个断言都被验证。</p>
</li>
</ol>
<p>代码覆盖率不关心具体功能的实现。因此无法保证功能的正确性。</p>
<h4 id="功能覆盖率Functional-Coverage）："><a href="#功能覆盖率Functional-Coverage）：" class="headerlink" title="功能覆盖率Functional Coverage）："></a>功能覆盖率Functional Coverage）：</h4><p>功能覆盖率是衡量测试用例是否覆盖了设计的所有功能方面的度量。它关注于设计的功能需求是否得到了充分的测试。</p>
<p>功能覆盖率需要人工定义。根据对设计的理解设计不同的功能模块。Based on the DUT spec and test plan, define what needs to be covered.</p>
<p>步骤：<br>Define coverage group (sampling points)<br>Define when to sample</p>
<h4 id="cover-group"><a href="#cover-group" class="headerlink" title="cover group"></a>cover group</h4><p>覆盖组是一组相关的覆盖点和&#x2F;或交叉覆盖点的集合。它用于组织和封装相关的覆盖点，以便于管理和分析。<br>特点：覆盖组可以包含一个或多个覆盖点，以及可选的交叉覆盖点（cross coverage）。它还可以包含用于控制采样时机和条件的方法。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> cg;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line">cg cg_inst = <span class="keyword">new</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mem(simple_bus sb);</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data, addr;</span><br><span class="line"><span class="keyword">event</span> write_event;</span><br><span class="line">    <span class="keyword">cover</span> <span class="keyword">property</span></span><br><span class="line">        (@(<span class="keyword">posedge</span> sb<span class="variable">.clock</span>) sb<span class="variable">.write_ena</span>==<span class="number">1</span>)</span><br><span class="line">    -&gt; write_event;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 cover property 定义了一个覆盖属性，该属性监视 simple_bus 上的 write_ena 信号。当 write_ena 在时钟上升沿为 1 时，触发 write_event 事件。</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test(simple_bus sb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> Write_cg @($root<span class="variable">.top</span><span class="variable">.m1</span><span class="variable">.write_event</span>);</span><br><span class="line">        <span class="keyword">coverpoint</span> $root<span class="variable">.top</span><span class="variable">.m1</span><span class="variable">.data</span>;</span><br><span class="line">        <span class="keyword">coverpoint</span> $root<span class="variable">.top</span><span class="variable">.m1</span><span class="variable">.addr</span>;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    Write_cg wcg;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        wcg = <span class="keyword">new</span>;</span><br><span class="line">        sb<span class="variable">.write_ena</span> &lt;= <span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">        #<span class="number">10000</span> <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//est 是一个程序，它也接收一个名为 sb 的 simple_bus 类型的参数。</span></span><br><span class="line"><span class="comment">//覆盖组：定义了一个名为 Write_cg 的覆盖组，该覆盖组在 write_event 事件发生时被采样。</span></span><br><span class="line"><span class="comment">//覆盖点：覆盖组包含两个覆盖点，分别监视 mem 模块中的 data 和 addr 变量。</span></span><br><span class="line"><span class="comment">//覆盖组实例化：在初始块中创建了 Write_cg 的一个实例 wcg。</span></span><br><span class="line"><span class="comment">//测试逻辑：设置 simple_bus 的 write_ena 为 1，并执行一些未详细说明的测试操作。</span></span><br><span class="line"><span class="comment">//仿真结束：在 10000 个时间单位后结束仿真。</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<h4 id="coverage-point"><a href="#coverage-point" class="headerlink" title="coverage point"></a>coverage point</h4><p>覆盖点是对单个变量或表达式的覆盖度量。<br>用途：它用于捕捉和度量特定变量或表达式在测试中的行为。<br>特点：覆盖点可以定义为变量的特定值、范围或者是基于表达式的条件。它通常包含一组覆盖桶（bins），每个桶对应于特定的值或值范围。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-71.png" alt="Alt text"></p>
<h4 id="bin-：对功能点分组"><a href="#bin-：对功能点分组" class="headerlink" title="bin ：对功能点分组"></a>bin ：对功能点分组</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] y;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] values[$]= &#x27;&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">covergroup</span> cg;</span><br><span class="line">cover_point_y : <span class="keyword">coverpoint</span> y &#123;</span><br><span class="line">    <span class="keyword">bins</span> a = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">bins</span> b = &#123;<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">bins</span> c = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">bins</span> d = &#123;<span class="number">6</span>,<span class="number">7</span>&#125;; &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">foreach</span>(values[i])</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        y = values[i];</span><br><span class="line">        cg_inst<span class="variable">.sample</span>();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<h5 id="Transitional-functional-point-bin"><a href="#Transitional-functional-point-bin" class="headerlink" title="Transitional functional point bin"></a>Transitional functional point bin</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">3</span>] y;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] values[$]= &#x27;&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">    cover_point_y : <span class="keyword">coverpoint</span> y &#123;</span><br><span class="line">        <span class="keyword">bins</span> tran_34 = (<span class="number">3</span>=&gt;<span class="number">4</span>);<span class="comment">//捕捉从3到4的切换</span></span><br><span class="line">        <span class="keyword">bins</span> tran_56 = (<span class="number">5</span>=&gt;<span class="number">6</span>);<span class="comment">//捕捉从5到6的切换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">foreach</span>(values[i])<span class="keyword">begin</span></span><br><span class="line">            y = values[i];</span><br><span class="line">            cg_inst<span class="variable">.sample</span>();</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-74.png" alt="Alt text"></p>
<h5 id="wildcard-bin-通配分组"><a href="#wildcard-bin-通配分组" class="headerlink" title="wildcard bin:通配分组"></a>wildcard bin:通配分组</h5><p>分组中的x,z,?会和0,1产生通配。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">3</span>] y;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">3</span>] values[$]= &#x27;&#123; <span class="number">4&#x27;b1100</span>,<span class="number">4&#x27;b1101</span>,<span class="number">4&#x27;b1110</span>,<span class="number">4&#x27;b1111</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">        cover_point_y : <span class="keyword">coverpoint</span> y &#123;</span><br><span class="line">        <span class="keyword">wildcard</span> <span class="keyword">bins</span> g12_15 = &#123; <span class="number">4&#x27;b11</span>?? &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">foreach</span>(values[i])<span class="keyword">begin</span></span><br><span class="line">            y = values[i];</span><br><span class="line">            cg_inst<span class="variable">.sample</span>();</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-72.png" alt="Alt text"></p>
<h5 id="ignore-bin-忽略的分组"><a href="#ignore-bin-忽略的分组" class="headerlink" title="ignore_bin 忽略的分组"></a>ignore_bin 忽略的分组</h5><p>ignore_bin 用于在覆盖率分析中排除特定的值或值范围。它有助于简化覆盖模型，专注于关键的、有意义的值或状态。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] y;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] values[$]= &#x27;&#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">        cover_point_y : <span class="keyword">coverpoint</span> y &#123;<span class="comment">//0,1,2,3,4,5,6,7</span></span><br><span class="line">        <span class="keyword">ignore_bins</span> ig = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">foreach</span>(values[i])<span class="keyword">begin</span></span><br><span class="line">        y = values[i];</span><br><span class="line">        cg_inst<span class="variable">.sample</span>();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-73.png" alt="Alt text"><br>0没有被覆盖到。</p>
<h5 id="illegal-bins"><a href="#illegal-bins" class="headerlink" title="illegal_bins"></a>illegal_bins</h5><p>定义不合法的部分，如果出现这些值直接报错。</p>
<h5 id="cross"><a href="#cross" class="headerlink" title="cross"></a>cross</h5><p>在 SystemVerilog 的功能覆盖率（Functional Coverage）中，cross 关键字用于定义交叉覆盖（Cross Coverage）。交叉覆盖是一种分析技术，用于度量两个或多个覆盖点（coverpoints）之间的组合情况。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] y;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] y_values[$]= &#x27;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] z;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] z_values[$]= &#x27;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">        cover_point_y : <span class="keyword">coverpoint</span> y ;</span><br><span class="line">        cover_point_z : <span class="keyword">coverpoint</span> z ;</span><br><span class="line">        cross_yz : <span class="keyword">cross</span> cover_point_y,cover_point_z ;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">foreach</span>(y_values[i])<span class="keyword">begin</span></span><br><span class="line">            y = y_values[i];</span><br><span class="line">            z = z_values[i];</span><br><span class="line">            cg_inst<span class="variable">.sample</span>();</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<h5 id="conditional-Coverage"><a href="#conditional-Coverage" class="headerlink" title="conditional Coverage"></a>conditional Coverage</h5><p>条件覆盖</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> CoverPort;</span><br><span class="line">    <span class="keyword">coverpoint</span> port <span class="keyword">iff</span> (!bus_if<span class="variable">.reset</span>);</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>

<p>当且仅当满足某种条件时才收集sample.</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>ICer</tag>
        <tag>Programming Language</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数字集成电路设计</title>
    <url>/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="高等数字集成电路设计"><a href="#高等数字集成电路设计" class="headerlink" title="高等数字集成电路设计"></a>高等数字集成电路设计</h1><h2 id="Lecture1-introduction"><a href="#Lecture1-introduction" class="headerlink" title="Lecture1 introduction"></a>Lecture1 introduction</h2><p>本节主要对IC产业的发展进行概述，以及介绍一些数字IC设计中的常用概念和基本指标。</p>
<h3 id="IC产业概述"><a href="#IC产业概述" class="headerlink" title="IC产业概述"></a>IC产业概述</h3><p>集成电路行业是典型的高附加值行业，具有重资产，高技术附加值，和劳动力密集三重特点。其发展存在典型的周期性:<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image.png"></p>
<p>半导体行业的细分领域如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-1.png"><br>对应中国的产业图谱为：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-2.png"></p>
<p>在IC产业的发展历程中，摩尔定律起到核心的推动作用。从芯片制造的角度讲，晶体管尺寸的scaling down能够带来性能，成本和各方面的益处，如下图：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-3.png"></p>
<p>然而随着器件尺寸逼近物理极限，IC工业面临的功耗墙，成本(主要是验证方面成本的急剧提高)及可靠性等各方面的挑战。<br>各工艺节点下的芯片制作成本如下：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-6.png"></p>
<h3 id="数字IC设计概览"><a href="#数字IC设计概览" class="headerlink" title="数字IC设计概览"></a>数字IC设计概览</h3><h4 id="方法学"><a href="#方法学" class="headerlink" title="方法学"></a>方法学</h4><p>数字IC设计从业者分为不同层级：架构，逻辑，电路和物理层级，它们负责不同抽象层级的设计，使用不同的设计工具，如下图：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-4.png"></p>
<p>在数字IC的实际实现过程中，又分为全定制设计和半定制设计。其中半定制设计包括标准单元库（standard cell 设计方法）、门阵列（gate array设计方法）。而全定制设计则在器件层面进行性能和功能的优化。半定制的方法在一定程度上降低了设计难度和优化难度，但可能在性能上略逊于全定制设计。如今的大部分IC设计都是基于半定制设计的。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-5.png"></p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>生产出的芯片裸片并不能直接用于生产生活中的直接应用，而需要先进行封装，对芯片进行一定的物理保护，从而增加芯片的可靠性。芯片封装需要考虑以下几个因素：</p>
<ol>
<li>电气特性，引入尽量小的寄生效应</li>
<li>机械特性：尽量高的稳定性和可靠性</li>
<li>热特性：高效的散热能力</li>
<li>经济性：尽量低的成本</li>
</ol>
<p>下图展示了封装过程中引入的寄生参数：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-7.png"></p>
<p>并且，随着IC产业的发展，一些先进封装技术如SiP,3D stacking, Die to Die,Chiplet等技术，脱离了物理保护的范畴，在架构层面实现了芯片性能的提升，从而成为在设计阶段就需要考虑的因素之一。</p>
<h4 id="DFT-defign-for-test"><a href="#DFT-defign-for-test" class="headerlink" title="DFT(defign for test)"></a>DFT(defign for test)</h4><p>如上所述，随着工艺尺寸的scaling down，IC设计面临测试和验证成本的急剧提升。为此引入了DFT技术。一些典型的DFT技术如扫描链(Scan chain)技术，内建自测试BIST(build-in self test),JTAG等。</p>
<h5 id="SCAN-CHAIN"><a href="#SCAN-CHAIN" class="headerlink" title="SCAN CHAIN"></a>SCAN CHAIN</h5><p>扫描链技术如下图：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-8.png"></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-9.png"></p>
<p>在每个寄存器的输入端口加入一个mux,形成一种scan register,并将每个寄存器的输出端和scan in段串联。</p>
<ol>
<li>在常规模式下，电路正常工作</li>
<li>在scan 模式下，电路相当于一个shift register,每个寄存器中保存的结果被逐位的移动至输出端口(scan out)，从而能够得到某一周期内电路的所有中间值，进行功能验证。</li>
</ol>
<h5 id="BIST"><a href="#BIST" class="headerlink" title="BIST"></a>BIST</h5><p>待补充</p>
<h5 id="JTAG"><a href="#JTAG" class="headerlink" title="JTAG"></a>JTAG</h5><p>待补充</p>
<h3 id="数字IC设计的关心的一些指标"><a href="#数字IC设计的关心的一些指标" class="headerlink" title="数字IC设计的关心的一些指标"></a>数字IC设计的关心的一些指标</h3><p>就IC设计而言，最关注的指标无疑是PPA(power,Performance,Area)。这三个指标往往相互约束，需要做出权衡取舍(trade-off)。</p>
<p>而数字IC设计领域，影响PPA的细分指标也有很多，下面分别简要进行介绍。</p>
<h4 id="Fan-in-和Fan-out"><a href="#Fan-in-和Fan-out" class="headerlink" title="Fan-in 和Fan-out"></a>Fan-in 和Fan-out</h4><p>fan in 指逻辑门连接的输入，fan-in越大，逻辑门本身的面积越大，同时性能也会越差。<img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-10.png" alt="alt text"></p>
<p>fan-out 指逻辑门连接的输出。fan-out越大，逻辑门需要驱动的下级电路越大，从而速度变慢。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-11.png"></p>
<h4 id="干扰-interference-及噪声-noise"><a href="#干扰-interference-及噪声-noise" class="headerlink" title="干扰(interference)及噪声(noise)"></a>干扰(interference)及噪声(noise)</h4><p>电路中那些预期之外的电压和电流信号被称为噪声，噪声往往影响电路的性能。</p>
<p>噪声的形成原因多种多样，常见的有平行线路之间的电磁串扰，电容直接的耦合(coupling)等。这些都造成电路信号的不稳定。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-12.png"><br>同时，来自电源(VDD)和地(VSS)的噪声也会影响信号。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-13.png"></p>
<h4 id="噪声容限-Noise-Margins"><a href="#噪声容限-Noise-Margins" class="headerlink" title="噪声容限 Noise Margins"></a>噪声容限 Noise Margins</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-14.png"></p>
<p>噪声容限一般分为高电平噪声容限$NM_H$和低电平噪声容限$NM_L$,代表电路对噪声的承受能力。它们分别定义为:</p>
<p>$$NM_H &#x3D; V_{OH}-V_{IH}$$<br>$$NM_L &#x3D; V_{IL}-V_{OL}$$</p>
<p>其中$V_{IL}$,$V_{IH}$,$V_{OL}$,$V_{OH}$的定义分别为：</p>
<ol>
<li>$V_{IL}$（Input Low Voltage）：输入低电平电压。输入信号被识别为低电平（通常为“0”）的最大电压。</li>
<li>$V_{IH}$（Input High Voltage）：输入高电平电压。输入信号被识别为高电平（通常为“1”）的最小电压。</li>
<li>$V_{OL}$（Output Low Voltage）：输出低电平电压。输出信号被识别为低电平（通常为“0”）时的最大电压。</li>
<li>$V_{OH}$（Output High Voltage）：输出高电平电压。输出信号被识别为高电平（通常为“1”）时的最小电压。</li>
</ol>
<h4 id="传输延迟-Delay"><a href="#传输延迟-Delay" class="headerlink" title="传输延迟 Delay"></a>传输延迟 Delay</h4><p>电路的传输延迟参数定义如下图：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-15.png"></p>
<ol>
<li>$t_r$：电路从高电平的10%上升为高电平的90%所需要的时间。</li>
<li>$t_f$：电路从高电平的90%下降为高电平的10%所需要的时间。</li>
<li>$t_{pHL}$：输入信号上升为高电平的50%到输出信号下降为高电平的50%所需要的时间。</li>
<li>$t_{pLH}$：输入信号下降为高电平的50%到输出信号上升为高电平的50%所需要的时间。</li>
<li>$t_p$： $t_{pHL}$和$t_{pLH}$的平均值。</li>
</ol>
<h4 id="能效指标：PDP和EDP"><a href="#能效指标：PDP和EDP" class="headerlink" title="能效指标：PDP和EDP"></a>能效指标：PDP和EDP</h4><p>PDP(power delay product)：电路发生翻转期间的平均功耗与传输延迟的乘积,用于衡量电路完成一次计算所消化的能量。单位为焦耳($W\times s$)。</p>
<p>$PDP &#x3D; P_{av}\times t_p$</p>
<p>EDP(Energy delay product):有时，一个具有低PDP的电路，传输延迟（$t_p$）仍然有可能很大。为了找到在功耗和性能之间的最佳平衡点，可以将Power与Delay的平方相乘。即:</p>
<p>$PEP &#x3D; P_{av}\times t_p^2 &#x3D; PDP \times t_p$</p>
<p>在CMOS电路中，PEP一般与电源电压VDD成正比，较低的电压下往往能得到更好的EDP。</p>
<h2 id="Lecture2-Device-Model"><a href="#Lecture2-Device-Model" class="headerlink" title="Lecture2 Device&amp;Model"></a>Lecture2 Device&amp;Model</h2><p>本节主要介绍集成电路中的基本器件：二极管和晶体管，以及对其进行分析的基本模型。</p>
<h3 id="二极管Diode"><a href="#二极管Diode" class="headerlink" title="二极管Diode"></a>二极管Diode</h3><h4 id="掺杂"><a href="#掺杂" class="headerlink" title="掺杂"></a>掺杂</h4><p>硅原子具有4个外层电子，在形成单质(单晶硅)时，每个晶格硅原子与周围的4个硅原子相连，形成正四面体结构：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-16.png"></p>
<p>如果对硅单质中掺入少量的3价元素（如硼B），则在一个晶格中存在一个硅原子，其原子核周围缺少一个电子，或者说形成了一个带正电的空穴(free hole)。进行这类掺杂(doping)的半导体材料具有获得电子的特性(acceptors)，称为P(posetive)型半导体。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-17.png"></p>
<p>如果对硅单质中掺入少量的5价元素(如磷P,砷As),则在一个晶格中存在一个硅原子，其原子核周围多出一个自由电子(free electron)。进行这类掺杂(doping)的半导体材料具有失去电子的特性(donater),称为N(negetive)型半导体。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-18.png"></p>
<h4 id="PN结"><a href="#PN结" class="headerlink" title="PN结"></a>PN结</h4><p>在将一块P型半导体和N型半导体进行接触之后，由于载流子浓度的不同，N型半导体中的自由电子便会自发向P型半导体的区域进行扩散(diffusion)，对其中的空穴进行填充，形成扩散电流(diffusion current)<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-19.png"></p>
<p>在这个过程中，N型半导体由于失去电子而带正电，P型半导体由于得到电子而带负电，从而在PN结内部形成一个从N指向P的内建电场。在内建电场的作用下，P区的电子反过来向N区运动，形成漂移电流(drift diffusion)</p>
<p>在自然条件下，PN结附近的扩散电流和漂移电流达到动态平衡。那些自发失去和得到电子的区域称为耗尽区(depletion region)。</p>
<p>在扩散作用达到平衡后形成的耗尽区具有如下特点：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20.png"></p>
<ol>
<li>电子&#x2F;空穴的密度均匀分布。</li>
<li>由于场强是电荷密度的积分，电子&#x2F;空穴的均匀分布引起电场强调的线性分布。</li>
<li>由于电势是场强的积分，PN结中内建电势随坐标呈现递增分布。</li>
</ol>
<p>耗尽区中内建电势的存在，会阻止载流子的运动，从宏观上看，降低了材料的导电能力。</p>
<h4 id="偏置"><a href="#偏置" class="headerlink" title="偏置"></a>偏置</h4><p>二级结的构成为一个PN结和连接它们的金属，如下图：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-21.png"></p>
<p>其电路符号为一个顶端带有一横线的三角，横线画在N型半导体的位置。</p>
<h5 id="正偏"><a href="#正偏" class="headerlink" title="正偏"></a>正偏</h5><p>将二极管的P区连接电源的正极，N区连接电源的负极时，称为正偏(forward bias):<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-22.png"></p>
<p>正偏后， 施加使得PN结内部的内建电势下降，耗尽区的宽度减小，从而减小了载流子通行的难度。P区的大量空穴和N区的大量电子(这是由掺杂浓度决定的，即空穴在N中为多子，电子在P中也为多子)能够成功穿过耗尽区，从而形成电流。此时占据主导的是扩散电流,导电主要由器件中的多子完成，电流较大。</p>
<h5 id="反偏"><a href="#反偏" class="headerlink" title="反偏"></a>反偏</h5><p>将二极管的P端连接电源负极，N端连接电源正极，称为反偏(reverse bias):<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-23.png"></p>
<p>反偏后，外加电源强化了二极管内部的内建电场，从而使载流子穿过耗尽区的难度增加，只有P区中的少数电子和N区中的少数空穴在电场作用下穿过耗尽区，形成电流。此时占据主导的是漂移电流，导电主要由器件中的少子完成，电流较小。</p>
<h5 id="I-V特性"><a href="#I-V特性" class="headerlink" title="I-V特性"></a>I-V特性</h5><p>二极管的电流公式为：<br>$$ I_D &#x3D; I_s(e^{\frac{V_D}{\phi_T}}-1)$$</p>
<p>其中$\phi_T&#x3D;\frac{kT}{q}&#x3D;26mV$</p>
<p>$I_s$为饱和电流，与二极管的掺杂，PN结面面积有关。</p>
<p>在一定情况下也可作一阶近似：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-24.png"></p>
<h5 id="结电容"><a href="#结电容" class="headerlink" title="结电容"></a>结电容</h5><p>PN结电容公式为：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-25.png"></p>
<p>通过对上述公式定性分析可知：施加正偏电压，$C_j$的分母减小，整体结电容增大。一种理解角度是，正偏后耗尽区减小，相当于减小了平行板电容器的间距，从而增大了电容。</p>
<h3 id="MOS晶体管的静态模型"><a href="#MOS晶体管的静态模型" class="headerlink" title="MOS晶体管的静态模型"></a>MOS晶体管的静态模型</h3><p>MOS器件的剖面图如下：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-26.png"></p>
<p>一个晶体管一般可以抽象成一个开关，当gate端施加足够大的电压(超过阈值电压)，则开关打开。</p>
<h4 id="阈值电压"><a href="#阈值电压" class="headerlink" title="阈值电压"></a>阈值电压</h4><p>晶体管的gate端可以看作一个平板电容，当施加电压足够高时，在下方的衬底中感应出一定的电荷，形成导电沟道。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-27.png"></p>
<p>阈值电压的计算公式：<br>$$V_T &#x3D; V_{T0} + \gamma (\sqrt{|-2\phi_F+V_{SB}|}-\sqrt{\phi_F})$$</p>
<p>其中：$V_{SB}$是源和沉底之间的电压，$V_{T0}$是$V_{SB}&#x3D;0$时的阈值电压，由制作工艺决定。$\phi_F$是费米能级。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-28.png"></p>
<h5 id="体偏效应"><a href="#体偏效应" class="headerlink" title="体偏效应"></a>体偏效应</h5><p>通过上述公式我们可以知道，阈值电压与体源电压有关，从而可以通过条件body端的电压实现阈值电压的条件。这样的方法常被用于低功耗技术中。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-29.png"></p>
<h5 id="短沟道效应-short-channel-effet"><a href="#短沟道效应-short-channel-effet" class="headerlink" title="短沟道效应 short channel effet"></a>短沟道效应 short channel effet</h5><p>随着晶体管尺寸的scaling down,器件的沟道长度逐渐缩短，由于工艺导致源漏之间的耗尽区变得接近，使得阈值电压降低，影响晶体管的开关特性。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-30.png"></p>
<h5 id="漏致势垒降低效应（DIBL）"><a href="#漏致势垒降低效应（DIBL）" class="headerlink" title="漏致势垒降低效应（DIBL）"></a>漏致势垒降低效应（DIBL）</h5><p>Drain-induced barrier lowering：在经典的长沟道器件中，阈值电压的值与漏区电压无关。然而在短沟道器件中，由于晶体管在工作时会给漏级施加电压，从而在D-B之间形成了一个反偏的二极管。这个反偏的二极管增大了漏极的耗尽区宽度，使其与源极的耗尽区进一步接近，从而进一步缩小了导电沟道的长度，使得阈值电压下降。</p>
<p>DIBL本质也是一种短沟道效应。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-31.png"></p>
<h5 id="窄沟道效应-narrow-channel-effet"><a href="#窄沟道效应-narrow-channel-effet" class="headerlink" title="窄沟道效应 narrow channel effet"></a>窄沟道效应 narrow channel effet</h5><p>不同于短沟道效应，窄沟道效应是指当晶体管的沟道宽度(不是长度)变窄时，阈值电压增大的一种现象。这是由于窄沟道的gate端容易与场氧化层重叠，形成更大的GATE电容。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-32.png"></p>
<h4 id="对晶体管的建模"><a href="#对晶体管的建模" class="headerlink" title="对晶体管的建模"></a>对晶体管的建模</h4><p>晶体管可以被看做是个 G,S,D,B的3端器件。在使用时，一般NMOS的衬底默认会接VSS,PMOS的衬底接VDD，从而简化为一个G,S,D的3端器件。在G S间的电压负责控制晶体管的开关，DS间的电压负责控制管子电流的流通。</p>
<h5 id="线性区"><a href="#线性区" class="headerlink" title="线性区"></a>线性区</h5><p>当晶体管满足：</p>
<p>$$V_{GS}&gt; V_T$$<br>$$V_{DS}&lt; V_{GS}-V_T$$</p>
<p>管子工作在线性区，此时晶体管的电流大小满足：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-33.png"></p>
<h5 id="饱和区"><a href="#饱和区" class="headerlink" title="饱和区"></a>饱和区</h5><p>当晶体管满足：<br>$$V_{GS}&gt; V_T$$<br>$$V_{DS}\geq V_{GS}-V_T$$</p>
<p>电流不再随$V_{DS}$增大而增大，而是只与$V_{GS}$有关：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-34.png"></p>
<p>此时的晶体管可以被看做是一个理想电流源。</p>
<h5 id="沟道长度调制-Channel-Length-Modulation"><a href="#沟道长度调制-Channel-Length-Modulation" class="headerlink" title="沟道长度调制 Channel Length Modulation"></a>沟道长度调制 Channel Length Modulation</h5><p>如下图，当$V_{DS} &gt; V_{GS}-V_T$时，靠近漏区部分的沟道实际上会无法感应出反型电荷而产生夹断(pinch-off)。这将导致晶体管的有效沟道长度减小。而晶体管的电流与沟道长度L成反比。因此实际的电流会增大。通过添加一个参数$\lambda$来修正这种沟道长度调制效应：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-35.png"></p>
<h5 id="速度饱和-Velocity-Saturation"><a href="#速度饱和-Velocity-Saturation" class="headerlink" title="速度饱和 Velocity Saturation"></a>速度饱和 Velocity Saturation</h5><p>一般来说，载流子的速度正比于电场强度，但是当速度过大时，会因为载流子间的散射效应而趋于饱和，不再满足线性关系。在源漏电压不变的情况下，沟道越短，沟道间的电场强度越大，从而越容易达到速度饱和。</p>
<p>而对同一器件，则存在一个饱和电压$V_{DSAT}$,当源漏电压大于该值是，出现速度饱和。速度饱和会降低饱和区电流。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-36.png"></p>
<h5 id="电流公式"><a href="#电流公式" class="headerlink" title="电流公式"></a>电流公式</h5><p>结合上述分析，可以分别得到长沟道器件和短沟道器件的电流公式：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-37.png"></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-38.png"></p>
<h5 id="电阻计算"><a href="#电阻计算" class="headerlink" title="电阻计算"></a>电阻计算</h5><p>MOS器件的等效电阻可以用如下公式计算：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-39.png"></p>
<p>可以看到，同样的器件，在VDD减小的情况下，等效电阻急剧增大。这也是阻止器件的VDD无法随器件尺寸同步scaling down的一个原因。</p>
<h3 id="晶体管的动态模型"><a href="#晶体管的动态模型" class="headerlink" title="晶体管的动态模型"></a>晶体管的动态模型</h3><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-40.png"><br>作为一个4端器件，MOS管的电容主要由3部分组成：</p>
<ol>
<li>结构电容</li>
<li>沟道电容</li>
<li>结电容</li>
</ol>
<p>下面依次进行分析：</p>
<h4 id="结构电容"><a href="#结构电容" class="headerlink" title="结构电容"></a>结构电容</h4><p>这部分的主要成因是MOS管在实际生产时，源和漏会向栅下方扩展一个$x_d$的长度，引起了栅和源漏之间的寄生电容：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-41.png"></p>
<h4 id="沟道电容"><a href="#沟道电容" class="headerlink" title="沟道电容"></a>沟道电容</h4><p>向栅极施加电压，在下方形成导电沟道，这个过程也是电容充电的过程。在这个过程中，gate 端与S,D,B间形成的电容大小与晶体管的工作状态有关，总结如下：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-42.png"></p>
<h4 id="结电容-扩散电容"><a href="#结电容-扩散电容" class="headerlink" title="结电容&#x2F;扩散电容"></a>结电容&#x2F;扩散电容</h4><p>最后一部分电容的形成原因如下：考虑一个NMOS，其制造是在一个P衬底上挖出2个N well,这样源漏和衬底之间实际上存在一个PN结，这个PN结在D极施加电压时是反向导通的，但是也具有一定的电容。此外因为MOS管实际是一个立体的结构，源漏区除了与底板之外，与侧壁之间也会形成PN结。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-43.png"></p>
<p>总结上述电容，就可以得到晶体管的电容模型：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-44.png"></p>
<h4 id="源-漏电阻"><a href="#源-漏电阻" class="headerlink" title="源-漏电阻"></a>源-漏电阻</h4><p>晶体管的电阻可能进一步受到源漏电阻的影响：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-45.png"></p>
<h3 id="先进器件"><a href="#先进器件" class="headerlink" title="先进器件"></a>先进器件</h3><p>略</p>
<h2 id="Lecture3-Inverter"><a href="#Lecture3-Inverter" class="headerlink" title="Lecture3 Inverter"></a>Lecture3 Inverter</h2><p>反相器是连接器件到电路的桥梁，因此对反相器的研究可以起到很好的承上启下的作用。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-47.png"></p>
<p>反相器的电路图如图所示。由gate 和drain端相连的一个PMOS和一个NMOS组成，当输入为高电平时，P管关闭而N管打开，VOUT为低电平。输入为低电平时则相反，N管打开而P管关闭，VOUT被拉高。</p>
<h4 id="瞬态响应"><a href="#瞬态响应" class="headerlink" title="瞬态响应"></a>瞬态响应</h4><p>反向器的瞬态响应，可以看作是通过P管和N管对于负责电阻$C_L$的充放电过程：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-48.png"></p>
<p>根据基本电路理论，其传输延迟为 $t_p&#x3D; ln2 \cdot RC &#x3D; 0.69R_{on}C_L$</p>
<h4 id="传输特性曲线"><a href="#传输特性曲线" class="headerlink" title="传输特性曲线"></a>传输特性曲线</h4><p>反向器的传输特性曲线如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-49.png"></p>
<p>需要注意的是，在CMOS电路中，在稳定的工作状态下，不存在从VDD到VSS的直接电流，只有在状态翻转的过程中有一个瞬时的大电流。</p>
<h4 id="翻转阈值"><a href="#翻转阈值" class="headerlink" title="翻转阈值"></a>翻转阈值</h4><p>将反相器的翻转阈值定义为：<br>$$V_M &#x3D; V_{in}&#x3D;V_{out}$$<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-50.png" alt="alt text"></p>
<p>根据上述公式，在该点下，P管和N管均处于饱和状态($V_{ds}&#x3D;V_{gs}$)，假设晶体管为短沟道器件，达到速度饱和，带入电流公式：</p>
<p>$$I_D &#x3D; k’\frac{W}{L}((V_{GS}-V_T)V_{DSAT}-\frac{V_{DSAT}^2}{2})$$</p>
<p>可以解得：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-51.png" alt="alt text"></p>
<p>当VDD的值相比晶体管的阈值电压和饱和电压相比足够大时，简化为“</p>
<p>$$V_M \simeq \frac{rV_{DD}}{1+r}$$</p>
<p>由于r 是一个与P N管宽度只比相关的参数，因此可以通过调节PN管的比值来调节$V_M$的大小：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-52.png"></p>
<p>一般来讲，当$\frac{W_p}{W_n} &#x3D; 2$时， $V_M$接近$V_{DD}$的一半。</p>
<h4 id="V-IH-V-IL-与噪声容限"><a href="#V-IH-V-IL-与噪声容限" class="headerlink" title="$V_{IH}$,$V_{IL}$与噪声容限"></a>$V_{IH}$,$V_{IL}$与噪声容限</h4><p>对于反相器而言，将VTC曲线的斜率为-1(增益为-1)时Vin的值定义为$V_{IH}$,$V_{IL}$</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-53.png"></p>
<p>而数字设计中，往往采用线性分段近似的方式，通过求得$V_M$处曲线的斜率g,确定$V_{IH}$和$V_{IL}$：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-54.png"></p>
<p>此时假设$V_{OL}&#x3D;0$,$V_{OH}&#x3D;V_{DD}$,计算得到相应的噪声容限。</p>
<h4 id="传输增益"><a href="#传输增益" class="headerlink" title="传输增益"></a>传输增益</h4><p>略</p>
<h3 id="负载电容"><a href="#负载电容" class="headerlink" title="负载电容"></a>负载电容</h3><p>接下来分析反相器的负载电容。假设2个反相器进行串联，分析其负载电容$C_L$：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-55.png"></p>
<p>$C_L$的组成包括：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-56.png"></p>
<h4 id="栅漏电容-C-gd"><a href="#栅漏电容-C-gd" class="headerlink" title="栅漏电容 $C_{gd}$"></a>栅漏电容 $C_{gd}$</h4><p>$C_{gd12}$指12这两个管子的栅与漏之间的电容，如之前在器件一栏分析的，该电容一方面由栅极的覆盖（栅氧化层）电容有关，另一方面与栅极电压感应出的沟道电容有关，即：</p>
<p>$$C_{gd} &#x3D; C_{gdO} + C_{gcd}$$</p>
<p>其中栅氧化层电容$C_{gdO}$的值是固定的，而沟道电容$C_{gcd}$与晶体管的工作状态有关。对其进行分类讨论如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-57.png"></p>
<p>可见无论何种工作状态下，沟道电容均为0，故栅漏电容只等于覆盖电容：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-58.png"></p>
<p>此外，需要考虑晶体管的米勒效应，将浮空电容用2倍的接地电容来替换，最终结合版图计算得到的栅漏电容$C_{gd1,2}$为：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-59.png"></p>
<h4 id="漏体电容-C-db1-和-C-db2"><a href="#漏体电容-C-db1-和-C-db2" class="headerlink" title="漏体电容$C_{db1}$和$C_{db2}$"></a>漏体电容$C_{db1}$和$C_{db2}$</h4><p>漏体电容$C_{db1}$和$C_{db2}$来自漏体之间反向偏置的PN结形成的结电容，满足PN结的电容公式。为了简化计算，一般采用一些线性公式进行近似。</p>
<h4 id="扇出的栅电容-C-g"><a href="#扇出的栅电容-C-g" class="headerlink" title="扇出的栅电容$C_g$"></a>扇出的栅电容$C_g$</h4><p>假设栅电容为扇出的栅上的总电容，有：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-60.png"></p>
<h4 id="连线电容-C-W"><a href="#连线电容-C-W" class="headerlink" title="连线电容 $C_W$"></a>连线电容 $C_W$</h4><p>$C_W$ 的值与具体工艺相关</p>
<p>将上述所有电容加和，便得到反相器的负载电容$C_L$</p>
<h3 id="传输延迟"><a href="#传输延迟" class="headerlink" title="传输延迟"></a>传输延迟</h3><p>如前所述，对反相器的传输延迟的分析可以近似为一个一阶的RC模型：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-61.png"></p>
<p>之前的分析已经计算出了反相器的负载电容，接下来需要考虑反相器工作时的等效电阻。</p>
<p>对等效电阻的分析如下：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-62.png"></p>
<p>可以看到，正如前面强调过的，等效电阻是一个与电源电压VDD相关的参数，且与VDD负相关。</p>
<p>当计算传输延迟时：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-63.png"></p>
<p>可以发现随着工作电压的提高，传输延迟也会下降，从而电路的性能提升。这也符号我们的一般直觉，即电压越高，对电路的”驱动”能力越强。</p>
<p>此外，传输延迟也与输入信号的变化有关：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-64.png"></p>
<p>由于输入信号并非理想信号，其变化时间也需要被考虑在传输延迟之内。</p>
<h4 id="晶体管尺寸比例的确定"><a href="#晶体管尺寸比例的确定" class="headerlink" title="晶体管尺寸比例的确定"></a>晶体管尺寸比例的确定</h4><p>在上一节中，为了是传输特性曲线VTC对称，得出P管和N管的比例系数$\beta$约为2。而对称的VTC并不意味着总延迟(high to low 和low to high之和)最小。</p>
<p>实际的实验结果如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-65.png"></p>
<p>可以看到，相等上升和下降传输延迟(2.4)与总延迟最小(1.9)的比例系数并不相等。</p>
<p>好在它们都在2附近，于是$\beta&#x3D;2$便成为默认比例系数。</p>
<h4 id="sizing的影响"><a href="#sizing的影响" class="headerlink" title="sizing的影响"></a>sizing的影响</h4><p>在上述分析中，我们总是假设晶体管的负载电容为$C_L$,然而事实上，$C_L$可以包含2个部分：本征电容$C_{int}$与外部电容$C_{ext}$。还是用之前2个反相器相连的例子：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-66.png"></p>
<p>将$f &#x3D; \frac{C_{ext}}{C_{int}}$称为等效扇出。</p>
<p>当反相器的尺寸整体扩大S倍时，其电容大致扩大为原来的S倍，而电阻却下降为原来的1&#x2F;S,这使得延迟参数$R_{eq}C{int}$不变。而由于sizing增大了本征电容的值，使得$\frac{C_{ext}}{C_{int}}$变小，从而整体的传输延迟变小。</p>
<p>即：在外部负载电容不变的情况下，反相器的尺寸越大，其”驱动”能力越强，传输延迟越小。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-67.png" alt="alt text"></p>
<p>同时需要注意的是，由于延迟与sizing的系数成反比，随着S的增大，在延迟的收益上会逐渐减小，无法通过sizing的方式无限降低延迟。</p>
<h3 id="对传输延迟的sizing优化"><a href="#对传输延迟的sizing优化" class="headerlink" title="* 对传输延迟的sizing优化"></a>* 对传输延迟的sizing优化</h3><p>在对反相器的sizing有了基本认识后，可以考虑对传输延迟进行优化。</p>
<p>考虑如下图所示的一个反相器链(inverter chain)<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-68.png"></p>
<p>对于反相器链中间的任意一个inverter来说，其输出负载($C_{ext}$)是下一级反相器的栅电容$C_g$,而其自身的栅电容是上一级反相器的输出负载。</p>
<p>对于反相器而言，本征电容和栅电容成线性关系：<br>$$C_{int} &#x3D; \gamma C_g$$<br>对于亚微米工艺，$\gamma \simeq 1$<br>于是对第j级有：</p>
<p>$$t_{p,j} &#x3D; t_{p0}(1+\frac{C_{g,j+1}}{\gamma C_{g,j}})$$</p>
<p>考虑整个N级反相器链的传播延迟，有：<br>$$t_p &#x3D;t_{p0} \sum_{j&#x3D;1}^{N}(1+\frac{C_{g,j+1}}{\gamma C_{g,j}})$$</p>
<p>其中$C_{g,N+1} &#x3D; C_L$</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-69.png"></p>
<p>利用均值不等式求其最小值，可得：</p>
<p>$$\frac{C_{g,j}}{C_{g,j-1}} &#x3D; \frac{C_{g,j+1}}{C_{g,j}}$$</p>
<p>即：每一级的反相器都相比前一级放到相同的倍数，记为f，满足：</p>
<p>$$F &#x3D; f^n &#x3D; \frac{C_L}{C_{g,1}}$$</p>
<p>$$t_p &#x3D; Nt_{p0}(1+\frac{\sqrt[n]{F}}{\gamma})$$</p>
<p>对于一个级数不确定的反相器链，为了确定其最优传输级数，将上式对N求导(已知$\frac{\partial \sqrt[x]{y}}{\partial x} &#x3D; -\frac{1}{x^2}\ln y \cdot \sqrt[x]{y}$)，另导数为0，可以得到：</p>
<p>$$f&#x3D;e^{(1+\frac{\gamma}{f})}$$</p>
<p>上述超越方程只有一个解，当$\gamma &#x3D; 1$时，f&#x3D;3.6，解得：</p>
<p>$$N &#x3D; \frac{lnF}{lnf}$$</p>
<h3 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h3><p>CMOS电路的功耗分为2种：</p>
<p>动态功耗：逻辑状态进行翻转时的功耗</p>
<p>静态功耗： 逻辑状态保持时的漏电流产生的功耗</p>
<p>CMOS反相器的功耗产生主要有以下几个方面：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-70.png"></p>
<ol>
<li>gate 端的漏电流</li>
<li>负载电容的充放电</li>
<li>进行翻转时的短路电流</li>
<li>漏极PN结的反偏电流</li>
<li>晶体管关断状态下的亚阈值漏电流</li>
</ol>
<p>其中，主要的功耗来自逻辑翻转时产生的动态功耗。</p>
<h4 id="动态功耗"><a href="#动态功耗" class="headerlink" title="动态功耗"></a>动态功耗</h4><p>当逻辑进行翻转时，PN两个管子同时导通，相当于产生了从VDD到VSS的短路电流。在上下其中一个管子关闭后，该电流需要对负载电容进行充放电，如下图：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-71.png"></p>
<p>负载电容的大小会影响峰值电流的大小，具体来说，负载电容越小，峰值电流越大：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-72.png"></p>
<p>对于动态功耗的计算，每次从低到高翻转消耗的能量为：</p>
<p>$$E &#x3D; C_LV_{dd}^2$$</p>
<p>其中$\frac{1}{2} C_LV_{dd}^2$的能量用于电容的充电，另外一半被PMOS或转化为热量，在放电时，另一半存储在电容的能量被NMOS转换为热量(这也是芯片放热的主要来源)。并且这个值与晶体管的尺寸无关，而只与负载电容和工作电压有关。</p>
<p>如果考虑电路的从0到1的翻转频率，则有：</p>
<p>$$P_{dyn} &#x3D; C_LV^2_{DD}f_{0\rightarrow1}$$</p>
<h4 id="针对最小功耗的反相器链sizing"><a href="#针对最小功耗的反相器链sizing" class="headerlink" title="针对最小功耗的反相器链sizing"></a>针对最小功耗的反相器链sizing</h4><p>上一节针对反相器链的性能进行了sizing,事实上，还可以针对最小功耗进行sizing。<br>(待补充)</p>
<h4 id="PDP和EDP"><a href="#PDP和EDP" class="headerlink" title="PDP和EDP"></a>PDP和EDP</h4><p>如第一节中所定义的，反相器的PDP和EDP如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-73.png"></p>
<p>当需要平衡功耗与性能，使反相器的EDP最小时，我们假设书中的公式5.21：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-74.png"></p>
<p>其中阈值电压和饱和电压满足一定的比例关系，可得：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-75.png"></p>
<p>另上述EDP对VDD的偏导为0，得：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-76.png"></p>
<p>对于一般的亚微米工艺，$\alpha$在1到2之间。</p>
<h2 id="Lecture4-Combinational-Circuits"><a href="#Lecture4-Combinational-Circuits" class="headerlink" title="Lecture4  Combinational Circuits"></a>Lecture4  Combinational Circuits</h2><p>本章将介绍组合逻辑电路，分为以下几个方面：</p>
<ol>
<li>静态&#x2F;动态CMOS 逻辑</li>
<li>组合逻辑门</li>
<li>不同输入下的门延迟</li>
<li>快速逻辑门设计</li>
<li>逻辑努力与延迟优化</li>
<li>有比逻辑</li>
<li>传输管逻辑</li>
<li>动态逻辑</li>
</ol>
<p>所谓组合逻辑，自然是与时序逻辑向对比而言的。二者的区别从抽象的角度来说，组合逻辑是输入的函数，而时序逻辑既是输入的函数，也是当前状态的函数。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-77.png"></p>
<h3 id="静态-动态CMOS电路"><a href="#静态-动态CMOS电路" class="headerlink" title="静态&#x2F;动态CMOS电路"></a>静态&#x2F;动态CMOS电路</h3><p>静态CMOS电路直接与电源和地相连，当电路稳定后，输出与时间无关。</p>
<p>动态CMOS电路则需要时钟信号控制。</p>
<h3 id="组合CMOS逻辑门"><a href="#组合CMOS逻辑门" class="headerlink" title="组合CMOS逻辑门"></a>组合CMOS逻辑门</h3><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-78.png"></p>
<p>CMOS逻辑门分为上拉和下拉网络，并且上拉网络的拓扑结构与下拉网络的结构是对偶的。上拉网络完全由PMOS组成，下拉网络完全由NMOS组成。并且这样实现的逻辑总是PDN的非逻辑。</p>
<p>一个典型的例子是NAND门：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-79.png"></p>
<p>CMOS逻辑的优点在于：</p>
<ol>
<li><p>逻辑摆幅大：CMOS集成电路的逻辑高电平“1”、逻辑低电平“0”分别接近于电源高电位VDD及电源低电位VSS，因此具有较高的噪声容限。也就是说，逻辑值的电平与管子尺寸无关。</p>
</li>
<li><p>具有低功耗特性：CMOS逻辑电路在静态状态下几乎没有功耗，只有在开关转换时才消耗功率。</p>
</li>
<li><p>可以通过sizing调节上升和下降的传输延迟</p>
</li>
</ol>
<h3 id="不同输入pattern下的传输延迟"><a href="#不同输入pattern下的传输延迟" class="headerlink" title="不同输入pattern下的传输延迟"></a>不同输入pattern下的传输延迟</h3><p>CMOS组合逻辑仍然可以套用之前的RC模型:</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-80.png"></p>
<p>与反相器不同的是，不同的输入组合会使传输延迟有所不同。例如考虑一个NAND门：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-81.png"></p>
<p>当输入AB同时拉低时，通过2条并行的线路同时对负载电容充电，从而传输延迟相比只有一条通路时有所下降。</p>
<p>还有一种最坏的情况为： B保持为1，A由1变为0，这个过程中，不但要通过A所在通路向负载电容充电，同时也需要对中间节点的电容充电：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-82.png"></p>
<h4 id="逻辑门的sizing"><a href="#逻辑门的sizing" class="headerlink" title="逻辑门的sizing"></a>逻辑门的sizing</h4><p>之前的章节我们分析过，对于晶体管，其尺寸(主要是宽度W)每扩大S倍，其等效电阻降低为原来的1&#x2F;S。</p>
<p>对逻辑门sizing的初衷在于，想要使上拉和下拉的传输延迟与一个标准的CMOS反相器(PMOS尺寸为NMOS的2倍)相同。而对一个逻辑门，总是考虑其最坏情况下的传输延迟。</p>
<p><strong>因此sizing的逻辑在于将串联的管子尺寸翻倍，以使其等效电阻与单个单倍尺寸的管子相同</strong></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-83.png"></p>
<p>sizing过后的NAND和NOR门分别如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-84.png"></p>
<h4 id="对扇入的考量"><a href="#对扇入的考量" class="headerlink" title="对扇入的考量"></a>对扇入的考量</h4><p>当逻辑门的输入增多时，逻辑门的扇入也会影响逻辑门的性能，需要被纳入考虑。比如如下图所示的4输入NAND门：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-85.png"></p>
<p>当ABC均为1，D从0变为1时，由于一开始OUT为高电平，$C_L$和内部节点$C_1,C_2,C_3$均被充电。</p>
<p>在放电过程中，电路的延迟可被计算为：</p>
<p>$$t_{pHL} &#x3D; 0.69(C_L(R_1+R_2+R_3+R_4)+ C_3(R_1+R_2+R_3)+C_2(R_1+R_2)+C_1R_1)$$</p>
<p>当N管尺寸相同时，可以认为它们拥有相同等效电阻，于是延迟转化为：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-86.png"></p>
<p>也就是说，<strong>逻辑门的延迟和扇入的数量成平方关系。因此大扇入对门的性能影响很大。</strong></p>
<p>相比之下，扇出对延迟的影响是线性的。</p>
<h3 id="快速逻辑门设计"><a href="#快速逻辑门设计" class="headerlink" title="快速逻辑门设计"></a>快速逻辑门设计</h3><p>基于上述对fin-in的考察，对于一个同样功能的逻辑门，有以下不同方式可以降低其延迟：</p>
<h4 id="递进式sizing"><a href="#递进式sizing" class="headerlink" title="递进式sizing"></a>递进式sizing</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-87.png"></p>
<p>对于类似的串联结构，由于M1管的电阻对整体延迟贡献的最多，因此可以将其尺寸适当放大以减小电阻。同样我们可以逐级放大后续管子的尺寸，使得：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-88.png"></p>
<p>这样的sizing方式可以降低大约20%延迟。</p>
<h4 id="晶体管的重排"><a href="#晶体管的重排" class="headerlink" title="晶体管的重排"></a>晶体管的重排</h4><p>通过重排，将先翻转的逻辑门从近输出端移到近地端，让内部电容提前放电，可以有效降低延迟：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-89.png"></p>
<h4 id="逻辑重构"><a href="#逻辑重构" class="headerlink" title="逻辑重构"></a>逻辑重构</h4><p>对于同一逻辑，使用不同的门进行组合可以降低其延迟。</p>
<p>例如对一个8输入与门有以下几种不同的实现方式：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-90.png"></p>
<h4 id="插入buffer增强驱动"><a href="#插入buffer增强驱动" class="headerlink" title="插入buffer增强驱动"></a>插入buffer增强驱动</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-91.png"></p>
<p>这样做能够增强驱动的原理在于，buffer的加入将fan-in和fan-out进行了隔离。</p>
<h3 id="逻辑努力"><a href="#逻辑努力" class="headerlink" title="逻辑努力"></a>逻辑努力</h3><p>先前对反相器链的分析中，我们知道通过对一整个链上的反相器进行sizing，可以有效降低整个路径的传输延迟。通过引入逻辑努力，可以将上述分析方法推广到所有组合逻辑门。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-92.png"></p>
<p>首先回顾反相器链的知识，一个标准反相器的延迟可以被表示为：</p>
<p>$$t_p &#x3D; 1+\frac{f}{\gamma}$$</p>
<p>其中f为等效扇出，$\gamma$是工艺参数，代表本征电容和栅电容的比值。</p>
<p>$$C_{inv} &#x3D;\gamma C_{g}$$</p>
<p>将上述分析方式推广任意逻辑门：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/7872a0ef0997c342ccdd6a92af73097.jpg"></p>
<p>注意上述推导过程，在第三行中，提取一个标准反相器的本征电容$C_{int}$作为公因子，在第五行中将这个值代换成了标准反相器的栅电容$\gamma C_{ginv}$。同时，假设通过sizing使标准逻辑门拥有与反相器相同的电阻，从而$R_{par} &#x3D; R_{inv}$。</p>
<p>第四行的$C_g$是逻辑门的栅电容。</p>
<p>最终我们得到公式：</p>
<p>$$t_p &#x3D; t_{p0}(p+ \frac{g\cdot f}{\gamma})$$</p>
<p>其中：</p>
<ol>
<li>$p$是逻辑门本征电容和标准反相器本征电容只比，这个值只与逻辑门的类型和拓扑结构有关。</li>
</ol>
<p>例如，对一个n输入的nand门，其p值为n:</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-94.png"></p>
<p>而对于下面的异或门，其p值为4：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-95.png"><br>（计算方法是看其对输出节点贡献的负载电阻。）</p>
<p>不同逻辑门的p值总结如下：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-96.png"></p>
<ol start="2">
<li><p>$g$称为逻辑努力，是门输入栅电容与标准反相器栅电容的比值，与逻辑门的类型有关。下表总结了不同类型的逻辑门的逻辑努力：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-97.png"><br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-93.png"></p>
</li>
<li><p>$f$为等效扇出，与反相器链中定义的一致，只不过这里的扇入是逻辑门的栅电容。</p>
</li>
</ol>
<h4 id="非对称逻辑门-skewed-gates"><a href="#非对称逻辑门-skewed-gates" class="headerlink" title="非对称逻辑门 skewed gates"></a>非对称逻辑门 skewed gates</h4><p>(待补充)</p>
<h4 id="分支努力"><a href="#分支努力" class="headerlink" title="分支努力"></a>分支努力</h4><p>假设同一个逻辑门的扇出路径上存在多个相同的逻辑门，如下图所示：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-98.png"></p>
<p>假设逻辑门共有b个分支，则对于单个逻辑门，其外部负载变为原来的b倍，传输延迟变为：</p>
<p>$$t_p &#x3D; t_{p0}(p+ \frac{g\cdot f\cdot b}{\gamma})$$</p>
<p>考虑一个多级，多分支的路径，其总延迟为：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-99.png"></p>
<p>优化上述延迟，使总延迟最小：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-100.png"></p>
<p>当且仅当每一级的</p>
<p>$$h_i &#x3D; g_if_ib_i$$</p>
<p>都相等时，整个链路的延迟最小。</p>
<p>而对于每一级来说，逻辑努力g和分支努力d都是固定的，能够进行sizing的参数只有f。</p>
<p>当电路的级数固定时，令每一级的级努力h都相等，可以取得最低延迟。</p>
<h5 id="example"><a href="#example" class="headerlink" title="example"></a>example</h5><p>例：优化下面电路的延迟：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-101.png"></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-102.png"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-103.png"></p>
<h3 id="Ratioed-Logic-有比逻辑"><a href="#Ratioed-Logic-有比逻辑" class="headerlink" title="Ratioed Logic 有比逻辑"></a>Ratioed Logic 有比逻辑</h3><p>除CMOS逻辑外，对同一电路功能还有其他实现方法，比如有比逻辑。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-104.png"></p>
<p>有比逻辑将CMOS中的上拉网络用一个电阻负载进行替代，可以有效减小电路的面积。有比逻辑具有以下特点：</p>
<ol>
<li>n输入的逻辑由n个管子和一个负载组成</li>
<li>$V_{OH} &#x3D; V_{DD}$</li>
<li>$V_{OL}&#x3D;\frac{R_{PN}}{R_{PN}+R_{L}}V_{DD}$</li>
<li>具有非对称的响应时间</li>
<li>静态功耗很高</li>
<li>$t_{pLH}&#x3D;0.69R_LC_L$</li>
</ol>
<h4 id="伪nmos逻辑"><a href="#伪nmos逻辑" class="headerlink" title="伪nmos逻辑"></a>伪nmos逻辑</h4><p>上述有比逻辑在实际实现时，可以通过一个敞开的PMOS来代替电阻：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-105.png"></p>
<p>这样实现的问题是$V_{OL}$不为0，且与P管与N管的尺寸比例有关(所以叫有比逻辑)。当P管的驱动能力太强时，下拉的N管可能不足以将电路拉低：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-106.png"></p>
<h4 id="有比逻辑的优化"><a href="#有比逻辑的优化" class="headerlink" title="有比逻辑的优化"></a>有比逻辑的优化</h4><p>基于有比逻辑的缺点，可以对其进行一些改进</p>
<h5 id="改进负载"><a href="#改进负载" class="headerlink" title="改进负载"></a>改进负载</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-107.png"></p>
<p>添加一个enable负载，增强P管驱动</p>
<h5 id="差分级联电压开关逻辑-Differential-Cascode-Voltage-Switch-Logic-DCVSL"><a href="#差分级联电压开关逻辑-Differential-Cascode-Voltage-Switch-Logic-DCVSL" class="headerlink" title="差分级联电压开关逻辑 Differential Cascode Voltage Switch Logic (DCVSL)"></a>差分级联电压开关逻辑 Differential Cascode Voltage Switch Logic (DCVSL)</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-108.png"></p>
<p>将2个下拉网络的输出端进行级联，并且下拉网络彼此对偶。当一个电路打开时，另一个一定关断。  例如下面的 与门：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-109.png"></p>
<p>差分逻辑具有如下特点：</p>
<ol>
<li>全电压摆幅。($V_{OL}$&#x3D;0，因为out为0会反馈回来关掉上拉网络)。</li>
<li>无静态功耗</li>
<li>2个互补的输出直接没有延迟</li>
</ol>
<h3 id="传输管逻辑"><a href="#传输管逻辑" class="headerlink" title="传输管逻辑"></a>传输管逻辑</h3><p>在一般的晶体管电路中，输入都被送到晶体管的栅极，而在传输管逻辑中，输入被送到晶体管的源&#x2F;漏极，这样的好处是可以在功耗，面积或性能上得到提升。</p>
<h4 id="nmos开关"><a href="#nmos开关" class="headerlink" title="nmos开关"></a>nmos开关</h4><p>当nmos作为开关时，存在的问题在于不会获得全摆幅的电压输出，如下图：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-110.png"></p>
<p>分析B点的电压，由于晶体管必须保持开启状态，有：</p>
<p>$$V_{GS}&#x3D;V_C-V_B \geq V_t$$</p>
<p>B点的电压最多只能达到 $V_{DD}-V_T$</p>
<p>这为传输管逻辑的级联带来了问题：</p>
<p>如图：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-111.png"><br>这样的连接方法在末端会损失一个$V_t$的电压。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-112.png"></p>
<p>这样的连法没连接一次就会损失一个$V_t$的电压。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-113.png" alt="alt text"></p>
<h5 id="改进：level-restoring"><a href="#改进：level-restoring" class="headerlink" title="改进：level restoring"></a>改进：level restoring</h5><p>可以通过下面的方式改进输出不足的问题：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-114.png"></p>
<p>通过一个反馈的P管，将X点电压重新拉回VDD。问题在于，这样的电路是一个有比逻辑，$M_r$的尺寸不能太大，否则X点电压可能没办法被拉回0.</p>
<h4 id="传输门逻辑"><a href="#传输门逻辑" class="headerlink" title="传输门逻辑"></a>传输门逻辑</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-116.png" alt="alt text"><br>通过同时使用PN2个管子，得到一个全摆幅的输出</p>
<h5 id="延迟分析"><a href="#延迟分析" class="headerlink" title="延迟分析"></a>延迟分析</h5><p>一个打开的传输门可以看作一个电阻，多级的传输门逻辑相当于一个RC网络，其延迟是级数的二阶函数：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-117.png"></p>
<p>同样可以通过插入buffer的方式来降低延迟：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-118.png"></p>
<h3 id="动态逻辑"><a href="#动态逻辑" class="headerlink" title="动态逻辑"></a>动态逻辑</h3><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-119.png"></p>
<p>动态逻辑的电路结构如图，通过为PDN加上2个由clk信号控制的管子和一个下拉网络实现，一个n输入的逻辑门需要n+2个管子实现。</p>
<p>当clk为0时，最下方的n管关闭，上方的n管先对负载进行预充电。clk拉高后，充电结束，下方的n管打开，经PDN的计算决定要不要对负载进行放电。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-120.png"></p>
<p>动态逻辑具有如下优点：</p>
<ol>
<li>只用下拉网络进行计算(节约面积)</li>
<li>全摆幅输出</li>
<li>无比逻辑</li>
<li>翻转速度更快(相比CMOS，输入和输出负载都更小)</li>
</ol>
<p>动态逻辑的缺点在于：</p>
<ol>
<li>功耗一般高于CMOS逻辑。(每次预充电后计算，都可能放电，导致电路的翻转频率高于CMOS)<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-121.png" alt="alt text"></li>
</ol>
<p>噪声容限较低。</p>
<h4 id="漏电问题"><a href="#漏电问题" class="headerlink" title="漏电问题"></a>漏电问题</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-122.png"></p>
<p>如下图，预充电后，A管的源极电压为高，S和B直接存在一个反偏的PN结，存在漏电流。这会导致$C_L$上的电荷减少，当进行计算时，无法得到一个满”1”:</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-124.png" alt="alt text"></p>
<p>解决方案是通过一个反馈来进行电压维持：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-125.png"></p>
<h4 id="电荷共享问题"><a href="#电荷共享问题" class="headerlink" title="电荷共享问题"></a>电荷共享问题</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-123.png"></p>
<p>如果在clk为0，进行计算的时候，A由低变高，则$C_A$分担了$C_L$上的电荷，同样导致输出不能达到满”1”：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-126.png"></p>
<p>解决方案是使用clk控制的晶体管对中间节点进行充电：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-127.png"></p>
<h4 id="回栅问题-back-gating"><a href="#回栅问题-back-gating" class="headerlink" title="回栅问题 (back gating)"></a>回栅问题 (back gating)</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-128.png"></p>
<p>简单来说就是输入(out1)通过电容耦合到了输出(out2)上，使输出不能得到完全的计算。</p>
<h4 id="时钟馈通-clock-feed-through"><a href="#时钟馈通-clock-feed-through" class="headerlink" title="时钟馈通 (clock feed through)"></a>时钟馈通 (clock feed through)</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-129.png"></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-130.png"></p>
<p>时钟信号的波动耦合到输出，使得输出峰值大于$V_{DD}$.</p>
<h4 id="级联问题"><a href="#级联问题" class="headerlink" title="级联问题"></a>级联问题</h4><p>如果将动态逻辑进行级联，同样会遇到输出下降的问题：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-131.png"></p>
<p>如图是2个串联的动态反相器，一开始clk为低时，out1和out2都被预充为1，在clk拉高后，它们分别开始计算。</p>
<p>由于in&#x3D;1,因此out1的预期结果应该为0，而out2的结果应该为1.在计算过程中，out1节点会逐渐放电到0，由于out1降到0需要一定时间，在这器件out1控制的nmos仍然是打开的，因此out2也会通过下拉通路放电，知道out1的值降到vt以下才会结束这个过程。</p>
<p>通过上述分析我们可以发现，这种过程只出现在计算时不需要放电，但却因为输入是从1到0渐变的，导致了一部分电荷损失。如果输入是由0到1的，也就是说本来就需要对输出节点进行放电，则不存在这个问题。</p>
<p>因此可以通过增加一级反相器解决这个问题：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-132.png"></p>
<p>由于out1前面的节点总是被预充到1，out1自己总是被预放电到0，如果计算出out1&#x3D;1,再对后面的节点进行放电，就不会有问题。</p>
<p>这样的多个动态逻辑的串联被称为多米诺逻辑：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-133.png"></p>
<p>此外可以在多米诺逻辑的基础上省略下面的管设计出footless的多米诺：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-134.png"></p>
<p>以及省略中间的反相器，做成np-CMOS：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-135.png"></p>
<h2 id="Lecture5-时序逻辑"><a href="#Lecture5-时序逻辑" class="headerlink" title="Lecture5 时序逻辑"></a>Lecture5 时序逻辑</h2><p>时序逻辑与组合逻辑的最大区别在于，电路的输出不止由输入决定，也由电路当前的状态决定。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-136.png"></p>
<h3 id="锁存器-latch-和寄存器-register"><a href="#锁存器-latch-和寄存器-register" class="headerlink" title="锁存器(latch)和寄存器(register)"></a>锁存器(latch)和寄存器(register)</h3><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-137.png"></p>
<p>区别在于，latch在整个时钟拉高的阶段都进行计算，register只在时钟上升沿发生变化。</p>
<h3 id="时序参数"><a href="#时序参数" class="headerlink" title="时序参数"></a>时序参数</h3><p>对寄存器来说，有以下几个重要的时序参数：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-138.png"></p>
<ol>
<li>set up time: 时钟到来之前，数据需要提前准备好的时间</li>
<li>hold time： 时钟到来之后，数据需要保持不变的时间</li>
<li>$t_{c2q}$:顾名思义，指时钟开始发生变化，到数据完成计算保持稳定的时间。可以看作是clk到q的传播延迟。</li>
</ol>
<p>接下来定义如下参数：</p>
<h4 id="传播延迟"><a href="#传播延迟" class="headerlink" title="传播延迟"></a>传播延迟</h4><p>污染延迟指输入信号开始变化后，输出信号完成变化的时间。也就是说，在传播延迟之后，数据才运算结束。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-139.png"><br>在这里要注意的是，传输延迟和数据端D无关，而是与时钟信号clk有关。</p>
<p>而$t_{p,reg}$不止需要经过寄存器的c to q传播，还需要数据提前准备好，所以要加上set up time。在传输延迟之后，数据不会有新的变化(一周期之内)</p>
<p>传播延迟决定时钟周期。</p>
<h4 id="污染延迟"><a href="#污染延迟" class="headerlink" title="污染延迟"></a>污染延迟</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-140.png"></p>
<p>污染延迟指输入信号开始变化后，输出信号开始变化的时间。也就是说，在污染延迟之内，数据未发生任何变化。因此污染延迟被用来计算保持时间。</p>
<h4 id="建立时间"><a href="#建立时间" class="headerlink" title="建立时间"></a>建立时间</h4><p>对于一个流水线结构，时钟周期满足如下关系：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-141.png"></p>
<h4 id="保持时间"><a href="#保持时间" class="headerlink" title="保持时间"></a>保持时间</h4><p>对于一个有限状态系统，保持时间满足如下关系：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-143.png" alt="alt text"></p>
<p>如果电路不满足建立时间，可以适当降频增大时钟周期，如果电路不满足保持时间，需要重新设计电路(例如可以通过插入buffer)的方式解决。</p>
<h3 id="静态latch-和-register"><a href="#静态latch-和-register" class="headerlink" title="静态latch 和 register"></a>静态latch 和 register</h3><p>如果需要用电路存储01这两种不同的状态，需要电路在高低电平时均能保持稳定，这需要构造一个双稳态电路。最简单的双稳态电路如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-144.png"></p>
<p>双稳态的蝶形曲线，可以保证任何向两端便宜的电压都会得到自我强化，最终达到一个稳定的端点：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-145.png"></p>
<p>然而，注意到在电路的C端，同样是一个可能成立的点。如果电路停留在C点而没有任何外部绕的的话，则处于一种”亚稳态”。</p>
<h4 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h4><p>使用晶体管存储电路一般有2种方式：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-146.png"></p>
<p>一种是通过双稳态电路静态存储，状态在通电状态下可以一直保存(类别SRAM)</p>
<p>一种是通过电容存储，需要定期刷新(参考DRAM)</p>
<h4 id="数据的写入"><a href="#数据的写入" class="headerlink" title="数据的写入"></a>数据的写入</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-147.png"></p>
<p>左边的写入方式是强行覆盖，需要晶体管有足够的驱动能力，需要sizing,右边的写入方式则相当于另外增加了写入通路。</p>
<h3 id="latch的实现"><a href="#latch的实现" class="headerlink" title="latch的实现"></a>latch的实现</h3><h4 id="基于mux的实现方式"><a href="#基于mux的实现方式" class="headerlink" title="基于mux的实现方式"></a>基于mux的实现方式</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-148.png"></p>
<p>如图，通过反馈连接的Mux可以实现latch的功能</p>
<h4 id="基于传输门的latch"><a href="#基于传输门的latch" class="headerlink" title="基于传输门的latch"></a>基于传输门的latch</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-149.png"></p>
<p>这种实现下clk信号要驱动4个负载晶体管</p>
<h4 id="基于NMOS实现"><a href="#基于NMOS实现" class="headerlink" title="基于NMOS实现"></a>基于NMOS实现</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-150.png"></p>
<p>这种实现需要clk和clk非信号之间直接没有重叠</p>
<h3 id="静态register的实现"><a href="#静态register的实现" class="headerlink" title="静态register的实现"></a>静态register的实现</h3><p>register可以通过将2级latch进行串联实现(可以用船闸进行类比)</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-151.png"></p>
<p>当clk为低时，数据被QM点采样，当clk为高时，QM保持不变并被Q采样。</p>
<p>此外，我们还可以对上述register做以下分析：</p>
<ol>
<li>clk信号的负载是6个晶体管</li>
<li>建立时间：</li>
</ol>
<p>分析上述电路的建立时间：<br>时钟上升沿到来之前(clk&#x3D;0)，$T_1$打开，$T_2$关闭，信号D通过$I_1$,$T_1$,$I_3$,$I_2$（以及$I_4$）写入双稳态电路。如果不考虑分支造成影响，则建立时间为：</p>
<p>$$t_{setup} &#x3D; 3t_{p_{inv}} + t_{p_{tx}}$$</p>
<p>即建立时间至少为3个反相器加一个传输管的传输延迟。</p>
<ol start="3">
<li>传输延迟</li>
</ol>
<p>时钟上升沿到来后，$T_3$打开。Q端有输出，需要信号经过$T_3$,$I_6$,即：<br>$$t_{prop}  &#x3D; t_{p_{inv}} + t_{p_{tx}}$$</p>
<ol start="4">
<li>保持时间为0.这是因为一旦clk升高，$T_1$便关断，信号立即被阻断。</li>
</ol>
<h4 id="时钟交叠的问题"><a href="#时钟交叠的问题" class="headerlink" title="时钟交叠的问题"></a>时钟交叠的问题</h4><p>上述电路的问题在于，$\bar{clk}$信号是通过一个反相器产生的，而这导致原信号与非信号并不完全同步，会有时钟交叠的问题：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-152.png"></p>
<p>而当2个信号同时为高时，会存在从Q到D的直接通路，造成亚稳态。</p>
<p>可以通过2个不重叠的时钟解决上述问题：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-153.png"></p>
<p>使用如下电路生成非交叠时钟信号：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-154.png"></p>
<h3 id="动态latch和register"><a href="#动态latch和register" class="headerlink" title="动态latch和register"></a>动态latch和register</h3><p>静态latch和register的缺点在于电路一般比较负责，同时面积过大。同时，对于依靠时钟驱动的电路，信号值一般只需要暂时保存(例如几个clk cycle)，因此便有了动态存储的思想。</p>
<p>动态存储不使用双稳态电路中稳定的电平进行存储，而是使用电容中的电荷进行存储。</p>
<h4 id="动态reg示例"><a href="#动态reg示例" class="headerlink" title="动态reg示例"></a>动态reg示例</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-155.png"></p>
<p>如图，使用一个大电容对电荷进行存储，同样能达到register的效果。</p>
<p>同时，可以在每一级Latch中增加一个反馈回路，使得电容的电荷更加稳定：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-156.png"></p>
<p>当然，即使做了改进，由于耦合，漏电和vdd跳变的影响，该电路的稳定性还是不如静态register。</p>
<h3 id="其他类型的reg-latch"><a href="#其他类型的reg-latch" class="headerlink" title="其他类型的reg&#x2F;latch"></a>其他类型的reg&#x2F;latch</h3><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-157.png"></p>
<p>图中是一种C2MOS,当clk为低，$\bar{D}0$被写入X，当clk为高，X的非传到Q。</p>
<p>这种寄存器的好处是不存在时钟交叠问题，因为当clk和其非信号都为1或0时，D值无法传到X</p>
<h3 id="单相register"><a href="#单相register" class="headerlink" title="单相register"></a>单相register</h3><p>上述寄存器的实现都同时用到了clk和其非信号，实际上还可以只用clk信号，从而避免时钟交叠问题。</p>
<p>如下所示：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-158.png"></p>
<p>为了将上述latch变成register，首先将其拆分成2半：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-159.png"></p>
<p>之后，我们加入一个动态逻辑中的inverter:</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-160.png"><br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-161.png"></p>
<p>再将上述三部分合在一起，加上一个额外的反相器，即可构成一个register:<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-162.png"></p>
<p>其工作原来如下：<br>clk&#x3D;0时，D的非被传输到X，同时Y被预充为高。CLK&#x3D;1后，Y点进行计算，得到X的非也就是D的值，同时Y的值经过半个Latch传到Q前面的反相器，再经过一级反相器达到Q。</p>
<p>其参数分析如下：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-163.png"></p>
<h3 id="低功耗register设计"><a href="#低功耗register设计" class="headerlink" title="低功耗register设计"></a>低功耗register设计</h3><p>在现代处理器中，FlipFlops占据总功耗的约20%，因此低功耗的寄存器设计是有必要的。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-164.png"></p>
<p>一个好的寄存器应当具有以下特点：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-165.png"></p>
<h4 id="案例分析-S2CFF"><a href="#案例分析-S2CFF" class="headerlink" title="案例分析: S2CFF"></a>案例分析: S2CFF</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-166.png"></p>
<p>(待补充)</p>
<h3 id="非双稳态电路"><a href="#非双稳态电路" class="headerlink" title="非双稳态电路"></a>非双稳态电路</h3><h4 id="施密特触发器"><a href="#施密特触发器" class="headerlink" title="施密特触发器"></a>施密特触发器</h4><p>施密特触发器的特性在于拥有非对称的电压阈值：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-167.png"><br>对于从低电压的传输，需要更高的电压阈值；对于低电压的传输，需要更低的电压阈值。</p>
<p>其电路符号如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-168.png"></p>
<p>施密特触发器一般被用作整流器，从而抑制电路的噪声：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-169.png"></p>
<p>其CMOS实现如下：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-170.png"></p>
<p>当VIN为0时，X为1，通过一个反相器的反馈，将M4打开，M3逐渐关闭，逐步将VOUT降到0.</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-171.png"><br>VIN&#x3D;VDD时，通过M3逐步将X拉低，将VOUT升高到VDD</p>
<h4 id="环形震荡器"><a href="#环形震荡器" class="headerlink" title="环形震荡器"></a>环形震荡器</h4><p>(待补充)</p>
<h2 id="Lecture6-低功耗设计"><a href="#Lecture6-低功耗设计" class="headerlink" title="Lecture6 低功耗设计"></a>Lecture6 低功耗设计</h2><p>关于低功耗设计的内容占据3个课时</p>
<h3 id="现代集成电路中的功耗问题"><a href="#现代集成电路中的功耗问题" class="headerlink" title="现代集成电路中的功耗问题"></a>现代集成电路中的功耗问题</h3><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-172.png"></p>
<p>在数据中心服务中，功耗意味着成本，在高性能计算领域，功耗和散热制约着电路的性能，在移动端，功耗影响电池寿命。</p>
<h4 id="power-vs-energy"><a href="#power-vs-energy" class="headerlink" title="power vs energy"></a>power vs energy</h4><p>功耗和能耗是不同概念。</p>
<p>对于同一个计算来讲，消化的能量是功耗和时间的乘积(曲线的面积)，一个低功耗电路意味着电路的瞬时功率更小（曲线的高度），但是有可能因为耗时更长使得总能耗变大。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-173.png"></p>
<h4 id="功耗分布情况"><a href="#功耗分布情况" class="headerlink" title="功耗分布情况"></a>功耗分布情况</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-174.png"></p>
<p>集成电路中，功耗分为静态功耗，动态功耗和静态电流(DB端的反偏PN结电流)</p>
<h4 id="动态功耗-1"><a href="#动态功耗-1" class="headerlink" title="动态功耗"></a>动态功耗</h4><p>动态功耗正比于翻转频率：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-175.png"></p>
<p>动态功耗的的来源有3个：</p>
<ol>
<li>电容的充放电</li>
<li>电流翻转过程中的短路电流</li>
<li>临时产生的毛刺(gliches)</li>
</ol>
<h5 id="电路功能对动态功耗的影响"><a href="#电路功能对动态功耗的影响" class="headerlink" title="电路功能对动态功耗的影响"></a>电路功能对动态功耗的影响</h5><p>由于CMOS电路的动态功耗只与输出从0向1变化有关(参见前面对反相器的分析)，所以动态功耗的表达式如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-176.png"></p>
<p>假设输入的概率均匀分布(0和1各占一半)，则相同时钟频率下，不同逻辑功能从0翻转到1的概率不同。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-177.png"></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-178.png"></p>
<p>这个概览在多级或多输入的情况下更加明显：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-179.png"></p>
<p>而对于动态逻辑，差分逻辑来讲，其动态功耗都大于CMOS逻辑。</p>
<h5 id="CMOS中的毛刺"><a href="#CMOS中的毛刺" class="headerlink" title="CMOS中的毛刺"></a>CMOS中的毛刺</h5><p>考虑如下电路：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-180.png"></p>
<p>ABC同时由101变为000，在AB由10变为00时，输出信号X由0变为1，这个时间晚于C，导致中间有一个阶段，X&#x3D;0,C&#x3D;0,Z被短暂的拉高。当X完成计算后，Z又被重新拉低。</p>
<p>这种问题也被称作动态冒险(dynamic hazard)：是指输入的一次变化造成了输出的多次变化。</p>
<p>分析这种毛刺产生的原因，是因为最后一级逻辑门的输入没有同时到达。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-181.png"></p>
<p>如果重新调整电路的结构，使各条路径上的延迟尽量平衡，则可以消除掉相应的毛刺。</p>
<h5 id="短路电流"><a href="#短路电流" class="headerlink" title="短路电流"></a>短路电流</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-182.png"></p>
<p>短路电流产生的原因是在输出翻转的过程中，有一个阶段上拉网络和下拉网络同时导通。</p>
<p>通过调整上升延迟和下降延迟的时间尽量相等，可以把短路电流功耗占据动态功耗的比值降低到10%~15%</p>
<h4 id="静态功耗中的漏电流"><a href="#静态功耗中的漏电流" class="headerlink" title="静态功耗中的漏电流"></a>静态功耗中的漏电流</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-183.png"></p>
<h5 id="亚阈值漏电-sub-threshold-leakage"><a href="#亚阈值漏电-sub-threshold-leakage" class="headerlink" title="亚阈值漏电 sub-threshold leakage"></a>亚阈值漏电 sub-threshold leakage</h5><p>一般而言栅电压低于阈值电压时，我们认为晶体管被关闭。但晶体管并非理想器件，实际上在关闭时仍存在漏电流。且器件的阈值电压越低，这个漏电流越大，且呈指数增长。(这也是为什么finfet效果更好，因为关断的效果更明显)。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-184.png"></p>
<h5 id="堆叠效应-stack-effect"><a href="#堆叠效应-stack-effect" class="headerlink" title="堆叠效应 stack effect"></a>堆叠效应 stack effect</h5><p>有趣的是，当多个管子堆叠时，可以有效降低亚阈值漏电：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-185.png"><br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-186.png"></p>
<p>然而，堆叠效应同时也会造成电荷共享问题。</p>
<h3 id="低功耗优化策略"><a href="#低功耗优化策略" class="headerlink" title="低功耗优化策略"></a>低功耗优化策略</h3><p>针对不同的功耗和电路工况，可以总结出如下所示的低功耗优化策略矩阵：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-187.png"></p>
<p>不同的优化测量分布对于矩阵中的如下位置：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-188.png"></p>
<h4 id="多电压域-multiple-supply-voltages"><a href="#多电压域-multiple-supply-voltages" class="headerlink" title="多电压域 multiple supply voltages"></a>多电压域 multiple supply voltages</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-189.png"></p>
<p>分为2种，一种时block内的多电压，一种是不同function块的多电压。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-190.png"></p>
<p>例如可以针对同一个组合逻辑中的关键路径提高电源电压，以达到更快的计算速度。其他模块则采用较低的电压。</p>
<p>上升电路中的电压转换寄存器(level convertiong FF)的实现方式如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-191.png"></p>
<p>可以实现d&#x3D;vddl,q&#x3D;vddh的变化</p>
<p>通过模块内的多电压域技术，实际上是提高了非关键逻辑的延迟。由此带来的问题是，改变了不同路径的延迟分布，有可能带来电路稳定性的问题（从统计学的角度）：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-192.png"></p>
<p>具体的多电压域有以下2种实现方式：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-193.png"></p>
<h4 id="降低电源电压-supply-voltage-reduction"><a href="#降低电源电压-supply-voltage-reduction" class="headerlink" title="降低电源电压 supply voltage reduction"></a>降低电源电压 supply voltage reduction</h4><p>数字IC中一个典型的数据通路如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-194.png"></p>
<p>其功耗与电源电压的平方，以及电容， 电路的频率成正比，因此理论上降低这三个值中的任何一个都可以有效降低功耗。</p>
<h5 id="并行降低功耗"><a href="#并行降低功耗" class="headerlink" title="并行降低功耗"></a>并行降低功耗</h5><p>通过并行技术可以有效降低电路的功耗，其原理如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-195.png"></p>
<p>通过将组合逻辑的硬件复制多份，将其计算能力提高N倍。<br>注意，组合电路执行的并不是相同的逻辑运算，而是分时运算。</p>
<p>例如，如果将前面采样寄存器的时钟周期保持不变，而在每个周期内送入n组不同的输入，它们分别被送入不同的n组组合电路中进行运算。经过原来的一个时钟周期后，所有计算完成。将输出频率提升n倍，通过mux将其结果输出，就可以在原来的一个时钟周期内得到n个不同的计算结果，相当于将电路性能提升了N倍。</p>
<p>而低功耗技术则是保持末端采样的频率不变，而将前方的采样频率降低为原来的1&#x2F;N。由于采样频率的降低，组合逻辑可以用更长的时间完成计算，因此可以降低电压。</p>
<p>更细节的分析如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-196.png"></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-197.png"></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-198.png"></p>
<p>即通过并行后将电源电压降低为原来的$\beta$倍，功耗降低为原来的$\beta^2$倍。</p>
<h5 id="流水线降低功耗"><a href="#流水线降低功耗" class="headerlink" title="流水线降低功耗"></a>流水线降低功耗</h5><p>流水线降低功耗的原理是，通过流水线提高电路的工作频率，然后降低工作电压，最终达到降低功耗的目的：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-199.png"></p>
<p>不同方法的总结如下表：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-200.png"></p>
<h4 id="DVFS-Dynamic-voltage-and-frequency-scaling"><a href="#DVFS-Dynamic-voltage-and-frequency-scaling" class="headerlink" title="DVFS Dynamic voltage and frequency scaling"></a>DVFS Dynamic voltage and frequency scaling</h4><p>动机： 在实际应用中，电路的活动频率和时间的相关性很大。例如在PC的日常使用中，CPU大部分时间是在待机，只有少部分时间执行高密度计算任务：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-201.png"></p>
<p>如果单纯降低工作频率，无法满足高性能计算的实时性要求：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-202.png"></p>
<p>通过DVFS技术，则可以有效提高电路的瞬时性能，而保持总能量消耗不变：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-203.png"></p>
<p>(这有点像人，同一件工作如果紧急，就提高效率争取快速做完。如果并不很着急，就暂时摆烂慢慢完成)</p>
<p>电源电压和工作频率的关系如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-204.png"></p>
<p>在先进工艺下，频率和电压基本成线性关系。</p>
<h5 id="DVFS框架"><a href="#DVFS框架" class="headerlink" title="DVFS框架"></a>DVFS框架</h5><p>一个典型的DFVS框架如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-205.png"></p>
<p>应用来决定任务的DDL,操作系统根据性能评估CPU的工作负载，选择合适的电源电压和频率节点。</p>
<p>通过软件控制硬件完成相应的DVFS操作。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-206.png"></p>
<p>例如，对苹果A13处理器，从待机到全功率运行需要大约100ms的时间：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-207.png"></p>
<h5 id="DVFS的开销"><a href="#DVFS的开销" class="headerlink" title="DVFS的开销"></a>DVFS的开销</h5><p>DVFS会对系统造成额外开销，主要有以下几个方面：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-208.png"></p>
<h4 id="clock-gating-technique-门控时钟技术"><a href="#clock-gating-technique-门控时钟技术" class="headerlink" title="clock gating technique 门控时钟技术"></a>clock gating technique 门控时钟技术</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-209.png"></p>
<p>通过为时钟信号加上一个disable（或者enable），实现时钟的控制，后面的电路在没有时钟信号时都不再翻转，从而省电。</p>
<p>相应的verilog代码如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-210.png"></p>
<p>通过clock gating技术可以显著减少能耗(70%)</p>
<h4 id="power-gating-电源门控"><a href="#power-gating-电源门控" class="headerlink" title="power gating  电源门控"></a>power gating  电源门控</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-211.png"></p>
<ol>
<li>电源门控控制器（Power Gating Controller）： 控制芯片中关断模块的电源何时关闭并给特殊的cell如retention register输出必要的使能信号；</li>
<li>电源切换结构（Power Switching Fabric）： 也称电源开关（Power Switch），实现电源关闭的逻辑单元，一般由后端实现阶段加入并按照一定规则摆放；</li>
<li>始终开启模块（Always-on Module）：电源一直保持打开的模块；</li>
<li>隔离单元（Isolation Cells）：简称ISO，一般在关断模块到电源始终开启模块方向的信号需要加入此类cell；</li>
<li>保留DFFs（Retention DFFs）：特殊的寄存器能够在主电源关断的情况下保持数据不丢失，只有当关断电源时仍然需要保留部分数据的时候才需要此类cell。</li>
</ol>
<h5 id="门控电源域"><a href="#门控电源域" class="headerlink" title="门控电源域"></a>门控电源域</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-212.png"></p>
<p>通过门控决定电源是否接入或接地。</p>
<p>一般使用基于PMOS的”header”,有时也使用基于NMOS的”footer”。在实际应用中，电源门控的方式主要有两种：关闭VDD或者关闭VSS，但在实际应用方面以关闭VDD为主。</p>
<h5 id="隔离单元-ISO"><a href="#隔离单元-ISO" class="headerlink" title="隔离单元 ISO"></a>隔离单元 ISO</h5><p>隔离单元在电源关断（Power Gating）技术中的主要作用是在模块的电源被切断时，隔离该模块与其他模块之间的信号传递，防止因模块电源关闭而对其他模块产生影响。也就是说，当一个模块的电源被关闭时，隔离单元可以阻断该模块的输出信号，防止这些信号对其他模块产生干扰。</p>
<p>方法是通过产生纯净的0或1信号。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-213.png"></p>
<h5 id="数据保留-data-retention"><a href="#数据保留-data-retention" class="headerlink" title="数据保留 data retention"></a>数据保留 data retention</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-214.png"></p>
<h5 id="添加Power-gating-的示例"><a href="#添加Power-gating-的示例" class="headerlink" title="添加Power gating 的示例"></a>添加Power gating 的示例</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-215.png"></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-216.png"></p>
<p>使用高阈值晶体管实现，N管比P管节约更多面积。</p>
<h5 id="门控电源的问题"><a href="#门控电源的问题" class="headerlink" title="门控电源的问题"></a>门控电源的问题</h5><p>门控电源会带来2个问题：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-217.png"></p>
<p>由于门控电源的加入，工作时虚拟vdd 和虚拟vss 2根线上可能存在噪声。</p>
<p>当模块关闭后，虚拟功能线上的电压很快发生变化，电路中保持的状态迅速丢失。</p>
<h5 id="添加解耦电容-decoupling-capacitor"><a href="#添加解耦电容-decoupling-capacitor" class="headerlink" title="添加解耦电容 decoupling capacitor"></a>添加解耦电容 decoupling capacitor</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-218.png"></p>
<p>解耦电容可以有效保证电路工作时的性能，同时让其中的信号更长时间保持稳定。也能够有效降低氧化层漏电。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-219.png"></p>
<h5 id="苏醒时间问题"><a href="#苏醒时间问题" class="headerlink" title="苏醒时间问题"></a>苏醒时间问题</h5><p>传统的门控电源在休眠后，需要很长时间苏醒才能正常工作(大约1k~1M时钟周期不等)，这使得对于一些只需要短期休眠的任务无法应用。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-220.png"></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-221.png"></p>
<p>苏醒时间慢的原因是需要对电路的中间节点通过footer进行放电。</p>
<h5 id="一种改进方案："><a href="#一种改进方案：" class="headerlink" title="一种改进方案："></a>一种改进方案：</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-222.png"></p>
<h5 id="体偏电压调节"><a href="#体偏电压调节" class="headerlink" title="体偏电压调节"></a>体偏电压调节</h5><p>通过第二节器件的知识我们已经知道，晶体管的阈值电压与体效应有关，通过调节体偏电压的大小，可以控制阈值电压。而阈值电压决定漏电流的大小。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-223.png"></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-224.png"></p>
<p>动态体偏电压的调节有2个思路：</p>
<ol>
<li>电路工作时，设置为正偏，降低VTH,提高性能</li>
<li>电路休眠时，设置为反偏，提升VTH，降低功耗。</li>
</ol>
<h5 id="Supply-Voltage-Ramping-SVR"><a href="#Supply-Voltage-Ramping-SVR" class="headerlink" title="Supply Voltage Ramping (SVR)"></a>Supply Voltage Ramping (SVR)</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-225.png"></p>
<p>在休眠时，干脆关闭电源电压或降低电源电压，以进一步节约功耗。</p>
<p>可以有效减小漏电流</p>
<h5 id="power-gating总结"><a href="#power-gating总结" class="headerlink" title="power gating总结"></a>power gating总结</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-226.png"></p>
<h3 id="超低电压计算"><a href="#超低电压计算" class="headerlink" title="超低电压计算"></a>超低电压计算</h3><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-227.png"></p>
<p>要获得最高的计算性能，需要将工作电压提高，以加快电路的计算速度。<br>然而如果想要是电路每次操作的耗电达到最低，则工作电压降低到阈值附件。</p>
<p>在一些边缘侧的供电受限，且不需要高性能的设备中，这类设计是很有用的。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-228.png"></p>
<p>工作电压VDD不能无限降低，因为再低下去电路的漏电会很大。</p>
<h4 id="logic-sizing"><a href="#logic-sizing" class="headerlink" title="logic sizing"></a>logic sizing</h4><p>在超低电压下，漏电电流变得和驱动电流大小接近。需要考虑电路的sizing问题。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-229.png"></p>
<p>同时要考虑工艺角问题：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-230.png"></p>
<h4 id="Dynamic-Leakage-Suppression-Logic-动态漏电流抑制"><a href="#Dynamic-Leakage-Suppression-Logic-动态漏电流抑制" class="headerlink" title="Dynamic Leakage-Suppression Logic 动态漏电流抑制"></a>Dynamic Leakage-Suppression Logic 动态漏电流抑制</h4><p>(待补充)</p>
<h4 id="Variation-Adaptive-Circuits-自适应电路"><a href="#Variation-Adaptive-Circuits-自适应电路" class="headerlink" title="Variation Adaptive Circuits 自适应电路"></a>Variation Adaptive Circuits 自适应电路</h4><h4 id="Timing-Resilient-Circuits"><a href="#Timing-Resilient-Circuits" class="headerlink" title="Timing Resilient Circuits"></a>Timing Resilient Circuits</h4><p>（待补充）</p>
<h2 id="Lecture7-Arithmetic-Circuits-算数电路"><a href="#Lecture7-Arithmetic-Circuits-算数电路" class="headerlink" title="Lecture7 Arithmetic Circuits 算数电路"></a>Lecture7 Arithmetic Circuits 算数电路</h2><h3 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h3><p>加法器作为算数逻辑运算的基石，很多时候也是电路的性能瓶颈。<br>对加法器的优化主要在于2方面：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-231.png"></p>
<h4 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h4><p>全加器接受3个输入信号(A,B,$C_i$)和2给输出信号(S,$C_o$)。又被称为3-2压缩器。</p>
<p>其中输出和输入的逻辑如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-232.png"></p>
<p>此外我们还可定义如下的中间变量，用于后续推理。</p>
<p>$$G &#x3D; AB $$<br>$$P &#x3D; A\oplus B$$<br>$$D &#x3D; \bar{A}\bar{B}$$</p>
<p>其中G代表generation,表示进位的产生。P代表propagation，表示如果上级产生一个进位，则可以被传播到下一级。D代表delete,表示任何进位都会在这一级消失。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-233.png"></p>
<h4 id="行波进位加法器-The-Ripple-Carry-Adder"><a href="#行波进位加法器-The-Ripple-Carry-Adder" class="headerlink" title="行波进位加法器 The Ripple-Carry Adder"></a>行波进位加法器 The Ripple-Carry Adder</h4><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-234.png"></p>
<p>一个最简单的加法器实现就是将多个全加器串联，得到行波进位加法器。其中进位由低到高逐级产生。</p>
<p>电路的关键路径是n-1级的进位加上最后一级的求和。</p>
<p>这样的加法器，其关键路径延迟是很长的，与加法器的位宽成线性关系。</p>
<h4 id="全加器的电路架构"><a href="#全加器的电路架构" class="headerlink" title="全加器的电路架构"></a>全加器的电路架构</h4><p>我们重构全加器的逻辑表达式：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-235.png"></p>
<p>上述逻辑可以用以下的28管CMOS电路实现：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-236.png"></p>
<p>上述实现的优缺点如下：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-237.png"></p>
<h5 id="改进措施"><a href="#改进措施" class="headerlink" title="改进措施"></a>改进措施</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-238.png"></p>
<p>同一计算逻辑，如果将输入反向，输出逻辑也反向，则得到的结果不变。</p>
<p>通过将奇偶方向加上或去掉反相器，最终每4位可以去掉2个反相器，同时在关键路径上减少了4个反相器：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-239.png"></p>
<h4 id="曼彻斯特进位链加法器"><a href="#曼彻斯特进位链加法器" class="headerlink" title="曼彻斯特进位链加法器"></a>曼彻斯特进位链加法器</h4><p>(待补充)</p>
<h4 id="旁路进位加法器"><a href="#旁路进位加法器" class="headerlink" title="旁路进位加法器"></a>旁路进位加法器</h4><p>旁路进位加法器的思路很简单：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-240.png"></p>
<p>通过计算进位是否可以向下传递，通过添加一个Mux提前算出进位结果。</p>
<p>最坏情况下的关键路径如下：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-241.png"></p>
<p>和行波进位加法器一样，旁路进位加法器的延迟与位数也是线性关系的：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-242.png"></p>
<h4 id="进位选择加法器"><a href="#进位选择加法器" class="headerlink" title="进位选择加法器"></a>进位选择加法器</h4><p>进位选择加法器的思路是，提前计算carry&#x3D;0和carry&#x3D;1的2种结果，通过传入的carry来选择最终的输出。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-243.png"></p>
<p>平分各个级数时：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-244.png"></p>
<p>也可以按照平方的形式划分：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-245.png"></p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-246.png"></p>
<p>对于位数更高的加法器优化效果更好。</p>
<h4 id="超前进位加法器"><a href="#超前进位加法器" class="headerlink" title="超前进位加法器"></a>超前进位加法器</h4><h5 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h5><p>加法器本质是组合逻辑，只要知道各位输入和进位输入，就可以得到进位输出。</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-247.png"></p>
<p>考虑第K位的进位输出：<br>$$C_{o,k} &#x3D; f(A_k,B_k,C_{o,k-1}) &#x3D; G_k+P_kC_{o,k-1}$$</p>
<p>即：第K位的进位产生有2种可能，一种是直接在第K位产生，另一种是低位产生的进位经由第K位传播。</p>
<p>注意到上面的$C_{o,k}$是一个迭代公式，可以一直迭代到最低位：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-248.png"></p>
<h5 id="Lookahead-Mirror"><a href="#Lookahead-Mirror" class="headerlink" title="Lookahead Mirror"></a>Lookahead Mirror</h5><p>上面的公式可以通过下面的结构来实现：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-249.png"></p>
<p>这个结构的问题在于虽然实现起来比较直观，但是扇入很大，位数一高延迟也很大。</p>
<h5 id="块进位"><a href="#块进位" class="headerlink" title="块进位"></a>块进位</h5><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-250.png"></p>
<p>重新组合进位传播公式，我们可以发现，如果将中间的几位看作一个整体，可以从块进位和块传播的角度理解进位公式。</p>
<p>其中<br>$P_{i:j}$表示产生的进位可以经由加法器的第i到j位传播，即：<br>$$P_{i,j} &#x3D; P_iP_{i-1}P_{i-2}\cdots P_j$$</p>
<p>$G_{i:j}$表示在加法器的第i到j位这个区间能够产生进位。显然有多种可能：<br>$$G_{i:j}&#x3D;G_i+ P_iG_{i-1:j} &#x3D; G_i+P_i(G_{i-1}+P_{i-1}G_{i-2:j})&#x3D;G_{i,k}+G_{k-1,j}P_{i,k}$$</p>
<p>定义一种新的算子：</p>
<p>$$(G,P)\bullet(G’,P’)&#x3D;(G+PG’,PP’)$$</p>
<p>例如要计算<br>$$(G_{3:2},P_{3:2})\bullet (G_{1:0},P_{1:0})\<br>&#x3D;(G_{3:2}+P_{3:2}G_{1:0},P_{3:2}P_{1:0})\<br>&#x3D;(G_{3:0},P_{3:0})$$</p>
<p>新算子$\bullet$能够将2个区间的进位产生和进位传播连接起来。其输入为4，输出为2，计算了一个乘加和一个与操作。</p>
<p>通过这个算子，我们可以自由组合控制进位的传播：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-251.png"></p>
<p>从而得到这样的树形加法器。</p>
<p>图中相邻2位的P和G产生过程如下：</p>
<p>$$(G_{1:0},P_{1:0}) &#x3D; (G_{1:1},P_{1:1})\bullet (G_{0:0},P_{0:0})\<br>&#x3D;(A_1B_1,A_1\oplus B_1)\bullet (A_0B_0,A_0\oplus B_0)$$</p>
<h3 id="乘法器"><a href="#乘法器" class="headerlink" title="乘法器"></a>乘法器</h3><p>二进制乘法器的原理可以表示为：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-252.png"><br>即我们熟悉的部分积之和的形式：</p>
<p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-253.png"></p>
<p>一般的乘法器可以做出下面的加法器阵列的形式。问题在于关键路径需要考虑多种进位情况。<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-254.png"></p>
<p>一种优化思路是进行对角线形式的进位，缩短关键路径：<br><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-255.png"></p>
<h3 id="Wallace-Tree-乘法器"><a href="#Wallace-Tree-乘法器" class="headerlink" title="Wallace-Tree 乘法器"></a>Wallace-Tree 乘法器</h3><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-256.png"></p>
<p>核心思路在于，半加器相当于2-2压缩器，全加器相当于3-2压缩器，通过重新排列全加器和半加器的位置，优化关键路径。</p>
<h3 id="移位器"><a href="#移位器" class="headerlink" title="移位器"></a>移位器</h3><p><img src="/2024/06/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-258.png" alt="alt text"></p>
<h2 id="Lecture8-Timing-Issue-时序问题"><a href="#Lecture8-Timing-Issue-时序问题" class="headerlink" title="Lecture8 Timing Issue 时序问题"></a>Lecture8 Timing Issue 时序问题</h2>]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>ICer</tag>
      </tags>
  </entry>
</search>
