<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Computer Architecture</title>
    <url>/2024/02/16/Computer-Architecture/</url>
    <content><![CDATA[<h1 id="高等计算机体系结构课程笔记"><a href="#高等计算机体系结构课程笔记" class="headerlink" title="高等计算机体系结构课程笔记"></a>高等计算机体系结构课程笔记</h1><h2 id="chapter1-Overview-and-Fundamental"><a href="#chapter1-Overview-and-Fundamental" class="headerlink" title="chapter1 Overview and Fundamental"></a>chapter1 Overview and Fundamental</h2><p>1.什么是计算机体系结构(Computer Architecture)?<br>    CA &#x3D; 指令集+微架构+硬件实现  (不单单是指令集设计)</p>
<p>1.指令集的概念：指令集是规定处理器外在行为的一系列内容的统称，是软件人员和硬件设计师之间的桥梁。同一个指令集体系会有多种硬件实现方式，称为微体系结构(microarchitecture)。</p>
<p>2.指令集的基本要素：<br>    指令集的分类(CISC or RISC)、<br>    内存地址分配（对齐方式、大端、小端）<br>    寻址模式（寄存器、立即数、etc）<br>    操作类型和码长<br>    操作内容（控制指令、存储指令、运算指令）<br>    控制流（jump、branch、return）、<br>    编码方式 (定长(MIPS)or变长(X86)) </p>
<p>3.CISC和RISC：</p>
<pre><code>CISC:(Complex Instruction Set Computer)复杂指令集计算机   代表：x86
RISC：(Reduced Instruction Set Computer)精简指令集计算机  代表：MIPS,ARM,RISCV
</code></pre>
<p>4:功耗墙与暗硅。功耗墙：芯片在工作时，如果功率超过某个临界值，就会使热量积累速度超过通过技术手段进行冷却的速度(风扇或水冷等),从而使局部温度不断升高，对芯片本身产生故障甚至永久损害。因此需要将芯片设计为在某个特定功率以下进行工作，即功耗墙。<br>暗硅：由于功耗墙的存在，一块芯片运行时，其上的所有晶体管并不在同一时间全部处于工作状态，这部分没有在工作的晶体管被称为暗硅。由于功耗墙和暗硅的存在，单纯依靠增大芯片面积或进行堆叠来提高芯片性能的做法是行不通的，必须同时考虑芯片的能效(energy efficiency)。<br>PS:集成电路的动态功耗正比于电压的平方x电容x频率。功耗墙的存在同时决定了单纯依靠提升频率来提升电路性能的做法是有极限的。</p>
<p>5:Thermal Design Power(TDP):热设计功耗。TDP 是一个指标，用于表示最大热输出，即一个芯片在运行最大负载时所产生的最大热量。这个值对于散热系统的设计至关重要，因为它帮助确保计算机的冷却系统能够有效地处理和散发这些热量，从而防止过热。</p>
<p>6.Dennard Scaling:随着晶体管尺寸缩小，它们的电压会等比例减小，在保持功耗密度不变的情况下，晶体管可以工作在更高的频率，从而提升了算力。然而随着功耗墙的出现，Dennard Scaling面临着终结。</p>
<p>7.计算机设计的2大原则：1.利用并行2.利用局部性原理</p>
<p>并行的相关术语：ILP（指令级并行）、DLP（数据级并行）、TLP（线程级并行）<br>SISD\SIMD\MISD\MIMD</p>
<p>局部性原理：局部性原理基于这样一个观察：程序在执行时倾向于从相对集中的内存位置重复访问数据和指令。局部性主要分为两种类型：</p>
<p>时间局部性（Temporal Locality）：这种类型的局部性指的是如果一个数据项被访问，那么它在不久的将来很可能会被再次访问。例如，程序中的循环可能多次访问相同的变量或指令。</p>
<p>空间局部性（Spatial Locality）：空间局部性指的是如果一个数据项被访问，那么它附近的数据项很快也可能被访问。这通常是由于数据结构的存储方式（如数组）或程序的顺序执行特性。</p>
<p>8.Amdahl’s Law: <img src="/2024/02/16/Computer-Architecture/image-2.png" alt="Alt text"><br>理解：某一部分的速度提升对总体速率提升的影响，需要考虑其在整体中占据的比例。<br>例：<br><img src="/2024/02/16/Computer-Architecture/image-3.png" alt="Alt text"><br><img src="/2024/02/16/Computer-Architecture/image-4.png" alt="Alt text"><br><img src="/2024/02/16/Computer-Architecture/image-5.png" alt="Alt text"></p>
<p>9.CPU Time和CPI计算：<br><img src="/2024/02/16/Computer-Architecture/image-6.png" alt="Alt text"></p>
<p>上式中，Instruction count由算法决定,Cycles per Instruction由体系结构决定，CLock cycle time由工艺决定。</p>
<p>CPI：clock cycles per instruction:<img src="/2024/02/16/Computer-Architecture/image-7.png" alt="Alt text"></p>
<h2 id="Chapter2-Memory-Hierarchy"><a href="#Chapter2-Memory-Hierarchy" class="headerlink" title="Chapter2 Memory Hierarchy"></a>Chapter2 Memory Hierarchy</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>为什么需要Memory Hierarchy?  <ol>
<li>存储墙的存在，运算单元的速度远远超过存储单元的速度（存储的发展主要是越来越大的容量或带宽，但速度的提升有限）。 导致计算机的性能瓶颈主要在于数据的搬运和存取，而非计算的速度。<br> <img src="/2024/02/16/Computer-Architecture/image-9.png" alt="Alt text"></li>
<li>同时高速存储(register、SRAM)的制造价格远远高于普通的低速存储(DRAM,FLASH),导致从成本的角度，无法做到在整个计算机系统中全部使用昂贵的高速存储。<br> <img src="/2024/02/16/Computer-Architecture/image-8.png" alt="Alt text"></li>
<li>但是，从程序运行的角度讲，我们总是希望能够用以足够大的，乃至近乎无限的存储空间。  </li>
<li>因为局部性原理的存在，使Memory Hierarchy成为可能。</li>
</ol>
</li>
</ol>
<p>2.什么是Memory Hierarchy?<br>    Memory hierarchy”（内存层次结构）是指一种组织和管理计算机内存系统的方式，它将不同类型的存储按照速度、成本和容量进行分层。所有的内存地址空间构建在一个最大的，同时也是最慢的内存结构上，而每一级的更快、更小的内存构成上一级的一个子集。</p>
<p>3.Cache的概念。<br>   缓存（Cache）是计算机体系结构中的一个关键组件，用于存储临时数据，以便快速访问。它位于处理器和主内存之间，旨在减少处理器访问主内存所需的平均时间。<br>   <strong>速度</strong>：缓存比主内存快得多，但比处理器内部的寄存器慢。<br>    <strong>大小</strong>：一般而言，缓存比主内存小得多，因此只能存储有限的数据。<br>    <strong>临时存储</strong>：缓存存储最近或最频繁使用的数据，以便快速访问。<br>    <strong>透明性</strong>：对于程序和用户来说，缓存的存在和操作通常是透明的。  </p>
<h3 id="Cache的原理及设计原则"><a href="#Cache的原理及设计原则" class="headerlink" title="Cache的原理及设计原则"></a>Cache的原理及设计原则</h3><ol>
<li><p>原理：本质上讲，Cache能够起效还是利用了程序的局部性原理。<br> 时间局部性：如果一个数据项最近被访问过，那么它在不久的将来可能会被再次访问。<br> 空间局部性：如果一个数据项被访问，那么它附近的数据项不久后也可能被访问。</p>
</li>
<li><p>Cache的设计主要需要考虑以下因素：  </p>
<ol>
<li>数据的摆放：什么样的数据可以从内存中放入Cache，以及按照什么样的规则摆放？ （<strong>全相联、直接映射、多路组相联</strong>）   </li>
<li>数据的寻找：数据摆放之后，如何寻找到想要的数据？（<strong>寻址策略，cache miss,hit</strong>）      </li>
<li>如何进行数据块的更换？（<strong>FIFO,LRU</strong>）  </li>
<li>对cache进行写操作时，采用何种写策略？(<strong>Write through、Write Back</strong>)</li>
</ol>
</li>
</ol>
<h4 id="数据块的摆放-Block-Placement"><a href="#数据块的摆放-Block-Placement" class="headerlink" title="数据块的摆放(Block Placement)"></a>数据块的摆放(Block Placement)</h4><p><img src="/2024/02/16/Computer-Architecture/image-10.png" alt="Alt text"></p>
<p><strong>全相联</strong>：任何一个数据块可以放在Cache的任何位置。<br>    优点：可以充分利用Cache的空间。缺点：数据寻址的开销增大  （一般不用这个）</p>
<p><strong>直接映射</strong>：数据块经过某种映射规则（通常是简单哈希，如编号 mod 8）后放入相应编号的Block.  (mod 几取决于cache中的block个数)<br>    优点：寻址方便  缺点，容易造成空间浪费，导致cache miss和频繁的数据换入换出</p>
<p><strong>多路组相联</strong>：是以上二者的折中，首先将cache中的block分路，一个数据块经过映射后，可以任何一个路的对应位置。（一个块有n个位置可放称作n路组相连，注意区分<strong>路</strong>和<strong>组</strong>）</p>
<h4 id="数据块的寻址"><a href="#数据块的寻址" class="headerlink" title="数据块的寻址"></a>数据块的寻址</h4><p>不同的摆放策略带来不同的寻址（或地址编码）方式：<br>以多路组相联为例：<br> <img src="/2024/02/16/Computer-Architecture/image-11.png" alt="Alt text"></p>
<p> 不同数据的作用： offset的作用是在block内进行索引，首先需要明确的是，计算机系统中的地址索引通常以字节Byte为单位，因此，如果一个Block的容量大于1个字节（通常是16B即4Words），则需要进行bolck内的偏移(offset)。<br> index的大小等于set中block的个数。(如每个set 拥有256个blocks，则index为8位)。<br> Tag作为地址的剩余位，一起写入cache中，用于作为标签比较，Tag一致则说明cache命中。</p>
<p> <img src="/2024/02/16/Computer-Architecture/image-12.png" alt="Alt text"></p>
<p>上述多路组相联的寻址策略，是直接根据index取出所有way中的对应数据，然后通过tag比对丢弃剩余的数据，只保留所需要的数据。<br>对于直接映射，地址编码中的offset用于块内的字索引。<br>对于全相联，地址编码中不存在index。  </p>
<p>例题：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-13.png" alt="Alt text"></p>
<p>解：4路,一共1KB,每路256B，缓存行32B,行数为256&#x2F;32 &#x3D; 8，index为3，offset为5，tag4位。</p>
<p><strong>（考试必考，为数不多可以出计算题的地方）</strong></p>
<h4 id="数据块替换策略"><a href="#数据块替换策略" class="headerlink" title="数据块替换策略"></a>数据块替换策略</h4><p>分情况讨论：  </p>
<ol>
<li>处理器在Cache中拿到了想要的数据(Tag比对正确，Valid有效)，称为Cache hit,皆大欢喜。</li>
<li>Tag比对失败，或Valid无效，需要对Cache进行Block的替换，称为Cache miss。<br> 对于直接映射的策略，则直接进行一次映射然后进行替换。<br> 对于全相联或多路组相联，则需要考虑具体替换哪一路中的数据。 具体策略可以有：完全随机，LRU(Least recently used),FIFO(First in First out)。</li>
</ol>
<h4 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h4><p>核心矛盾：对cache中的数据进行写操作，导致cache和主存中的数据产生不一致，此时有2种选择：</p>
<ol>
<li>立即更新主存中的数据(称为写穿透，write through)</li>
<li>额外增加一个dirty位，当一个被改写的数据块被从cache换出时，再将主存中的数据进行更新,称为(write back)</li>
</ol>
<p>一般都是用write back,因为write through开销太大。</p>
<p>一种解决写主存耗时过长的策略： write buffer。<br><img src="/2024/02/16/Computer-Architecture/image-14.png" alt="Alt text"></p>
<p>把要写的数据丢给buffer让它写，然后接着干自己的活。（write back 和write through都能用）</p>
<p>当写miss发生时，write through有2中选择，直接改写主存中的数据，而不把数据搬入cache,或者既写又搬。对应write back,一般而言需要先把数据搬入主存。</p>
<h4 id="Cache-性能对CPI的影响"><a href="#Cache-性能对CPI的影响" class="headerlink" title="Cache 性能对CPI的影响"></a>Cache 性能对CPI的影响</h4><p><img src="/2024/02/16/Computer-Architecture/image-15.png" alt="Alt text"></p>
<p>例题：<br><img src="/2024/02/16/Computer-Architecture/image-16.png" alt="Alt text"></p>
<p>解：一开始的CPI为1，每条指令耗时1个周期，4Ghz的处理器，每个周期时长为0.25ns，故每条指令的平均耗时为0.25ns。2%的Miss rate,每条指令的平均耗时变为：（$0.02\times 100ns+ 0.25ns &#x3D; 2.25ns$ ）</p>
<p>增加2级cache,每条指令的平均耗时变为：($0.005\times 100ns + 0.02\times 5 ns +  0.25ns &#x3D; 0.85ns$)</p>
<p>加速比： $2.25&#x2F;0.85 &#x3D; 2.6$</p>
<p>或从CPI角度进行计算：一级cache的失效代价为：$100ns&#x2F;0.25ns &#x3D; 400$个clock cycle,<br>因此平均CPI为：$1+0.02\times 400 &#x3D; 9$,</p>
<p>增加2级缓存后，cache2的访问或miss需要：<br>$5ns&#x2F;0.25ns &#x3D; 20$个clock cycle,<br> CPI为：$1+0.02\times 20 + 0.005\times 400&#x3D; 3.4$</p>
<p> 加速比：$9&#x2F;3.4 &#x3D; 2.6$</p>
<h4 id="影响cache性能的4C因素"><a href="#影响cache性能的4C因素" class="headerlink" title="影响cache性能的4C因素"></a>影响cache性能的4C因素</h4><ol>
<li><p>强制性缺失（Compulsory Misses）</p>
<ol>
<li>这些缺失发生在第一次访问数据时，因为这时数据还没有被加载到缓存中。</li>
<li>强制性缺失也被称为“冷启动缺失”或“首次访问缺失”。</li>
<li>减少强制性缺失的方法有限，因为它们是程序运行的必然结果。预取策略（将数据提前加载到缓存中）可以在一定程度上帮助减少这类缺失。</li>
</ol>
</li>
<li><p>容量缺失（Capacity Misses）</p>
<ol>
<li>当缓存的容量不足以存储所有需要的数据时，就会发生容量缺失。</li>
<li>这种缺失表明缓存无法容纳程序工作集（即同时活跃的数据集合）。</li>
<li>增加缓存大小是减少容量缺失的直接方法，但这也会增加成本和可能增加访问延迟。</li>
</ol>
</li>
<li><p>冲突缺失（Conflict Misses）</p>
<ol>
<li>冲突缺失发生在缓存可以容纳更多数据，但由于缓存映射策略（如直接映射或组相联映射）的限2制，不同的数据块争用相同的缓存位置。</li>
<li>在直接映射缓存中，这种情况最为常见。</li>
<li>通过使用更复杂的映射策略（如全相联或更高程度的组相联）可以减少冲突缺失，但这可能增加硬件复杂性和成本。</li>
</ol>
</li>
<li><p>一致性问题（Coherency）</p>
<ol>
<li>在多核或多处理器系统中，维持缓存一致性是一个重要问题。</li>
<li>缓存一致性问题是指当多个缓存副本存储相同数据时，确保所有副本在任何时刻都是一致的。</li>
<li>缓存一致性问题不直接导致缺失，但它会影响系统的整体性能和正确性。</li>
<li>解决方案包括缓存一致性协议，如MESI（修改、独占、共享、无效）协议。(第5章)</li>
</ol>
</li>
</ol>
<h3 id="6种基础的Cache性能优化"><a href="#6种基础的Cache性能优化" class="headerlink" title="6种基础的Cache性能优化"></a>6种基础的Cache性能优化</h3><p>考虑某种优化策略对Cache性能带来的影响，主要分为以下4个维度：  </p>
<ol>
<li>访存(命中)时间(hit time)</li>
<li>未命中率(Miss rate)</li>
<li>未命中的代价(Miss Penalty)</li>
<li>硬件设计复杂度或成本</li>
</ol>
<table>
<thead>
<tr>
<th>Methods</th>
<th>hit time</th>
<th>Miss rate</th>
<th>Miss penalty</th>
<th>Hardware Complexity or Cost</th>
</tr>
</thead>
<tbody><tr>
<td>Larger Block Size</td>
<td>$\uparrow$</td>
<td>$\downarrow$(主要是降低了Copullsory Miss)</td>
<td>$\uparrow$</td>
<td>几乎不变</td>
</tr>
<tr>
<td>Larger Capacity</td>
<td>$\uparrow$</td>
<td>$\downarrow$(主要是降低了Capacity Miss)</td>
<td>几乎不变</td>
<td>$\uparrow$</td>
</tr>
<tr>
<td>High Associativity</td>
<td>$\uparrow$</td>
<td>$\downarrow$(主要是降低了Conflict Miss)</td>
<td>几乎不变</td>
<td>$\uparrow$</td>
</tr>
<tr>
<td>More Cache Levels</td>
<td>不变</td>
<td>对于各级来说保持不变</td>
<td>$\downarrow$</td>
<td>$\uparrow$</td>
</tr>
<tr>
<td>Read misses over Write</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Address Translation(虚拟内存和TLB技术)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="10种进阶优化策略"><a href="#10种进阶优化策略" class="headerlink" title="10种进阶优化策略"></a>10种进阶优化策略</h3><table>
<thead>
<tr>
<th>Methods</th>
<th>hit time</th>
<th>Miss rate</th>
<th>Miss penalty</th>
<th>Hardware Complexity or Cost</th>
</tr>
</thead>
<tbody><tr>
<td>Small and simple L1 Cache</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Way Prediction</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Piplined Cache Accesses</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Non-blocking-Cache</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Multibanked Caches</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Critical word first and early restart</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Merging write buffer</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Compiler optimization</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hardware Prefetching</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Compiler-controled prefetching</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ol>
<li><p><strong>什么是虚拟存储器，为什么要有虚拟存储器？</strong><br> 在实际使用计算机时，一个进程(或程序)可能需要的地址空间过大，使得整个内存都无法装下。或者对于多个进程，每个进程都需要自己的地址空间，超过了内存空间的总量。因此需要虚拟内存技术。<br> 虚拟内存（Virtual Memory）是计算机系统内存管理的一项关键技术。它使得操作系统通过将物理存储器和内存一同抽象为虚拟内存，从而为软件提供比实际物理内存更大的内存空间。(可以理解为，将内存作为硬盘的cache,构成整个虚拟内存空间)虚拟内存的实现方法：MMU(Memory Management Unit)+OS(Operation System)</p>
</li>
<li><p><strong>虚拟内存的优点：</strong></p>
<ol>
<li>更大的内存空间：程序可以使用比实际物理内存更多的内存。</li>
<li>内存保护：每个程序有自己的虚拟地址空间，避免了程序间的内存冲突。</li>
<li>数据共享和内存映射文件：程序可以更容易地共享数据，并将文件直接映射到内存中，以提高数据访问速度。</li>
</ol>
</li>
<li><p><strong>虚拟地址和物理地址</strong>：虚拟地址（virtual address）是程序员看到的虚拟地址空间。物理地址（physical address）是主存或硬盘上的实际地址。虚拟内存为每个程序提供了一种看似独占的内存抽象，称为虚拟地址空间。这意味着每个程序都认为自己拥有连续的、完整的内存空间，而实际上，这些空间可能是非连续的，甚至不完全存在于物理内存中。<br><img src="/2024/02/16/Computer-Architecture/image-17.png" alt="Alt text"></p>
</li>
</ol>
<h4 id="虚拟地址和物理地址的转换"><a href="#虚拟地址和物理地址的转换" class="headerlink" title="虚拟地址和物理地址的转换"></a>虚拟地址和物理地址的转换</h4><ol>
<li><p>页（Paging）：虚拟内存通常以“页”的形式组织，每页是一个固定大小的内存块（例如4K）。虚拟地址空间被分割成多个这样的页，它们可以独立地映射到物理内存中的页，或者在需要时存储到磁盘上。</p>
</li>
<li><p>页表（Page Table）：操作系统维护一个页表来追踪虚拟页和物理页之间的映射关系。当程序访问其虚拟内存中的地址时，页表用来查找相应的物理内存地址。</p>
</li>
</ol>
<p><img src="/2024/02/16/Computer-Architecture/image-18.png" alt="Alt text"><br><img src="/2024/02/16/Computer-Architecture/image-19.png" alt="Alt text"><br>3个关键问题：</p>
<ol>
<li><p>页表放在哪？<br> 放在内存中，通过虚拟地址的virtual page number,进行查表，得到physical page number。</p>
</li>
<li><p>页表放在内存中，怎么找到它？<br> CPU中专门有一个page table register,记录了页表的首地址(相当于一个指针)。</p>
</li>
<li><p>页表如何工作？<br> 每个进程有自己独立的页表（意味着独立的地址空间）、PC以及寄存器的值。存储在内存中的不同位置。当OS进行进程切换时，CPU读入对应进程的页表寄存器，PC以及其它状态寄存器，该进程便转为Active 状态。</p>
</li>
</ol>
<h4 id="缺页中断（Page-Fault）"><a href="#缺页中断（Page-Fault）" class="headerlink" title="缺页中断（Page Fault）"></a>缺页中断（Page Fault）</h4><p>当程序访问的虚拟内存页不在物理内存中时，会发生缺页中断。操作系统将处理这种中断，从磁盘中加载所需的页到物理内存，并更新页表。</p>
<p>由于磁盘的访问时间很长，此时操作系统会进行进程切换。</p>
<p>缺页后的替换策略，通常使用LRU算法。一个由OS实现的伪LRU算法：<br><img src="/2024/02/16/Computer-Architecture/image-20.png" alt="Alt text"></p>
<h4 id="快表TLB-Translation-Look-aside-Buffer"><a href="#快表TLB-Translation-Look-aside-Buffer" class="headerlink" title="快表TLB(Translation Look-aside Buffer)"></a>快表TLB(Translation Look-aside Buffer)</h4><ol>
<li><p><strong>为什么要有TLB？</strong><br>在虚拟内存的背景下，CPU拿到一个在内存中的数据，需要经过以下阶段： </p>
<ol>
<li>访问页表，根据虚拟地址的virtual page number,进行查表，得到physical page number。（相当于访问了一次，内存）。</li>
<li>根据Physical page number，和virtual address中的page offset结合，得到实际的物理地址，根据这个物理地址，再次访问内存。</li>
</ol>
<p>这个过程的问题在于，每当想要拿到一个在内存中的数据，需要访问2次内存。能否加速这个过程？</p>
</li>
<li><p><strong>TLB的原理</strong><br> TLB的原理就一句话，将部分使用频繁的页表表项建立为一个cache。TLB是一个小型、高速的缓存，存储了最近使用的一小部分虚拟地址到物理地址的映射关系。</p>
<p> <img src="/2024/02/16/Computer-Architecture/image-21.png" alt="Alt text"></p>
<p> <strong>注意：不是说TLB放在cache里，而是TLB自己就是一个cache。是专门针对页表建立的cache。</strong></p>
</li>
<li><p><strong>TLB Miss</strong><br> 只要是cache，就会有cache miss。TLB miss 的情况和cache miss类似，但是需要考虑页表中也不存在对应页的情况(相当于2级缓存全部miss)（缺页中断）</p>
</li>
</ol>
<h4 id="TLB和cache的交互"><a href="#TLB和cache的交互" class="headerlink" title="TLB和cache的交互"></a>TLB和cache的交互</h4><p>在使用了虚拟内存和TLB后，引入一个新的问题，TLB和cache之间如何交互？<br>具体来讲，CPU通过一个地址访问cache时，这个地址是虚拟地址，还是物理地址？</p>
<ol>
<li><p>PIPT（Physically Indexed, Physically Tagged）<br><img src="/2024/02/16/Computer-Architecture/image-22.png" alt="Alt text"></p>
<ol>
<li>在这种方式中，缓存使用物理地址进行索引和标记。  </li>
<li>这要求在访问缓存之前，必须先通过TLB将虚拟地址翻译成物理地址。</li>
<li>物理寻址的优势在于它避免了缓存别名问题（即多个虚拟地址映射到同一物理地址的情况），但它增加了访问缓存之前的延迟。<br>优点是简单，缺点是相当于访问了2次cache。</li>
</ol>
</li>
<li><p>VIVT（Virtually Indexed, Virtually Tagged）</p>
<ol>
<li>在这种方式中，缓存使用虚拟地址进行索引和标记。</li>
<li>这允许直接使用虚拟地址访问缓存，无需等待TLB翻译，从而减少了访问延迟。</li>
<li>但虚拟寻址带来了缓存一致性的问题，因为不同的虚拟地址可能映射到相同的物理地址。</li>
</ol>
</li>
<li><p>VIPT（Virtually Indexed, Physically Tagged）</p>
<ol>
<li><p>索引（Indexing）：缓存使用虚拟地址进行索引。这意味着在访问缓存以确定一个缓存行是否存在时，不需要等待虚拟地址到物理地址的转换。这样可以减少访问缓存的延迟，因为索引操作可以并行于TLB的地址翻译。</p>
</li>
<li><p>标记（Tagging）：缓存使用物理地址的标记。这意味着一旦确定了缓存行的位置，缓存使用物理地址的标签来确定是否命中。这样做的好处是维护缓存一致性和避免缓存别名问题，因为物理地址是全局唯一的。</p>
</li>
<li><p>地址转换：在VIPT缓存中，地址转换（即从虚拟地址到物理地址的转换）仍然需要进行，但其时间可以与访问缓存的索引过程重叠。</p>
</li>
</ol>
</li>
<li><p>PIVT（Physically Indexed, Virtually Tagged）<br> 理论上存在，但没啥用</p>
</li>
</ol>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>首先考虑一个页表大小的问题：假设有32位虚拟地址，每页大小为4KB, 每个页表表项(PTE, Page Table Entry)大小为4B。</p>
<p>32位地址能够编码的页数为： $2^{32}&#x2F;4K &#x3D; 2^{20}$<br>而每个页表表项大小为4B,为了存储所有这些表项，页表的大小为：$2^{20}\times4B &#x3D; 4MB$<br>也就是说，仅存储页表，就需要消耗主存中4MB中的空间。</p>
<p>如果是64位，这个数字变成 $2^{54}MB&#x3D;2^{44}GB$远远超过了内存的全部大小！！</p>
<p>因此需要多级页表。将上述4MB的页表分为1K个小页表。每个小页表大小为4KB，对应1000个页。将每个小页表看作一个需要寻址的地址。对这1k个小页表再建立一个页表，则新的页表有1000个表项，每个表项的索引长度为10。加上标签后表项大小变为4B，这个新的“页表的页表”的大小为1000*4B&#x3D;4KB，这样，只需要将这个二级页表放入主存，然后将部分一级页表(被分割的小页表)也放入主存，就能减少主存中的页表占用大小。</p>
<p>二级页表之所以能减少对主存空间的占用，主要是因为并不是所有的页表都需要常驻在主存中。这种设计允许操作系统按需加载和卸载页表，从而有效地管理大型虚拟地址空间，而不必为每个可能的虚拟地址都保留固定的物理内存空间。</p>
<h2 id="Chapter-3-指令级并行及其扩展"><a href="#Chapter-3-指令级并行及其扩展" class="headerlink" title="Chapter 3 指令级并行及其扩展"></a>Chapter 3 指令级并行及其扩展</h2><p>指令级并行的实现原理：流水线技术(Piplining)</p>
<p>并行的问题：三种Hazard:</p>
<ol>
<li><p><strong>结构冲突（Structural Hazards）</strong></p>
<ol>
<li>定义：当硬件资源不足以支持所有流水线阶段同时进行时，就会发生结构冲突。</li>
<li>举例：如果只有一个内存单元，但在同一时刻，流水线中的一个阶段需要读取指令，而另一个阶段需要读写数据，这就会导致结构冲突。</li>
<li>解决办法：增加资源（如多个内存单元、专用指令和数据缓存等），或者在设计时对资源进行时间复用。</li>
<li></li>
</ol>
</li>
<li><p><strong>数据冲突（Data Hazards）</strong></p>
<ol>
<li>定义：当流水线中的指令依赖于前一条或多条指令的结果时，就会发生数据冲突。</li>
<li>类型：<br> RAW（Read After Write）：后续指令需要读取前一条指令写入的数据。<br> WAR（Write After Read）：写入操作与前面的读取操作冲突。<br> WAW（Write After Write）：两条指令写入同一位置。  </li>
<li>解决办法：数据前递（Data Forwarding）来绕过这些冲突，指令重排（Instruction Reordering），或者在必要时暂停（Stalling）流水线。</li>
</ol>
</li>
<li><p><strong>控制冲突（Control Hazards）</strong> </p>
<ol>
<li>定义：当流水线中的指令修改了程序的控制流（如跳转和分支）时，就会发生控制冲突。</li>
<li>原因：由于流水线中后续的指令已经开始执行，但分支指令的结果尚未确定，因此不清楚这些指令是否应该继续。</li>
<li>解决办法：分支预测（Branch Prediction）来猜测分支的结果，延迟槽（Delay Slot）来填充分支决定之前的空闲周期，或者在分支决策确定前暂停流水线。</li>
</ol>
</li>
</ol>
<h3 id="三种data-hazard"><a href="#三种data-hazard" class="headerlink" title="三种data hazard:"></a>三种data hazard:</h3><h4 id="RAW-read-after-write"><a href="#RAW-read-after-write" class="headerlink" title="RAW(read after write)"></a>RAW(read after write)</h4><p><img src="/2024/02/16/Computer-Architecture/image-24.png" alt="Alt text"></p>
<p>写后读，第一条指令在第五个cycle才能写回结果，而第二条指令在第3个cycle就读了，产生stall.</p>
<p>RAW是真相关，只能通过添加bypassing改善或stall。</p>
<h4 id="WAR（读后写）"><a href="#WAR（读后写）" class="headerlink" title="WAR（读后写）"></a>WAR（读后写）</h4><p><img src="/2024/02/16/Computer-Architecture/image-25.png" alt="Alt text"></p>
<p>其实不影响，只是名字重了，所以也叫名相关(name dependent)，或者反相关，名相关的唯一问题在于，编译器进行指令重排的时候会产生问题，因此需要进行寄存器的重命名。</p>
<h4 id="WAW（写后写）"><a href="#WAW（写后写）" class="headerlink" title="WAW（写后写）"></a>WAW（写后写）</h4><p>同理，也是一种名称相关，可以通过寄存器重命名解决。</p>
<h4 id="解决真相关：bypassing和-forwarding"><a href="#解决真相关：bypassing和-forwarding" class="headerlink" title="解决真相关：bypassing和 forwarding"></a>解决真相关：bypassing和 forwarding</h4><p><img src="/2024/02/16/Computer-Architecture/image-26.png" alt="Alt text"></p>
<p>通过前递解决了一般的计算指令的RAW</p>
<p>对应load类指令的写后读，则还需要1周期的stall:<br><img src="/2024/02/16/Computer-Architecture/image-27.png" alt="Alt text"></p>
<p>增加相关单元后的流水线：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-29.png" alt="Alt text"></p>
<p>forwarding 单元的原理：通过比较MEM阶段和wb阶段的目的寄存器以及id阶段的源寄存器判断是否需要进行前递。</p>
<p>Hazard detection 单元主要负责检查是否存在ld,alu类型的RAW,这种类型的hazard需要stall流水线一个周期。</p>
<h3 id="Control-Hazard"><a href="#Control-Hazard" class="headerlink" title="Control Hazard"></a>Control Hazard</h3><p>1.control Hazard产生的原因：PC总是按顺序取指令，而分支条件跳转指令要到EX阶段才能判断具体要取的指令，此时已经取了新的指令进来，而新取的指令可能是错的。</p>
<p>无任何硬件优化下，每次分支产生3个cycle的penalty:<br><img src="/2024/02/16/Computer-Architecture/image-33.png" alt="Alt text"><br>解决思路：</p>
<ol>
<li><p>直接暂停流水线：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-30.png" alt="Alt text"></p>
<p>由于需要译码之后才能知道这是一条分支指令，因此还是多取了1条指令。</p>
</li>
<li><p>predict-not-taken<br> <img src="/2024/02/16/Computer-Architecture/image-31.png" alt="Alt text"></p>
<p> 每次都假设不发生跳转，如果猜对了，则不会有stall,猜错了则冲刷流水线，取相应的指令。猜测了的开销和每次停顿是一样的。</p>
<p> <img src="/2024/02/16/Computer-Architecture/image-32.png" alt="Alt text"></p>
<p> 在ID阶段添加一些硬件，使得提前一个周期得到分支结果和目标的PC值。(这样就只用冲刷1条指令，就是上面表格的结果。)</p>
</li>
</ol>
<h3 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h3><ol>
<li><p>为什么需要分支预测？已经分支预测为什么有效？</p>
<ol>
<li>对于更深的流水线，分支指令对性能的影响增大。而现代的面向对象编程(Object-oriented Programming)中，存在大量分支场景。</li>
<li>分支预测能够工作的原因：程序的运行总是有某种规律，使得分支的发生与否能够被预测（时间上的局部性原理）。指令序列总是不可避免的带有人类思维的痕迹，因此是可预测的。</li>
</ol>
</li>
<li><p>分支预测预测什么？<br> <strong>分支跳转的方向</strong>(taken or not taken),<strong>目标PC的地址</strong>(address)。</p>
</li>
</ol>
<h3 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h3><h4 id="BTB（Branch-Target-Buffer）-和BHT（Branch-History-Table）"><a href="#BTB（Branch-Target-Buffer）-和BHT（Branch-History-Table）" class="headerlink" title="BTB（Branch Target Buffer） 和BHT（Branch History Table）:"></a>BTB（Branch Target Buffer） 和BHT（Branch History Table）:</h4><p><img src="/2024/02/16/Computer-Architecture/image-34.png" alt="Alt text"></p>
<p>BHT：每条不同的PC指令映射为BHT中的一个条目，记录了该条指令跳转还是不跳转。通过branch指令的历史行为(taken or not taken)，来预测指令本次是否跳转。</p>
<p>BTB：BHT只负责预测指令发生与否，而BTB存储了指令的目标地址。这样，如果BHT预测指令跳转，BTB就提供相应的PC地址，从而实现快速的指令切换。<br><img src="/2024/02/16/Computer-Architecture/image-40.png" alt="Alt text"><br>BTB的问题：只记录了PC值，还是要走一遍取值，译码，执行的过程。</p>
<p>一种改进策略：<br><img src="/2024/02/16/Computer-Architecture/image-41.png" alt="Alt text"></p>
<p>不讲武德，直接把指令取好。不是记录PC的值，而是记录指令本身，这样如果BHT预测发生跳转，BTB直接可以拿出相应的指令，跳过了IF阶段。</p>
<h4 id="一位分支预测的缺点："><a href="#一位分支预测的缺点：" class="headerlink" title="一位分支预测的缺点："></a>一位分支预测的缺点：</h4><p><img src="/2024/02/16/Computer-Architecture/image-36.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;++<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">        loop...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑这样的一个两层循环。一开始（j&#x3D;(0,n-1)），内层循环每次都taken，外层循环每次都not taken，当内层循环结束时(j&#x3D;n)，会执行一次外层循环，此时实际的执行效果变为：内层循环not taken,外层循环taken。而根据BHT的历史记录，会连续预测错误2次分支指令，造成性能损失。</p>
<h4 id="改进：2位分支预测"><a href="#改进：2位分支预测" class="headerlink" title="改进：2位分支预测"></a>改进：2位分支预测</h4><p><img src="/2024/02/16/Computer-Architecture/image-37.png" alt="Alt text"></p>
<p><strong>2位分支预测的核心思路</strong>：通过2位比特编码，得到四个预测状态（taken,weak taken,weak not taken, not taken）。同样考虑上面的那个例子：<br>当进行一遍内层循环时，由于内层循环每次都taken,会被记录为(taken),外层循环由于只进行了一次，所以被记录为(weak not taken)，这样，当内外循环交替时，只有内层循环的预测出现错误，而外层循环能正确预测。</p>
<h4 id="高级预测方法：Correlating-Branch-Predictor（相关分支预测器）"><a href="#高级预测方法：Correlating-Branch-Predictor（相关分支预测器）" class="headerlink" title="高级预测方法：Correlating Branch Predictor（相关分支预测器）"></a>高级预测方法：Correlating Branch Predictor（相关分支预测器）</h4><p><strong>核心思路：</strong>：不止关心本条分支指令的历史，而是关心全局的（或其它与本条指令相关的）分支指令的历史，从而实现更好的预测。（从$y_{n+1} &#x3D; f(y_{n})$变为：$y_{n+1}^{(1)} &#x3D; f(y_{n}^{(1)},y_{n}^{(2)},y_{n}^{(3)},…,y_{n}^{(m)})$）</p>
<p>实现方法：  (m,n)预测：用前m条指令和n位的状态来预测本次分支。<br>举例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-38.png" alt="Alt text"></p>
<ol>
<li>(1,1)相当于一个BHT,没啥好说的。</li>
<li>(m,1)相当于记录下m条指令的历史状态，对应一个1位的预测器。</li>
<li>(m,2)每个m位预测历史对应一个n位的编码，通过对n位编码进行某种解释，得到跳转与否的预测。<br><img src="/2024/02/16/Computer-Architecture/image-39.png" alt="Alt text"></li>
</ol>
<h4 id="Tournament-Predictor-（锦标赛预测器）"><a href="#Tournament-Predictor-（锦标赛预测器）" class="headerlink" title="Tournament Predictor （锦标赛预测器）"></a>Tournament Predictor （锦标赛预测器）</h4><p><strong>核心思路：</strong> 养蛊，让几种不同的预测方法自己内卷，哪个效果好就用哪个。</p>
<h3 id="Software-Scheduling-for-Exposing-ILP（软件调度的ILP）"><a href="#Software-Scheduling-for-Exposing-ILP（软件调度的ILP）" class="headerlink" title="Software Scheduling for Exposing ILP（软件调度的ILP）"></a>Software Scheduling for Exposing ILP（软件调度的ILP）</h3><p><strong>核心思路：</strong> 聪明的编译器会根据代码的结构尽量减少stall。</p>
<p>举例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-42.png" alt="Alt text"><br>每次add前要等load把数据读出来，需要一个周期stall（加了forwarding单元后）。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-43.png" alt="Alt text"><br>通过循环内指令的重排，减少了stall。 (区别就是把 DADDUI R1,R1, #-8 这条判断循环跳转的指令挪到上面去了)</p>
<p><img src="/2024/02/16/Computer-Architecture/image-44.png" alt="Alt text"></p>
<p>更近一步，把循环4倍展开。可以有更多指令用于重排。进一步减少stall。问题在于使用了更多的寄存器，需要保证寄存器够用。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-45.png" alt="Alt text"></p>
<h3 id="Dynamic-Scheduling-动态调度"><a href="#Dynamic-Scheduling-动态调度" class="headerlink" title="Dynamic Scheduling 动态调度"></a>Dynamic Scheduling 动态调度</h3><p>首先考虑一个顺序发射，顺序执行(in order issue, in order execution)的例子：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-46.png" alt="Alt text"><br>F0存在经典的RAW，因而会有stall（没有forwarding单元，或者流水深度过长的时候）。</p>
<p>如果将第二条指令和第三条指令交换顺序执行，则不存在上述问题。能这么做的原因在于，两条指令直接不存在相关性。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-47.png" alt="Alt text"><br>对于WAW,WAR,简单的寄存器重命名就可以解决依赖问题。</p>
<h4 id="OOO-out-of-order-的思想"><a href="#OOO-out-of-order-的思想" class="headerlink" title="OOO(out of order)的思想"></a>OOO(out of order)的思想</h4><p>stall会出现的本质原因，在于指令被译码结束后，其操作数因为各种原因还没有准备好(比如需要等其它指令计算结束，或相关操作数在memory中需要load)。既然如此，指令译码结束后，可以检测其操作数状态，只有操作数准备好的指令，才将其放入对应的计算资源中执行相应操作。从而最大程度减小stall。</p>
<p>另外，尽管指令是乱序执行的，但让处理器在指令完成后对结果进行重排序，以确保与程序指定的顺序一致，就可以保证程序的正确性。</p>
<p>这方面的一个典型例子是Tomasulo 算法。</p>
<h4 id="Tomasulo-Algorithm"><a href="#Tomasulo-Algorithm" class="headerlink" title="Tomasulo Algorithm"></a>Tomasulo Algorithm</h4><p>实现OOO的关键在于硬件支持：一个典型的Tomasulo算法需要以下功能单元：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-48.png" alt="Alt text"></p>
<ol>
<li><p><strong>保留站（Reservation Stations）</strong></p>
<ol>
<li>作用：保留站用于暂存即将执行的指令，同时跟踪指令所需的操作数是否已经可用。</li>
<li>功能：每个保留站都与一个特定的执行单元相关联，并存储指令、操作数、操作数的来源以及执行状态等信息。保留站还负责检测操作数的可用性，并在操作数准备就绪时触发指令的执行。</li>
</ol>
</li>
<li><p><strong>寄存器重命名（Register Renaming）</strong></p>
<ol>
<li>作用：减少WAR（Write After Read）和WAW（Write After Write）冲突，提高指令流的并行度。</li>
<li>功能：使用保留站中的标签而非真实的寄存器名称，从而允许多个指令同时对同一寄存器进行操作，而不会相互干扰。</li>
</ol>
</li>
<li><p><strong>公共数据总线（Common Data Bus，CDB）</strong></p>
<ol>
<li>作用：用于广播执行单元完成的操作结果，同时通知等待这些结果的其它保留站和寄存器。</li>
<li>功能：任何执行单元完成操作后，会将结果放在CDB上。保留站和寄存器监听CDB，以获取它们需要的数据。</li>
</ol>
</li>
<li><p><strong>执行单元（Execution Units）</strong></p>
<ol>
<li>作用：执行具体的计算任务，如加法、乘法、逻辑操作等。</li>
<li>功能：根据保留站提供的指令和操作数进行计算，并将结果发送到CDB。</li>
</ol>
</li>
<li><p><strong>指令队列（Instruction Queue）</strong></p>
<ol>
<li>作用：暂存尚未处理的指令。</li>
<li>功能：指令队列按照程序顺序存储指令，然后将指令分发到相应的保留站。</li>
</ol>
</li>
<li><p><strong>load Buffers</strong></p>
<ol>
<li>作用：Load Buffers用于处理来自内存的加载（load）操作。</li>
<li>功能：当指令队列中出现一个加载操作时，该操作被放置在Load Buffer中。Load Buffer负责跟踪加载操作的地址计算，并在地址计算完成后从内存中获取数据。一旦数据加载完成，它就可以被送往执行单元或者直接写入寄存器。</li>
</ol>
</li>
<li><p><strong>Store Buffers</strong></p>
<ol>
<li>作用：Store Buffers用于处理写入内存的存储（store）操作。</li>
<li>功能：当指令队列中出现一个存储操作时，该操作被放置在Store Buffer中。Store Buffer负责跟踪存储操作的地址计算和待存储的数据。一旦地址和数据都准备好，存储操作就可以被提交到内存。</li>
</ol>
</li>
<li><p><strong>重排序缓冲区（Reorder Buffer，ROB，可选）</strong></p>
<ol>
<li>作用：确保即使在乱序执行的情况下，指令的结果也能按照程序顺序提交（commit），维护程序的正确性。</li>
<li>功能：ROB跟踪指令的执行状态，并在所有先行指令完成后按序提交结果。</li>
</ol>
</li>
</ol>
<h4 id="进一步理解："><a href="#进一步理解：" class="headerlink" title="进一步理解："></a>进一步理解：</h4><p><img src="/2024/02/16/Computer-Architecture/image-49.png" alt="Alt text"></p>
<p>一个Tomasulo 的算法表。其中各部分的解释如下：</p>
<ol>
<li><p><strong>Instruction status:</strong> 一条指令包含多种状态。Issue代表已经发射(放入了执行队列)，Execute表示被执行(放入了对应的执行单元)，Write Result表示执行完毕且结果已写回。 这部分只是便于理解算法本身，硬件中并不存在真实的结构。</p>
</li>
<li><p><strong>Reservation Stations:</strong> 保留站中指令的状态。</p>
<ol>
<li>Op：表示对应的操作。</li>
<li>Busy: 对应的执行单元处于忙碌状态，指令正在执行，或者对应的发射槽被占用。</li>
<li>Vj,Vk: 左右操作数的值。表示操作数具体放在哪个寄存器。如果Vj,Vk都有数，且对应的执行单元不busy,说明指令可以被执行。</li>
<li>Qj,Qk:即将产生Vj,Vk的操作。表示指令直接的依赖关系。也就是说，Qj和Vj互斥，Qk和Vk互斥，2个中只同时有一个有数。</li>
</ol>
</li>
<li><p><strong>Register Status：</strong> 寄存器与对应指令的关系，表明那条指令将写哪个寄存器。</p>
</li>
</ol>
<h4 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h4><p><img src="/2024/02/16/Computer-Architecture/image-50.png" alt="Alt text"><br>    初始状态</p>
<p><img src="/2024/02/16/Computer-Architecture/image-51.png" alt="Alt text"></p>
<p>第一条指令被发射，进入loads buffer，同时对应的寄存器F6处记录下Load1，表示Load1的结构将写入F6。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-52.png" alt="Alt text"></p>
<p>发射指令load2，和前面差不多</p>
<p><img src="/2024/02/16/Computer-Architecture/image-53.png" alt="Alt text"></p>
<p>第一条load指令执行完毕，拿到了操作数，但还没来得及写回。第三条mul指令被发射，进入保留站，对应的发射槽变为Busy。其右操作数F4是现成的，因此写在Vk，而左操作数依赖Load2的结果，写在Qj。由于此时load2还没执行完，因此这条乘法指令没发被执行。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-54.png" alt="Alt text"></p>
<p>下一条减法指令发射。第一条load指令已经将结果写入F6寄存器。因此减法指令可以直接拿到这个操作数Vj,而另一个操作数需要等待Load2写回。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-55.png" alt="Alt text"></p>
<p>Load2写回， Mul和sub指令都拿到了2个操作数，下一个周期就可以开始执行了。其余类似。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-56.png" alt="Alt text"><br>注意看上面的2条运算指令进入了complete阶段。</p>
<h4 id="Tumasulo的总结"><a href="#Tumasulo的总结" class="headerlink" title="Tumasulo的总结"></a>Tumasulo的总结</h4><p>很经典，体现了OOO的精髓。很有效率，但是硬件开销比较大。体</p>
<p>同时Common Data Bus的设计存在很大限制。因为它需要广播通知所有的保留站对应的操作数到了，从而存在以下几个问题：</p>
<ol>
<li>扇出（Fan-out）问题<br>挑战：CDB需要将数据同时广播给多个保留站和寄存器文件，这就导致了较大的扇出。高扇出会增加电路的负载，从而影响信号的传播时间和电路的响应速度。<br>影响：高扇出可能限制处理器的时钟频率，因为信号需要在一个时钟周期内在整个CDB上稳定下来。</li>
<li>功耗<br>挑战：广播机制意味着CDB在每次操作时都需要激活多个接收点，这增加了功耗。<br>影响：在功耗敏感的应用场景中，如移动设备或高性能计算，这可能是一个显著的问题。</li>
<li>硬件复杂性<br>挑战：实现一个高效且可靠的CDB需要复杂的硬件设计，尤其是在处理高速、高密度信号时。<br>影响：这增加了处理器设计的复杂性和成本。</li>
<li>争用和冲突<br>挑战：当多个执行单元几乎同时完成计算时，可能会出现对CDB的争用。<br>影响：必须有机制来处理这种争用，否则可能导致性能下降。</li>
</ol>
<h4 id="Dynamic-Scheduling的总结"><a href="#Dynamic-Scheduling的总结" class="headerlink" title="Dynamic Scheduling的总结"></a>Dynamic Scheduling的总结</h4><p><strong>优点</strong></p>
<ol>
<li><p>提高性能：通过允许指令乱序执行，动态调度可以减少因数据依赖性引起的延迟，提高处理器的执行效率。</p>
</li>
<li><p>提高资源利用率：动态调度允许处理器更有效地利用其执行单元，减少因指令等待而空闲的情况。</p>
</li>
<li><p>减少冲突：动态调度可以减少流水线中的结构冲突和数据冲突，尤其是在超标量和乱序执行的处理器中。</p>
</li>
<li><p>自适应性：动态调度可以根据指令流的实际情况动态调整，适应不同的程序和工作负载。</p>
</li>
<li><p>隐藏延迟：它可以有效地隐藏长延迟操作（如缓存未命中）的影响，通过执行其他独立指令来填充等待时间。</p>
</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><p>硬件复杂性：实现动态调度需要复杂的硬件支持，如保留站、重排序缓冲区和复杂的控制逻辑。</p>
</li>
<li><p>功耗增加：由于需要更多的硬件资源和更高的运算速度，动态调度的处理器通常消耗更多的功率。</p>
</li>
<li><p>设计挑战：设计一个高效且准确的动态调度算法是非常具有挑战性的，需要精确处理指令间的依赖和冲突。</p>
</li>
<li><p>成本增加：与简单的顺序执行处理器相比，动态调度处理器的制造成本更高。</p>
</li>
<li><p>时钟频率的限制：由于动态调度的复杂性，可能对处理器的最高时钟频率造成限制。</p>
</li>
</ol>
<h3 id="推断（Speculation）"><a href="#推断（Speculation）" class="headerlink" title="推断（Speculation）"></a>推断（Speculation）</h3><pre><code>Speculation = Dynamic Scheduling + Prediction
</code></pre>
<p>动态调度结合分支预测技术，提前执行一些可能用得到的指令。如果判断对了，皆大欢喜，如果判断失误，丢弃对应的指令结果，进行回滚(Roll back)。可以总结为: Out of order execution, in order commit.</p>
<h4 id="关键硬件-ROB（Reorded-Buffer）"><a href="#关键硬件-ROB（Reorded-Buffer）" class="headerlink" title="关键硬件: ROB（Reorded Buffer）"></a>关键硬件: ROB（Reorded Buffer）</h4><p><img src="/2024/02/16/Computer-Architecture/image-57.png" alt="Alt text"></p>
<h5 id="ROB的工作原理"><a href="#ROB的工作原理" class="headerlink" title="ROB的工作原理"></a>ROB的工作原理</h5><ol>
<li><p>指令进入ROB：当指令被分派（Dispatched）到流水线时，它们会进入ROB。每条指令在ROB中都有一个对应的条目。</p>
</li>
<li><p>指令执行：指令可以乱序执行，即按照数据依赖和执行单元的可用性进行执行，而不是严格按照程序顺序。执行过程中，指令的结果（如计算结果或加载的数据）暂时存储在ROB中，而不是直接写入寄存器或内存。</p>
</li>
<li><p>维护程序顺序：尽管指令是乱序执行的，ROB确保按照原始程序顺序“提交”（Commit）指令的结果。这意味着只有当ROB中所有先前的指令都已正确完成，一条指令的结果才能被提交到寄存器或内存。</p>
</li>
<li><p>处理分支和异常：如果处理器遇到分支预测错误或异常，ROB可以用来撤销或回滚错误预测的指令，并从正确的点重新开始执行。</p>
</li>
<li><p>结果提交：一旦确认指令可以安全提交，其结果就从ROB转移到相应的目的地，如寄存器文件或内存。这个提交过程保证了即使发生乱序执行，外部观察到的效果仍然符合程序的顺序执行。</p>
</li>
</ol>
<h5 id="ROB的重要性"><a href="#ROB的重要性" class="headerlink" title="ROB的重要性"></a>ROB的重要性</h5><ol>
<li>支持乱序执行：ROB使得处理器可以在保持程序语义的前提下自由地重排指令的执行顺序。</li>
<li>支持推测执行：ROB存储推测执行的结果，并在确定这些推测是正确的之后才进行提交。</li>
<li>保证异常处理的正确性：在发生异常或分支预测错误时，ROB提供了一种机制来撤销或回滚已经执行但尚未提交的指令。</li>
<li>隐藏延迟：通过允许后续独立指令先于前面的长延迟指令执行，ROB有助于隐藏延迟，提高处理器效率。</li>
</ol>
<h3 id="Multi-Issue多发射"><a href="#Multi-Issue多发射" class="headerlink" title="Multi Issue多发射"></a>Multi Issue多发射</h3><p>首先思考CPI这个概念：顾名思义，Clock Per Instruction，在流水下，最优的情况是每个周期就能执行一条指令，也就是说CPI&#x3D;1.那么问题来了，能不能进一步挖掘指令的并行性能，使CPI小于1？</p>
<p><strong>Multi Issue（多发射）</strong>技术是指处理器能够在每个时钟周期内发射（即开始执行）多条指令的能力。这种技术是超标量架构的一个关键特征，它允许处理器并行地执行多个操作，从而提高整体性能和处理器的吞吐量。</p>
<p>一个解决方法是，使用超长指令字(Very Long Instruction Word)VLIW。<br>每条超长指令是一系列简单指令的拼接。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-58.png" alt="Alt text"></p>
<h3 id="多线程Multi-Thread"><a href="#多线程Multi-Thread" class="headerlink" title="多线程Multi Thread"></a>多线程Multi Thread</h3><p>（待补充）</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="Chapter-4-DLP-in-Vector-SIMD-and-GPU-Architectures"><a href="#Chapter-4-DLP-in-Vector-SIMD-and-GPU-Architectures" class="headerlink" title="Chapter 4 DLP in Vector, SIMD, and GPU  Architectures"></a>Chapter 4 DLP in Vector, SIMD, and GPU  Architectures</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><h4 id="数据级并行（Data-level-parallelism-DLP）"><a href="#数据级并行（Data-level-parallelism-DLP）" class="headerlink" title="数据级并行（Data level parallelism, DLP）"></a>数据级并行（Data level parallelism, DLP）</h4><p>数据级并行是指同时对多个数据项执行相同的操作。这种并行性主要体现在在单个操作中处理多个数据项，而不是在多个操作上。在处理大量数据时，DLP特别有效，因为它可以显著加快数据处理速度。</p>
<h4 id="单指令多数据流（Single-Instruction-Multi-Data-SIMD）"><a href="#单指令多数据流（Single-Instruction-Multi-Data-SIMD）" class="headerlink" title="单指令多数据流（Single Instruction Multi Data,SIMD）"></a>单指令多数据流（Single Instruction Multi Data,SIMD）</h4><p>SIMD是实现数据级并行的一种常见方式。在SIMD架构中，单个指令控制多个处理单元同时对不同的数据执行相同的操作。这种方法在多媒体处理、科学计算和机器学习等领域非常有效，因为这些领域常常涉及到对大量数据执行重复的操作。</p>
<p>同时，由于SIMD的编程模型仍然是串行的，比较符合人类的思维逻辑，减小了编程的难度。</p>
<h4 id="向量处理器（Vector-Processor）"><a href="#向量处理器（Vector-Processor）" class="headerlink" title="向量处理器（Vector Processor）"></a>向量处理器（Vector Processor）</h4><p>向量处理器是一种专门的处理器，设计用来高效地执行SIMD操作。在向量处理器中，指令不是对单个数据项进行操作，而是对一个数据集合（向量）进行操作。每个向量指令可以同时对多个数据元素执行相同的操作，这使得向量处理器特别适合于那些需要大规模数值计算的应用。</p>
<h3 id="一个典型例子-VMIPS"><a href="#一个典型例子-VMIPS" class="headerlink" title="一个典型例子:VMIPS"></a>一个典型例子:VMIPS</h3><p><img src="/2024/02/16/Computer-Architecture/image-60.png" alt="Alt text"><br>在硬件上对寄存器和运算单元进行扩展，同时设计了新的指令，支持向量操作</p>
<p><img src="/2024/02/16/Computer-Architecture/image-59.png" alt="Alt text"></p>
<p>使用vector后，64个数据的操作指令减少到6条。</p>
<h5 id="向量体系结构的运行时间分析"><a href="#向量体系结构的运行时间分析" class="headerlink" title="向量体系结构的运行时间分析"></a>向量体系结构的运行时间分析</h5><p><img src="/2024/02/16/Computer-Architecture/image-61.png" alt="Alt text"><br>假设只有1个执行单元，多条指令可以同时发射，但需要顺序执行，此时执行时间约等于向量的长度。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-62.png" alt="Alt text"></p>
<p>在这张图上我们假设乘法单元和加法单元各有一个，则通过前递(forwarding)二者可以几乎并行的执行。</p>
<ol>
<li><p>Convoy<br>在向量处理器的上下文中，“Convoy”通常指一组可以同时发射（即开始执行）的向量指令。在某些向量处理器设计中，一组指令被打包成一个Convoy，这组指令共享相同的执行资源。Convoy的概念有助于优化指令流水线，提高处理器的吞吐量。</p>
</li>
<li><p>Chaining<br>“Chaining”是向量处理器中一种重要的性能优化技术。在Chaining中，一个向量指令的输出直接作为另一个向量指令的输入，而无需等待第一个指令完全完成。这种方法可以减少存储器访问和中间结果写回的开销，从而加速整个计算过程。</p>
</li>
<li><p>chime<br>向量处理器处理一个convoy的用时。m个convey则需要m个chime。<br>对应长度为$n$的向量，则需要$m\times$个周期来执行。</p>
<p>例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-63.png" alt="Alt text"></p>
</li>
</ol>
<h4 id="提升Vector性能的方法"><a href="#提升Vector性能的方法" class="headerlink" title="提升Vector性能的方法"></a>提升Vector性能的方法</h4><p><img src="/2024/02/16/Computer-Architecture/image-64.png" alt="Alt text"></p>
<h5 id="multiple-lanes"><a href="#multiple-lanes" class="headerlink" title="multiple lanes"></a>multiple lanes</h5><p><img src="/2024/02/16/Computer-Architecture/image-65.png" alt="Alt text"></p>
<p>最简单粗暴的方法：直接做多硬件资源，使各种功能单元数量翻倍。</p>
<h5 id="Vector-Length-Register"><a href="#Vector-Length-Register" class="headerlink" title="Vector Length Register"></a>Vector Length Register</h5><p>使用向量长度寄存器，达到能够支持任意长度向量的效果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">low = <span class="number">0</span>;</span><br><span class="line">VL = (n % MVL); <span class="comment">/*find odd-size piece using modulo op % */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= (n/MVL); j=j+<span class="number">1</span>) &#123; <span class="comment">/*outer loop*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt; (low+VL); i=i+<span class="number">1</span>) <span class="comment">/*runs for length VL*/</span></span><br><span class="line">        Y[i] = a * X[i] + Y[i] ; <span class="comment">/*main operation*/</span></span><br><span class="line">    low = low + VL; <span class="comment">/*start of next vector*/</span></span><br><span class="line">    VL = MVL; <span class="comment">/*reset the length to maximum vector length*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中MVL为Maximum Vector Length,即硬件支持的最大向量长度（如64）。这个大小对程序员来说是已知的。</p>
<h5 id="Vertor-Mask-Register"><a href="#Vertor-Mask-Register" class="headerlink" title="Vertor Mask Register"></a>Vertor Mask Register</h5><p>考虑如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i=i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (X[i] != <span class="number">0</span>)</span><br><span class="line">        X[i] = X[i] – Y[i];</span><br></pre></td></tr></table></figure>

<p>对一个向量中符合某种条件的代码进行操作。</p>
<p>此时可以使用Mask Vector</p>
<p>对应的汇编指令可以设计为：<br><img src="/2024/02/16/Computer-Architecture/image-67.png" alt="Alt text"></p>
<p>而在硬件支持方面，只需要在所有运算单元上增加一个enable信号，只有接收到enable信号的功能单元才执行操作，即可支持mask功能。</p>
<h5 id="Memory-Banks"><a href="#Memory-Banks" class="headerlink" title="Memory Banks"></a>Memory Banks</h5><p>使用多bank的内存，支持高带宽的并行存取。</p>
<p>此时需考虑bank conflict的情况。</p>
<p>如矩阵乘：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i=i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j=j+<span class="number">1</span>) &#123;</span><br><span class="line">        A[i][j] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k=k+<span class="number">1</span>)</span><br><span class="line">            A[i][j] = A[i][j] + B[i][k] * D[k][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于D矩阵的数据，如果存储在同一个bank中，会出现比较严重的bank conflict。例：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-68.png" alt="Alt text"></p>
<h5 id="Scatter-Gather-对稀疏的支持。"><a href="#Scatter-Gather-对稀疏的支持。" class="headerlink" title="Scatter-Gather 对稀疏的支持。"></a>Scatter-Gather 对稀疏的支持。</h5><p>考虑计算2个稀疏矩阵A和C的加法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">    A[K[i]] = A[K[i]]+C[K[i]];</span><br><span class="line">    A[M[i]] = A[M[i]]+C[M[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>K和M分别是A与C中非0元素位置的索引。需要的指令支持为：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-69.png" alt="Alt text"></p>
<h4 id="向量处理器的优缺点"><a href="#向量处理器的优缺点" class="headerlink" title="向量处理器的优缺点"></a>向量处理器的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>对于取值来说，向量处理器能够用更少的指令实现同样的功能，因此简化了取指。</li>
<li>简化了指令的发射执行。对于分支指令，由于向量指令能够合并分支，避免了一部分分支预测的开销。同时对于数据依赖检测的硬件实现也更简单。</li>
<li>更有效的内存访问。向量结构的访存地址通常更规则，结合memory的bank结构，能够更有效的存取数据，使得访存的延迟被摊销掉不少。</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>对于一些标量操作，仍然需要传统的标量单元来执行</li>
<li>难以进行精确的中断控制。因为是向量操作，无法进行有效的数据回滚</li>
<li>对编译器和程序员带来一定挑战，必须将原本的程序向量化</li>
<li>如果向量长度比较小，向量处理器通常并不高效</li>
<li>对某些特殊的应用类型的性能很一般(数据并行度比较差的程序)</li>
<li>需要对内存系统进行优化</li>
</ol>
<h3 id="GPGPU-General-Purpose-Graphics-Processing-Unit-通用图形处理器"><a href="#GPGPU-General-Purpose-Graphics-Processing-Unit-通用图形处理器" class="headerlink" title="GPGPU General Purpose Graphics Processing Unit 通用图形处理器"></a>GPGPU General Purpose Graphics Processing Unit 通用图形处理器</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>GPGPU</strong>（General-Purpose computing on Graphics Processing Units）指的是在图形处理单元（GPU）上进行的通用计算。这种技术利用了GPU的高并行处理能力来执行非图形相关的计算任务，特别是那些可以通过数据并行性来显著加速的任务。</p>
<p><strong>背景</strong><br>最初，GPU被设计用来处理计算机图形和图像相关的任务，例如渲染3D图形和处理视频内容。然而，人们逐渐意识到GPU强大的并行处理能力也非常适合进行科学计算、工程模拟、数据分析等任务。</p>
<p><strong>GPGPU的特点</strong><br>高度的数据并行性：GPU含有数百到数千个小型、高效的处理核心，能够同时处理大量数据。</p>
<p><strong>专用硬件加速</strong>：GPU包含专门设计的硬件，适用于执行浮点运算和向量运算。</p>
<p><strong>适用于特定类型的计算</strong>：GPGPU非常适合执行可以被分解为小的、独立的并行任务的计算，如矩阵运算、信号处理等。</p>
<p><strong>编程模型</strong>：利用GPGPU进行计算通常需要特定的编程模型和编程语言，如CUDA（Compute Unified Device Architecture，由NVIDIA开发）和OpenCL（Open Computing Language）。</p>
<h4 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h4><p>什么是编程？</p>
<p>编程模型（Programming Model）是指用于指导和简化特定类型程序设计的一套规则、概念和结构。它定义了程序中的数据和控制流结构，以及程序员与计算系统（如处理器、操作系统或整个计算平台）之间的交互方式。编程模型是编程范式（如面向对象编程、函数式编程）和具体技术实现（如API或编程框架）之间的中间层。</p>
<p>一般而言，编程模型包含以下3个方面：</p>
<ol>
<li>How to compute the wanted function(计算过程、算法)</li>
<li>How to organize the memory to serve the computation（存储管理）</li>
<li>How to map the function to the real hardware（控制、硬件配置）</li>
</ol>
<p>对于GPU这类并行架构来说，编程模型更关心以下几个方面：</p>
<ol>
<li>How to divide the workload (任务的切分)</li>
<li>How to communicate between the divided work（任务间通信）</li>
<li>How to synchronize the divided work（任务同步）</li>
</ol>
<h5 id="异构计算-Heterogeneous-computing"><a href="#异构计算-Heterogeneous-computing" class="headerlink" title="异构计算 Heterogeneous computing"></a>异构计算 Heterogeneous computing</h5><p>在程序员的视角，GPU编程是一种异构计算：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-70.png" alt="Alt text"></p>
<p>异构计算（Heterogeneous Computing）是一种计算范式，它涉及到在单个系统中结合使用多种类型的处理器或核心来提高计算效率和性能。这种系统通常包含不同种类的处理单元，如传统的中央处理器（CPU）、图形处理器（GPU）、数字信号处理器（DSP）和其他类型的专用加速器。</p>
<h5 id="GPGPU的线程模型："><a href="#GPGPU的线程模型：" class="headerlink" title="GPGPU的线程模型："></a>GPGPU的线程模型：</h5><p>NVIDIA GPU的线程模型是一个专门为其CUDA（Compute Unified Device Architecture）平台设计的并行计算架构。这个模型使得开发者能够有效地利用GPU的强大并行处理能力。在这个模型中，关键概念包括内核（Kernel）、网格（Grid）、块（Block）和线程（Thread）。</p>
<p><strong>Kernel（内核）</strong><br>含义：内核是在GPU上执行的一个函数。当你启动一个内核时，实际上是在告诉GPU同时执行许多线程的实例。<br>角色：每个内核代表了一个在GPU上并行执行的任务。在CUDA编程中，内核由特定的CUDA C&#x2F;C++函数构成，使用__global__声明修饰符标记。</p>
<p><strong>Grid（网格）</strong><br>含义：网格是一组块的集合。当一个内核被启动时，它会以网格的形式组织。<br>角色：网格代表了所有线程的总体组织结构，它定义了执行内核所需要的所有线程块。</p>
<p><strong>Block（块）</strong><br>含义：块是一组线程的集合，这些线程可以协同执行，并能够通过共享内存进行通信。<br>角色：每个块中的线程可以同步执行，并共享一定量的快速但容量有限的共享内存。一个块内的所有线程都在同一个GPU上执行。</p>
<p><strong>Thread（线程）</strong><br>含义：线程是执行内核代码的基本单位。每个线程执行内核中的一部分操作。<br>角色：在CUDA中，每个线程都有其唯一的线程ID，用于计算数据的位置和执行特定的操作。线程是实际执行计算的实体。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-71.png" alt="Alt text"></p>
<p><img src="/2024/02/16/Computer-Architecture/image-72.png" alt="Alt text"></p>
<h5 id="SMIT-和SMID的区别"><a href="#SMIT-和SMID的区别" class="headerlink" title="SMIT 和SMID的区别"></a>SMIT 和SMID的区别</h5><p><img src="/2024/02/16/Computer-Architecture/image-73.png" alt="Alt text"></p>
<p>SMID是一个线程同时操作多个标量操作。<br>SMIT是多个线程同时进行单个的标量操作。</p>
<h5 id="GPU的优势"><a href="#GPU的优势" class="headerlink" title="GPU的优势"></a>GPU的优势</h5><p>branch, memory bandwidth, multi-bank, coalescing</p>
<h4 id="GPU控制架构"><a href="#GPU控制架构" class="headerlink" title="GPU控制架构"></a>GPU控制架构</h4><p><img src="/2024/02/16/Computer-Architecture/image-74.png" alt="Alt text"></p>
<p>一个SM(Streaming Multiprocessor)可编程多处理器 的架构如图。</p>
<h5 id="Warp的概念"><a href="#Warp的概念" class="headerlink" title="Warp的概念"></a>Warp的概念</h5><p>线程组：一个 Warp 通常包含32个线程。这些线程在硬件上被同时调度执行，共享同一个指令流。</p>
<p>并行执行：Warp 中的所有线程都执行相同的指令，但是每个线程可以在不同的数据上操作。这是一种单指令多数据（SIMD）的并行处理方式。</p>
<p>效率：通过将多个线程组织成一个 Warp，GPU 能够高效地利用其并行处理单元，尤其是在处理类似的数据或执行重复任务时。</p>
<p>SM上的指令调度全部以warp为单位进行。<br><img src="/2024/02/16/Computer-Architecture/image-75.png" alt="Alt text"></p>
<p>warp只有在ready的情况下才会被调度。warp的标志位包括：</p>
<ol>
<li>ID：表示线程数的identity</li>
<li>PC: PC值，warp的指令地址</li>
<li>Decoded instruction:需要执行的指令类型</li>
<li>Ready: 可以被调度</li>
<li>Valid: 是否有效</li>
</ol>
<p>warp的调度方法包括 轮询(round-robin),贪心GTO(greedy-then-oldest)。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-76.png" alt="Alt text"></p>
<p>轮询存在的问题： 每个线程都是先访存再计算，导致计算效率低。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-77.png" alt="Alt text"></p>
<p>使用2级轮询可以进行改善。</p>
<h5 id="线程的发散"><a href="#线程的发散" class="headerlink" title="线程的发散"></a>线程的发散</h5><p>(略，复习不完了)</p>
<h4 id="GPU-存储架构"><a href="#GPU-存储架构" class="headerlink" title="GPU 存储架构"></a>GPU 存储架构</h4><p>不同于CPU，GPU中的存储器呈倒三角结构</p>
<p><img src="/2024/02/16/Computer-Architecture/image-78.png" alt="Alt text"></p>
<h4 id="运算单元架构"><a href="#运算单元架构" class="headerlink" title="运算单元架构"></a>运算单元架构</h4><p>(略，复习不完了)</p>
<h4 id="张量核心架构"><a href="#张量核心架构" class="headerlink" title="张量核心架构"></a>张量核心架构</h4><p>(略，复习不完了)</p>
<h2 id="Chapter-5-Multiprocess-and-Thread-Level-Parallelism"><a href="#Chapter-5-Multiprocess-and-Thread-Level-Parallelism" class="headerlink" title="Chapter 5 Multiprocess and Thread-Level Parallelism"></a>Chapter 5 Multiprocess and Thread-Level Parallelism</h2><h3 id="多处理器的概念"><a href="#多处理器的概念" class="headerlink" title="多处理器的概念"></a>多处理器的概念</h3><p>在计算机架构中，多处理器（Multiprocessor）指的是包含多个处理单元（通常是CPU核心）的系统。这些处理单元可以并行处理多个任务，提高系统的总体计算能力和吞吐率。多处理器系统可以是对称的（SMP，Symmetric Multiprocessing）或不对称的（Asymmetric Multiprocessing），具体取决于各个处理器之间的角色和功能是否相同。</p>
<p>多处理器的特点<br>并行处理能力：多处理器系统能够同时执行多个计算任务，提高了处理效率和吞吐量。</p>
<p>增强的性能：相较于单处理器系统，多处理器系统通常提供更高的性能，特别是在处理并行化良好的任务时。</p>
<p>可扩展性：多处理器架构允许更灵活地扩展计算能力，可以通过增加更多的处理器来提高系统性能。</p>
<p>容错能力：在一些设计中，多处理器系统可以提供更好的容错能力，当一个处理器失败时，其他处理器可以接管其任务。</p>
<p>资源共享：多处理器通常共享系统资源，如内存、I&#x2F;O设备等。这要求有效的资源管理和调度策略，以避免冲突和瓶颈。</p>
<p>高效的数据处理：对于需要大量数据处理的应用（如数据库服务器、科学计算应用），多处理器系统可以提供显著的性能优势。</p>
<h3 id="SMP和DMP"><a href="#SMP和DMP" class="headerlink" title="SMP和DMP"></a>SMP和DMP</h3><h4 id="SMP-Symmetric-multiprocessors"><a href="#SMP-Symmetric-multiprocessors" class="headerlink" title="SMP(Symmetric multiprocessors)"></a>SMP(Symmetric multiprocessors)</h4><p><img src="/2024/02/16/Computer-Architecture/image-79.png" alt="Alt text"></p>
<p>多个处理器共享同一个内存地址。(目前大部分Intel和AMD处理器的架构)</p>
<p>地址是一致的(Uniformed Memory Access)</p>
<h4 id="DMP"><a href="#DMP" class="headerlink" title="DMP"></a>DMP</h4><p><img src="/2024/02/16/Computer-Architecture/image-80.png" alt="Alt text"></p>
<p>每个处理器具有独立的内存和地址，需要考虑数据一致性。</p>
<h3 id="多处理器的并行挑战"><a href="#多处理器的并行挑战" class="headerlink" title="多处理器的并行挑战"></a>多处理器的并行挑战</h3><h4 id="并行效率"><a href="#并行效率" class="headerlink" title="并行效率"></a>并行效率</h4><p>例：如果使用100个核，想要达到单核80倍的加速比，根据阿姆达尔定律：</p>
<p>speed up  &#x3D; $\frac{1}{a%+(1-a%)\div100}$</p>
<p>其中a为并行指令的百分比。解的a为0.25，也就是说串行指令只能占0.25%。</p>
<h4 id="通信开销"><a href="#通信开销" class="headerlink" title="通信开销"></a>通信开销</h4><p><img src="/2024/02/16/Computer-Architecture/image-81.png" alt="Alt text"></p>
<p>200ns的通信时间相当于660个时钟周期，0.002的通信频率使CPI变为：<br>$0.5+660\times0.002&#x3D;1.82$</p>
<h4 id="缓存一致性-Cache-Coherence"><a href="#缓存一致性-Cache-Coherence" class="headerlink" title="缓存一致性(Cache Coherence)"></a>缓存一致性(Cache Coherence)</h4><p><img src="/2024/02/16/Computer-Architecture/image-82.png" alt="Alt text"></p>
<p>AB二者缓存中都有数据X，A写了自己的cachee,并通过write through写了Memory,B不知道，造成不一致。</p>
<p>一般来说有3中解决方案：<br><img src="/2024/02/16/Computer-Architecture/image-83.png" alt="Alt text"></p>
<ol>
<li>软件调度，直接禁止所有对Shared Memory的缓存操作</li>
<li>某个处理器写了一个数据后，其它cache中的该数据失效。</li>
<li>通过协议及时更新数据。</li>
</ol>
<h5 id="Snoopy-监听-Coherence-Protocol"><a href="#Snoopy-监听-Coherence-Protocol" class="headerlink" title="Snoopy(监听) Coherence Protocol"></a>Snoopy(监听) Coherence Protocol</h5><p><img src="/2024/02/16/Computer-Architecture/image-84.png" alt="Alt text"></p>
<p>还是上面那个例子，当A写了之后，B再读自己cache中的X会显示cache miss，因为相应数据已经失效了。</p>
<p>实现方式： 通过一个BUS广播告诉所有Cache数据的状态。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-85.png" alt="Alt text"></p>
<p>cache 中，每个数据有3中不同状态：</p>
<p><img src="/2024/02/16/Computer-Architecture/image-86.png" alt="Alt text"></p>
<h6 id="协议内容"><a href="#协议内容" class="headerlink" title="协议内容"></a>协议内容</h6><p><img src="/2024/02/16/Computer-Architecture/image-87.png" alt="Alt text"></p>
<p>分类讨论read hit,read miss,write hit,write miss。</p>
<p>同时在read miss,write hit,write miss的情况下，考虑被替换的数据状态是invalid,shared 还是modified,相应的bus要做出对应的行为。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-88.png" alt="Alt text"><br>Snoopy协议下cache的状态转换图</p>
<p><img src="/2024/02/16/Computer-Architecture/image-89.png" alt="Alt text"><br>Snoopy协议下bus的状态转换图</p>
<h5 id="Snoopy协议的扩展："><a href="#Snoopy协议的扩展：" class="headerlink" title="Snoopy协议的扩展："></a>Snoopy协议的扩展：</h5><h6 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h6><p><img src="/2024/02/16/Computer-Architecture/image-90.png" alt="Alt text"></p>
<p>添加一个新的状态 Exclusive,表示数据在只有本cache中有，而且还没有被写过(clean)</p>
<p>当其它cache读这个数据时，转变为S<br>当本processor写这个cache时，变为M状态，此时不需要广播其它cache。</p>
<h6 id="MOSI"><a href="#MOSI" class="headerlink" title="MOSI"></a>MOSI</h6><p><img src="/2024/02/16/Computer-Architecture/image-91.png" alt="Alt text"></p>
<p>应用场景：处理器之间交换数据速度比处理器与Memory之间交换数据快时，添加一个状态叫Owned</p>
<p>状态为O说明只有这个Cache中的数据是最新的，其它cache都不从memory中拿数据而是从该cache中拿。</p>
<p>O变为M,说明写回Memory的动作完成。</p>
<h5 id="Snoopy总结"><a href="#Snoopy总结" class="headerlink" title="Snoopy总结"></a>Snoopy总结</h5><p>Snoopy协议的基本概念<br>“Snoopy”协议得名于它的工作方式，类似于卡通角色“Snoopy”（史努比）的窥探行为。在这种协议下，每个处理器（或更准确地说，每个处理器的缓存控制器）都会“窥探”（snoop）在共享总线上发生的所有事务（如读取和写入操作），以监控其他处理器对共享内存的访问。</p>
<p>工作机制<br>缓存一致性：Snoopy协议的主要目的是维持缓存一致性，确保所有处理器的缓存中存储的是共享内存的最新数据。</p>
<p>总线监听：当一个处理器执行内存操作（读取或写入）时，其他处理器的缓存控制器会监听总线上的这些操作，并根据需要更新或失效其本地缓存副本。</p>
<p>写入操作：例如，当一个处理器写入共享数据时，其他处理器的缓存可能需要使其缓存中的相应数据无效，以保证一致性。</p>
<p>Snoopy协议的类型<br>写失效（Write Invalidate）：最常见的方式是在写入数据时使其他所有缓存中的该数据无效。<br>写更新（Write Update）：另一种方式是在写入数据时更新所有缓存中的该数据副本。<br>优点与挑战<br>优点：Snoopy协议简单直观，对于中等规模的多处理器系统非常有效。<br>挑战：随着处理器数量的增加，总线流量和协议开销可能会变得过大，影响系统性能。对于大规模的多处理器系统，可能需要更复杂的一致性协议。</p>
<h5 id="Directory-Coherence-Protocol-目录协议"><a href="#Directory-Coherence-Protocol-目录协议" class="headerlink" title="Directory Coherence Protocol 目录协议"></a>Directory Coherence Protocol 目录协议</h5><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>Directory Coherence Protocol是一种用于维护多处理器系统中缓存一致性的协议，特别适用于大规模或者分布式共享内存系统。与基于总线的Snoopy协议不同，Directory协议不依赖于总线广播，而是使用一个中央的存储结构（称为目录）来追踪哪些处理器拥有某个内存位置的副本。</p>
<p>工作原理<br>目录（Directory）：目录是一个数据结构，它存储了每个内存块的共享信息。对于每个内存块，目录记录了哪些缓存拥有该块的副本，以及每个副本的状态（例如，是否被修改）。</p>
<p>状态追踪：当处理器需要读取或写入内存时，它首先与目录通信。目录决定是否需要采取行动，如向其他拥有该数据副本的缓存发送失效（Invalidate）或更新（Update）消息。</p>
<p>消息传递：Directory协议依赖于消息传递机制，用于在处理器、缓存和目录之间传递控制消息。</p>
<p>工作流程<br>读取操作：当处理器发起一个读取请求时，目录检查该内存块的状态，并根据需要更新状态和发送消息。<br>写入操作：当处理器发起写入请求时，目录可能需要向其他拥有该内存块副本的缓存发送失效消息，以保持一致性。<br>优点<br>可扩展性：由于不依赖于总线广播，Directory协议在大规模多处理器系统中比Snoopy协议具有更好的可扩展性。<br>减少网络流量：通过仅向相关的缓存发送消息，Directory协议可以减少网络上的流量和冲突。<br>挑战。</p>
<p>目录开销：目录的维护需要额外的存储空间和管理开销。<br>复杂性：实现和维护Directory协议比Snoopy协议更复杂，特别是在处理大量处理器和缓存时。</p>
<h5 id="-1"><a href="#-1" class="headerlink" title></a></h5><p><img src="/2024/02/16/Computer-Architecture/image-92.png" alt="Alt text"><br>Local Node（本地节点）<br>含义：Local node通常指发起某个特定内存操作（如读取或写入请求）的处理器或缓存。<br>作用：本地节点根据需要读取或修改数据，并与目录节点通信以维护一致性。<br>例子：如果一个处理器尝试写入一个共享变量，那么这个处理器就是该写入操作的本地节点。<br>Home Node（家节点）<br>含义：Home node是存储某个特定内存地址的数据和其目录条目的节点。<br>作用：家节点负责管理目录信息，包括哪些节点拥有该内存地址的副本，以及这些副本的状态（共享、独占、修改等）。<br>例子：对于给定的内存地址，家节点包含该地址的主副本和一个目录条目，用于跟踪其他节点对该地址的缓存情况。<br>Remote Node（远程节点）<br>含义：Remote node指除了本地节点和家节点之外，涉及到特定内存操作的其他节点。<br>作用：远程节点可能包含与操作相关的内存地址的缓存副本。在处理缓存一致性操作时，家节点可能需要向远程节点发送消息，如失效或更新消息。<br>例子：如果多个处理器缓存了同一个内存地址的数据，那么在某个处理器（本地节点）写入该地址时，其他拥有该地址副本的节点就是远程节点。</p>
<p><img src="/2024/02/16/Computer-Architecture/image-93.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CA</tag>
      </tags>
  </entry>
  <entry>
    <title>System Verilog Notes</title>
    <url>/2024/02/12/System-Verilog-Notes/</url>
    <content><![CDATA[<h1 id="System-Verilog期末复习"><a href="#System-Verilog期末复习" class="headerlink" title="System Verilog期末复习"></a>System Verilog期末复习</h1><p><strong>题型：<br>简答（填空、代码解析、电路图、波形）<br>编程<br>共20题</strong></p>
<h2 id="SV中的数据类型"><a href="#SV中的数据类型" class="headerlink" title="SV中的数据类型"></a>SV中的数据类型</h2><p><strong>线网</strong>：<code>net tpye</code>  与verilog类似</p>
<p><strong>变量</strong> <code>variable</code><br>大多数变量本身不用来描述电路，只用于更高抽象层面的验证</p>
<p>Reg&#x2F;<strong>logic&#x2F;Bit</strong>&#x2F;byte&#x2F;shortint&#x2F;int&#x2F;longint</p>
<p><strong>增加了2值数据类型</strong></p>
<p><code>logic</code>: <strong>4值数据类型</strong><br>用来代替verilog中的reg和wire<br>（<strong>其中reg被logic完全代替，但logic不能被多驱动</strong>）<br>举例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> a;</span><br><span class="line"><span class="keyword">assign</span> a = xxx; <span class="comment">///wrong</span></span><br><span class="line"><span class="keyword">logic</span> a;</span><br><span class="line"><span class="keyword">assign</span> a = xxx;  <span class="comment">//  acceptable</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LDT(<span class="keyword">input</span> <span class="keyword">logic</span> res);</span><br><span class="line"><span class="keyword">logic</span> q, qn, d, clk, resl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">forever</span> #<span class="number">5</span> clk=~clk;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> resl=~res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">not</span> a(qn,q);</span><br><span class="line">DFF D(q, d, clk, resl);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>logic的使用更加自由，用作端口连接信号时不受限制。</p>
<p><strong>2值数据类型</strong>  （用于testbench）<br>Bit<br>• 1 bit, 2 state integer, scalable to vector</p>
<p>byte<br>• 8 bit, 2 state integer (similar to char in C)  </p>
<p>shortint<br>• 16 bit, 2 state integer (similar to short in C)  </p>
<p>int<br>• 32 bit, 2 state integer (similar to int in C)  </p>
<p>longint<br>• 64 bit, 2 state integer (similar to longlong in C)  </p>
<p>注意区分<code>logic[7:0] x</code> 与 <code>byte x</code> 的区别</p>
<p>1.byte是有符号的，并且只有2值(0和1)</p>
<p><img src="/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_14-08-17.png"><br>4值和2值类型之间如何相互转化？<br>4值的x和z都被转化为2值的0（导致信息丢失）</p>
<p>使用<code>$isunknown</code>来判断x和z</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">$isunknown</span>(iport)==<span class="number">1</span>)</span><br><span class="line"><span class="built_in">$display</span> (“ <span class="number">4</span>-state variable detected”);</span><br></pre></td></tr></table></figure>


<h3 id="Array-Dynamic-arrays-Associative-arrays-Queues"><a href="#Array-Dynamic-arrays-Associative-arrays-Queues" class="headerlink" title="Array&#x2F; Dynamic arrays&#x2F;Associative arrays&#x2F;Queues"></a>Array&#x2F; Dynamic arrays&#x2F;Associative arrays&#x2F;Queues</h3><p>verilog中的向量：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span>[msb:lsb] data;</span><br><span class="line"><span class="comment">//msb 和lsb为常数，二者之间的大小关系没有要求</span></span><br><span class="line"><span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] data_in;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] data_out;<span class="comment">//recommend grammar</span></span><br></pre></td></tr></table></figure>

<p>寄存器组可以用来建模 ROM,RAM（6个晶体管实现1位存储）,RF(register file，26个晶体管实现1位存储)。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[msb:lsb] memory[upper:lower];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] memory1 [<span class="number">0</span>:<span class="number">63</span>]; <span class="comment">//64个8位的存储器</span></span><br><span class="line"><span class="keyword">reg</span> mema [<span class="number">1</span>:<span class="number">5</span>]; <span class="comment">//5个一位的存储器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">5</span>] rega; <span class="comment">//1个5位的寄存器</span></span><br><span class="line"><span class="comment">//区别：对于存储器的访问须指定地址，不能实现同时的所有地址访问。</span></span><br><span class="line">rega = <span class="number">0</span>; <span class="comment">// Legal syntax</span></span><br><span class="line">mema = <span class="number">0</span>; <span class="comment">// illegal syntax，不能同时读</span></span><br><span class="line">mema[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//Assigns 0 to the first element of mema。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> arrayb[<span class="number">7</span>:<span class="number">0</span>][<span class="number">0</span>:<span class="number">255</span>]; <span class="comment">// declare a two-dimensional array of one bit registers 不推荐的写法(找不到对应的硬件)</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，初始化操作mema&#x3D;0不合法，同时对硬件(SRAM)来说,初始化同样没有实现机制。</p>
<p>在设计中，对memeory的单比特访问同样不推荐(mem[a][b])，因为对硬件来说一般会直接读整个字。</p>
<p><strong>对向量的赋值</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_vector();</span><br><span class="line"><span class="keyword">parameter</span> SIZE=<span class="number">64</span>;</span><br><span class="line"><span class="keyword">reg</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] data1;</span><br><span class="line"><span class="keyword">logic</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] data2;</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">data1=<span class="number">0</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br><span class="line">data1=<span class="number">&#x27;bz</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br><span class="line">data1=<span class="number">&#x27;bx</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br><span class="line">data1=<span class="number">64&#x27;hFFFFFFFFFFFFFFFF</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,data1);</span><br></pre></td></tr></table></figure>

<p><strong>packed和unpacked Array：</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] c1; <span class="comment">// packed array of scalar bit types</span></span><br><span class="line"><span class="keyword">real</span> u [<span class="number">7</span>:<span class="number">0</span>]; <span class="comment">// unpacked array of real types</span></span><br></pre></td></tr></table></figure>

<p>一维的packed Array相当于vector</p>
<p>Packed Array只能被声明为单比特的数据类型。<br>packed: 存储的时候被打包在一起，可以被当作一个一元变量处理（直接整体赋值）。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>]bytes;</span><br><span class="line">bytes=<span class="number">32</span>’habcd_efab;</span><br><span class="line"><span class="built_in">$displayh</span>(bytes</span><br><span class="line">        bytes[<span class="number">3</span>]</span><br><span class="line">        bytes[<span class="number">3</span>][<span class="number">7</span>]);</span><br></pre></td></tr></table></figure>

<p>Unpacked Array可以被声明为任何数据类型,一般用于一些比较复杂的数据结构。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> lo_hi[<span class="number">0</span>:<span class="number">15</span>]; <span class="comment">//16 ints [0]..[15], Verilog style</span></span><br><span class="line"><span class="keyword">int</span> lo_hi[<span class="number">16</span>]; <span class="comment">//16 ints [0]..[15]，SV style (C’s style)</span></span><br></pre></td></tr></table></figure>

<p>读写问题：<br>越界写被忽略，越界读则得到：（x for 4-state,0 for 2 state）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_outboundry();</span><br><span class="line"><span class="keyword">byte</span> array1 [<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] array2 [<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">array1[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">255</span>;</span><br><span class="line">array2[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">255</span>;</span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%d&quot;</span>,array1[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// -1 for byte is signed</span></span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%d&quot;</span>,array2[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 255</span></span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,array1[<span class="number">3</span>][<span class="number">3</span>]); <span class="comment">// 8&#x27;b00000000</span></span><br><span class="line">#<span class="number">5</span> <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,array2[<span class="number">3</span>][<span class="number">3</span>]);<span class="comment">// 8&#x27;bxxxxxxxxx</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>Unpacked Array 的初始化</p>
<p><img src="/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_15-23-40.png"></p>
<p>顺序为：从左往右从低到高<br><img src="/2024/02/12/System-Verilog-Notes/Snipaste_2023-09-28_15-24-38.png"></p>
<p><strong>混合使用： mixed Array</strong></p>
<p>举例：<br><img src="/2024/02/12/System-Verilog-Notes/image-37.png" alt="内存布局"></p>
<p>理解，每一行(连续的内存空间)，是一个[3:0][7:0]的packed array，而纵向是unpacked 的。<br>索引方式： unpacked 在前，packed在后。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-38.png" alt="Alt text"></p>
<p><strong>Packed Array 和Unpacked Array比较</strong>：</p>
<ol>
<li><p>Packed Array：</p>
<ol>
<li>紧凑存储：Packed array 的所有元素都是紧密排列的，没有间隙。这意味着整个数组可以被视为一个单一的、连续的位向量。</li>
<li><strong>位级操作</strong>：由于其连续的存储方式，可以对整个 packed array 进行位级操作，如位移、逻辑运算等。</li>
<li>定义方式：在声明数组时，packed 维度紧随数据类型之后。例如：bit [3:0] packedArray; 表示一个4位的 packed array。</li>
<li>应用场景：通常用于硬件建模，如总线接口、寄存器等，因为它们可以映射到硬件中的连续位。</li>
</ol>
</li>
<li><p>Unpacked Array：</p>
<ol>
<li>分散存储：Unpacked array 的元素在内存中可能是分散存储的，每个元素可以独立寻址。</li>
<li><strong>元素级操作</strong>：通常对 unpacked array 的操作是在元素级别进行的，如数组的遍历和单个元素的访问。</li>
<li>定义方式：在声明数组时，unpacked 维度跟在变量名之后。例如：int unpackedArray [10]; 表示一个有10个整数的 unpacked array。</li>
<li>应用场景：常用于表示复杂的数据结构，如队列、堆栈、记录等，以及在验证和建模过程中处理大量数据。</li>
</ol>
</li>
</ol>
<h3 id="quiz"><a href="#quiz" class="headerlink" title="quiz"></a>quiz</h3><ol>
<li><p>What is the basic difference between logic and reg?<br> logic的功能几乎完全取代reg和wire.因此区别主要在于，logic可以被连续赋值，而reg不行。</p>
</li>
<li><p>What is the difference between logic and bit?<br> 四值逻辑和二值逻辑的区别。</p>
</li>
<li><p>Should the 2-state variable be used with the DUT?<br>不行，二值逻辑不可综合，无法用于电路的建模</p>
</li>
</ol>
<h3 id="动态数组-Dynamic-Array"><a href="#动态数组-Dynamic-Array" class="headerlink" title="动态数组 Dynamic Array"></a>动态数组 Dynamic Array</h3><p>定义方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] nibble[]; <span class="comment">// Dynamic array of 4-bit vectors</span></span><br><span class="line"><span class="keyword">integer</span> mem[<span class="number">2</span>][]; <span class="comment">// Fixed-size unpacked array composed</span></span><br><span class="line"><span class="comment">// of 2 dynamic subarrays of integers</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Dynamic Array是unpacked的。</p>
<p>用法：本质是一个内置的对象类型，具有new,size,delete等方法。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_da();</span><br><span class="line">    <span class="keyword">int</span> dyn[], d2[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    dyn=<span class="keyword">new</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (dyn[j]) dyn[j]=j;<span class="comment">//[0,1,2,3,4]</span></span><br><span class="line"></span><br><span class="line">    d2=dyn;</span><br><span class="line">    d2[<span class="number">0</span>]=<span class="number">5</span>; [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">$display</span>(dyn[<span class="number">0</span>],d2[<span class="number">0</span>]); <span class="comment">//0,5</span></span><br><span class="line">    dyn=<span class="keyword">new</span>[<span class="number">10</span>](dyn);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%p&quot;</span>,dyn);<span class="comment">//[0,1,2,3,4,0,0,0,0,0]  </span></span><br><span class="line">    dyn=<span class="keyword">new</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%p&quot;</span>,dyn);<span class="comment">//[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span></span><br><span class="line">    dyn<span class="variable">.delete</span>();</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot; %d&quot;</span>,dyn<span class="variable">.size</span>());  <span class="comment">//0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意以上2中new的区别，是用原来的array初始化还是重新初始化。</p>
<h3 id="关联数组-Associate-Array"><a href="#关联数组-Associate-Array" class="headerlink" title="关联数组 Associate Array"></a>关联数组 Associate Array</h3><p>语法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> name [*];</span><br></pre></td></tr></table></figure>

<p>用一个星号进行声明。</p>
<p>与动态数组的比较：<br><img src="/2024/02/12/System-Verilog-Notes/image-39.png" alt="Alt text"><br>可以分配稀疏的存储空间(本质是哈希表)，且索引形式更自由，支持任何形式数据类型的索引。</p>
<p>应用场景：</p>
<ol>
<li>存储稀疏数据：当数据集是非连续的或稀疏的，关联数组是一个理想的选择。</li>
<li>查找表：在需要快速查找的场景下，如实现映射或字典功能。</li>
<li>动态数据处理：在验证环境中，经常需要处理动态变化的数据集，关联数组在这方面非常有用。</li>
</ol>
<h3 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h3><p>语法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> name[$]</span><br></pre></td></tr></table></figure>

<p>参考C++的vector.<br>基础操作：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Size()</span><br><span class="line">Insert()</span><br><span class="line">Delete()</span><br><span class="line">Pop_front()</span><br><span class="line">Pop_back()</span><br><span class="line">Push_front()</span><br><span class="line">Push_back()</span><br></pre></td></tr></table></figure>

<h3 id="Array-Methods"><a href="#Array-Methods" class="headerlink" title="Array Methods:"></a>Array Methods:</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$left</span></span><br><span class="line"><span class="built_in">$right</span></span><br><span class="line"><span class="built_in">$low</span></span><br><span class="line"><span class="built_in">$high</span></span><br><span class="line"><span class="built_in">$increment</span></span><br><span class="line"><span class="built_in">$size</span></span><br><span class="line"><span class="built_in">$dimensions</span></span><br><span class="line"><span class="built_in">$unpacked_dimensions</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举-enumerated"><a href="#枚举-enumerated" class="headerlink" title="枚举 enumerated"></a>枚举 enumerated</h3><p>语法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;red, green, blue&#125; RGB</span><br></pre></td></tr></table></figure>
<p>枚举类型的特性：枚举中的每个变量是默认自增的，当人为定义各类型的值时，需要注意不能违背自增原则。<br><img src="/2024/02/12/System-Verilog-Notes/image-41.png" alt="Alt text"></p>
<h3 id="结构体-Structure"><a href="#结构体-Structure" class="headerlink" title="结构体 Structure"></a>结构体 Structure</h3><p>语法：类似C</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] opcode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">    <span class="keyword">bit</span> error;</span><br><span class="line">&#125; Instruction_Word</span><br></pre></td></tr></table></figure>

<p>同时还有一种 packed的定义方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> valid;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] tag;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; data_word</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-42.png" alt="Alt text"></p>
<p>packed定义的结构体在内存上是连续的。<br>同时Packed 支持成员索引和按位索引：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">data_word<span class="variable">.tag</span> = <span class="number">8</span>’hf0;</span><br><span class="line">data_word [<span class="number">39</span>:<span class="number">32</span>]=<span class="number">8</span>’hf0;</span><br></pre></td></tr></table></figure>

<h2 id="System-Verilog-Programming-Basic-I"><a href="#System-Verilog-Programming-Basic-I" class="headerlink" title="System Verilog Programming Basic I"></a>System Verilog Programming Basic I</h2><h3 id="verilog-style"><a href="#verilog-style" class="headerlink" title="verilog style"></a>verilog style</h3><p>一个常见的状态机的写法：  </p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> fsm1a (ds, rd, go, ws, clk, rst_n);</span><br><span class="line"><span class="keyword">output</span> ds, rd;</span><br><span class="line"><span class="keyword">input</span> go, ws,clk, rst_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">1</span>:<span class="number">0</span>] IDLE = <span class="number">2&#x27;b00</span>,READ = <span class="number">2&#x27;b01</span>,DLY =<span class="number">2&#x27;b10</span>,DONE = <span class="number">2&#x27;b11</span>;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] state, next;<span class="comment">//reg也可用于描述组合逻辑</span></span><br><span class="line"><span class="keyword">wire</span> rd, ds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) </span><br><span class="line">        state &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        state &lt;= next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(state <span class="keyword">or</span> go <span class="keyword">or</span> ws) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (state)</span><br><span class="line">        IDLE: <span class="keyword">if</span> (go) next = READ;</span><br><span class="line">            <span class="keyword">else</span> next = IDLE;</span><br><span class="line">        READ: next = DLY;</span><br><span class="line">        DLY: <span class="keyword">if</span> (ws) next = READ;</span><br><span class="line">            <span class="keyword">else</span> next = DONE;</span><br><span class="line">        DONE: next = IDLE;</span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> rd = (state==READ || state==DLY);</span><br><span class="line"><span class="keyword">assign</span> ds = (state==DONE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>SV中对端口的数据类型不做限制</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p><code>== !=</code>逻辑判断<br>当x或z参与比较时，返回x</p>
<p><code>=== !==</code><br>将x或z当成独立的状态进行比较</p>
<p><code>==?  !=?</code><br>通配操作，对右边的操作数放宽比较的限制。在通配中，右边的x和z会被忽略。左边有x或z则结果直接变成x。<br><img src="/2024/02/12/System-Verilog-Notes/image-44.png" alt="Alt text"><br>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_wildcard();</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] a, b,c;</span><br><span class="line">    <span class="keyword">logic</span> le1,le2,ce1,ce2,we1,we2,we3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    a=<span class="number">4&#x27;b010z</span>;</span><br><span class="line">    b=<span class="number">4&#x27;b0101</span>;</span><br><span class="line">    c=<span class="number">4&#x27;b010z</span>;</span><br><span class="line"></span><br><span class="line">    le1=(a==b);</span><br><span class="line">    le2=(a==c);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%b,%b&quot;</span>,le1,le2); <span class="comment">//#x,x</span></span><br><span class="line"></span><br><span class="line">    ce1=(a===b);</span><br><span class="line">    ce2=(a===c);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%b,%b&quot;</span>,ce1,ce2);<span class="comment">//#0,1</span></span><br><span class="line"></span><br><span class="line">    we1=(a==?b);</span><br><span class="line">    we2=(b==?a);</span><br><span class="line">    we3=(a==?c);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%b,%b,%b&quot;</span>,we1,we2,we3);<span class="comment">//#x,1,1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h4 id="递增、递减"><a href="#递增、递减" class="headerlink" title="递增、递减"></a>递增、递减</h4><p><code>++  --</code></p>
<p><code>+=  -=</code></p>
<p>注意：+&#x3D;是一种阻塞赋值。</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> test();</span><br><span class="line"><span class="keyword">int</span> dat0,dat1,dat00,dat01,dat02,dat10,dat11,dat12;<span class="comment">//默认值为0</span></span><br><span class="line"><span class="keyword">bit</span> tik=<span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">bit</span> clk;</span><br><span class="line"><span class="keyword">always</span> #<span class="number">1</span> clk=!clk;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat00 &lt;= dat0 + tik; <span class="comment">// 1</span></span><br><span class="line">    dat0 = dat0 + tik; <span class="comment">// 1  (阻塞语句优先执行)</span></span><br><span class="line">    dat01 &lt;= dat0 + tik; <span class="comment">// 2</span></span><br><span class="line">    dat02 &lt;= dat01 + tik; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat10 &lt;= dat1 + tik; <span class="comment">// 1</span></span><br><span class="line">    dat1 += tik; <span class="comment">// 1</span></span><br><span class="line">    dat11 &lt;= dat1 + tik; <span class="comment">// 2</span></span><br><span class="line">    dat12 &lt;= dat11 + tik; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>即 <code>a+=b</code>和<code>a = a+b</code>的效果完全相同。</p>
<p>example</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> test();</span><br><span class="line"><span class="keyword">int</span> dat0,dat1,dat3,dat30,dat31;</span><br><span class="line"><span class="keyword">int</span> tik0,tik1,tik3;</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat0 =tik0++;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;dat0=%d,tik0=%d&quot;</span>,dat0,tik0); <span class="comment">//0, 1</span></span><br><span class="line">    dat1=++tik1;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;dat1=%d,tik1=%d&quot;</span>,dat1,tik1); <span class="comment">//1, 1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dat30&lt;=tik3;</span><br><span class="line">    dat3 =++tik3;</span><br><span class="line">    dat31&lt;=tik3;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;dat30=%d,dat3=%d,dat31=%d,tik3=%d&quot;</span>,</span><br><span class="line">    dat30,dat3,dat31,tik3); <span class="comment">// 0,  1,  0(实际上是1),   1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="comment">//display语句比非阻塞赋值的执行要早。</span></span><br></pre></td></tr></table></figure>

<h4 id="inside"><a href="#inside" class="headerlink" title="inside"></a>inside</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] a;</span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">inside</span> &#123;<span class="number">3</span>’b001, <span class="number">3</span>’b010, <span class="number">3</span>’b100&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//与下面的写法等价：</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] a;</span><br><span class="line"><span class="keyword">if</span> ((a==?<span class="number">3</span>’b001)||(a==?<span class="number">3</span>’b010)||(a==?<span class="number">3</span>’b100))</span><br></pre></td></tr></table></figure>
<p>顾名思义，inside用于检查一个变量是否在一个集合中。<br>inside可用于随机数生成。</p>
<p>同时, inside 可以用作通配操作：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> r;</span><br><span class="line"><span class="keyword">assign</span> r=<span class="number">3&#x27;bz11</span> <span class="keyword">inside</span> &#123;<span class="number">3&#x27;b1</span>?<span class="number">1</span>, <span class="number">3&#x27;b011</span>&#125;; <span class="comment">// r = 1&#x27;bx</span></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> r = (<span class="number">3&#x27;bz11</span>==?<span class="number">3&#x27;b1</span>?<span class="number">1</span> || <span class="number">3&#x27;bz11</span>==?<span class="number">3&#x27;b011</span> )</span><br></pre></td></tr></table></figure>

<h4 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h4><p>产生某种统计分布</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> distribution ();</span><br><span class="line">    <span class="keyword">class</span> frame_t;</span><br><span class="line">        <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">constraint</span> len &#123;</span><br><span class="line">        length <span class="keyword">dist</span> &#123;</span><br><span class="line">        [<span class="number">0</span>:<span class="number">7</span>] := <span class="number">8</span>,</span><br><span class="line">        [<span class="number">8</span>:<span class="number">15</span>] := <span class="number">8</span>,</span><br><span class="line">        [<span class="number">16</span>:<span class="number">31</span>] := <span class="number">16</span>&#125;;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="keyword">void</span> post_randomize();</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;length : %d&quot;</span>,length);</span><br><span class="line">        <span class="keyword">endfunction</span> </span><br><span class="line">    <span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    frame_t frame = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">integer</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j &lt; <span class="number">32</span>; j++)</span><br><span class="line">        i = frame<span class="variable">.randomize</span>();</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-5.png" alt="Alt text"></p>
<h4 id="streaming"><a href="#streaming" class="headerlink" title="streaming"></a>streaming</h4><p><code>&#123;&lt;&lt;&#123;&#125;&#125;     &#123;&gt;&gt;&#123;&#125;&#125;</code></p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> streaming();</span><br><span class="line"><span class="keyword">int</span> j = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Value of j %0x&quot;</span>,j);</span><br><span class="line">    <span class="built_in">$monitor</span>(<span class="string">&quot;@%0dns stream value is %x&quot;</span>,<span class="built_in">$time</span>, stream);</span><br><span class="line">    #<span class="number">1</span> stream = &#123; &gt;&gt; &#123;j&#125;&#125;; <span class="comment">// generates stream &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot;</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="keyword">byte</span> &#123;j&#125;&#125;; <span class="comment">// generates stream &quot;D&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; (little endian)</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="number">16</span> &#123;j&#125;&#125;; <span class="comment">// generates stream &quot;C&quot; &quot;D&quot; &quot;A&quot; &quot;B&quot;</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; &#123; <span class="number">8&#x27;b0011_0101</span> &#125;&#125;; <span class="comment">// generates stream &#x27;b1010_1100 (bit reverse)</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="number">4</span> &#123; <span class="number">6&#x27;b11_0101</span> &#125;&#125;; <span class="comment">// generates stream &#x27;b0101_11</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &gt;&gt; <span class="number">4</span> &#123; <span class="number">6&#x27;b11_0101</span> &#125;&#125;; <span class="comment">// generates stream &#x27;b1101_01</span></span><br><span class="line">    #<span class="number">1</span> stream = &#123; &lt;&lt; <span class="number">2</span> &#123; &#123; &lt;&lt; &#123; <span class="number">4&#x27;b1101</span> &#125;&#125; &#125;&#125;; <span class="comment">// generates stream &#x27;b1110</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-6.png" alt="Alt text"></p>
<h4 id="casting-固定-强制类型转换"><a href="#casting-固定-强制类型转换" class="headerlink" title="casting  固定(强制类型转换)"></a>casting  固定(强制类型转换)</h4><p>具体操作：</p>
<p><code>type’ (expression)</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">longint</span> a,y;</span><br><span class="line"><span class="keyword">real</span> r;</span><br><span class="line">y=a+<span class="keyword">longint</span>’(r**<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>宽度、符号位等也可以进行固定。</p>
<h4 id="Assignment-赋值"><a href="#Assignment-赋值" class="headerlink" title="Assignment 赋值"></a>Assignment 赋值</h4><p>阻塞赋值、非阻塞赋值</p>
<p>不同的电路描述方式会产生不同的电路：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline1(clk,d,q);</span><br><span class="line">    <span class="keyword">input</span> clk,d;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span> q1,q2,q3;</span><br><span class="line">    <span class="keyword">wire</span> clk,d,q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        q1=d;</span><br><span class="line">        q2=q1;</span><br><span class="line">        q3=q2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> q=q3;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>对应的电路：<br><img src="/2024/02/12/System-Verilog-Notes/image-45.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline1(clk,d,q);</span><br><span class="line">    <span class="keyword">input</span> clk,d;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span> q1,q2,q3;</span><br><span class="line">    <span class="keyword">wire</span> clk,d,q;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        q1&lt;=d;</span><br><span class="line">        q2&lt;=q1;</span><br><span class="line">        q3&lt;=q2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> q=q3;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-46.png" alt="Alt text"></p>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p><code>if else</code>    </p>
<p>注意<strong>if else要讨论清楚所有情况。</strong></p>
<p><code>case</code></p>
<p><code>casez</code><br>忽略z状态</p>
<p><code>casex</code><br>忽略x和z状态</p>
<p>当多个分支同时满足条件时，case只选择第一个分支。(即case存在优先级)</p>
<p><code>unique</code> 和 <code>priority</code>用在分支语句之前</p>
<p><strong>unique</strong>会对分支条件有重叠（overlap）或分支不全的情况进行报警。unique 用于 if-else 或 case 语句，以指示只有一个条件或分支应该为真。如果多个条件或分支同时为真，这通常被视为编码错误，可能会在仿真时产生警告或错误。</p>
<p><strong>priority</strong>确保了条件或分支的评估顺序，即使有多个条件或分支为真，也只有第一个为真的会被执行。<br>priority 有助于防止条件重叠时的不确定行为。</p>
<p>举例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> unique_if;</span><br><span class="line"><span class="comment">//variables declaration</span></span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//initialization</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    b=<span class="number">20</span>;</span><br><span class="line">    c=<span class="number">40</span>;</span><br><span class="line">    <span class="keyword">unique</span> <span class="keyword">if</span> ( a &lt; b ) <span class="built_in">$display</span>(<span class="string">&quot;\t a is less than b&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( a &lt; c ) <span class="built_in">$display</span>(<span class="string">&quot;\t a is less than c&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">$display</span>(<span class="string">&quot;\t a is greater than b and c&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-47.png" alt="Alt text"><br>仿真时报错。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_priority();</span><br><span class="line"><span class="keyword">initial</span> </span><br><span class="line">    <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>;a&lt;<span class="number">4</span>;a++) </span><br><span class="line">    <span class="keyword">priority</span> <span class="keyword">casez</span>(a) <span class="comment">// values 4,5,6,7 </span></span><br><span class="line">        cause a warning </span><br><span class="line">        <span class="number">3&#x27;b00</span>?: <span class="built_in">$display</span>(<span class="string">&quot;0 or 1&quot;</span>); </span><br><span class="line">        <span class="number">3&#x27;b0</span>??: <span class="built_in">$display</span>(<span class="string">&quot;2 or 3&quot;</span>); </span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-48.png" alt="Alt text"></p>
<h4 id="过程块-procedural-statements"><a href="#过程块-procedural-statements" class="headerlink" title="过程块 procedural statements"></a>过程块 procedural statements</h4><p><strong>initial</strong><br>    用途： 指示仿真的开始。可以同时存在多个initial并行。</p>
<p><strong>final</strong><br>类似initial，其中定义的行为在仿真结束后执行，用于在仿真结束后收集信息。同时，<strong>final中不能定义延迟。</strong></p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">begin</span></span><br><span class="line"><span class="built_in">$display</span> (“Final value of Data = %h <span class="string">&quot;, data);</span></span><br><span class="line"><span class="string">data = 1; // even assignments can be done</span></span><br><span class="line"><span class="string">$display (&quot;</span> Final value of Data = %h <span class="string">&quot;, data);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">final $display (&quot;</span>display <span class="keyword">final</span> block <span class="number">1</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">final $display (&quot;</span>display <span class="keyword">final</span> block <span class="number">2</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">final $display (&quot;</span>display <span class="keyword">final</span> block <span class="number">3</span> <span class="string">&quot;);</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-7.png" alt="Alt text"></p>
<p>区别在于，final中不能添加任何delay语句(#delay)   </p>
<p><strong>always</strong><br>在verilog中：<br> always @(*)<br> always @(posedge clk)<br> always @(clk)<br> always  </p>
<p>sv 新增：always_ff&#x2F;always_comb&#x2F;always_latch</p>
<p>SV将组合逻辑、时序逻辑和latch严格区分。  </p>
<p>数字设计时，需要避免latch和组合逻辑环。</p>
<h4 id="Loop-循环"><a href="#Loop-循环" class="headerlink" title="Loop 循环"></a>Loop 循环</h4><p><strong>forever</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">clock1 &lt;= <span class="number">0</span>;</span><br><span class="line">clock2 &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">fork</span></span><br><span class="line">    <span class="keyword">forever</span> #<span class="number">10</span> clock1 = ~clock1;</span><br><span class="line">    #<span class="number">5</span> <span class="keyword">forever</span> #<span class="number">10</span> clock2 = ~clock2;</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>for 循环</strong>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">1024</span>; i=i+<span class="number">1</span>)</span><br><span class="line">…</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>sv和verilog的区别在于，sv可以运行循环控制变量i在循环内部定义(接近c语言的风格)</p>
<p><strong>foreach</strong><br>sv新增，面向对象特性。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">string</span> words [<span class="number">2</span>] = &#x27;&#123; <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> prod [<span class="number">1</span>:<span class="number">8</span>] [<span class="number">1</span>:<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">foreach</span>( words [ j ] )</span><br><span class="line"><span class="built_in">$display</span>( j , words[j] ); <span class="comment">// print each index and value</span></span><br><span class="line">    <span class="keyword">foreach</span>( prod[ k, m ] )</span><br><span class="line">    prod[k][m] = k * m; <span class="comment">// initializ</span></span><br></pre></td></tr></table></figure>

<p>很灵活，可以直接用索引代指变量</p>
<p><strong>while&#x2F;do while</strong></p>
<p><strong>break</strong></p>
<p><strong>repeat</strong></p>
<h4 id="functions-and-tasks-SV的重点"><a href="#functions-and-tasks-SV的重点" class="headerlink" title="functions and tasks(SV的重点)"></a>functions and tasks(SV的重点)</h4><p>task:执行需要时间</p>
<p>function: 被看作瞬时完成，不能有延时操作。</p>
<p>task可以调用function,task不能调用function</p>
<p>function只能有1个返回值，task可以通过output产生多个返回值。task不能写return.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> foo(loo);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] loo;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] goo = zero_count(loo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> [<span class="number">3</span>:<span class="number">0</span>] zero_count;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] in_bus;</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            zero_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i= i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (!in_bus[i])</span><br><span class="line">            zero_count = zero_count +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add_and_inc (<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a,b);</span><br><span class="line">    add_and_inc=a+b+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> add ( <span class="keyword">byte</span> a , b );</span><br><span class="line">    val = a + b ;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    add (<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">$display</span> (val); <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>函数值被看作默认的返回值。</p>
<h4 id="变量的静态和动态-static-automatic"><a href="#变量的静态和动态-static-automatic" class="headerlink" title="变量的静态和动态(static&#x2F;automatic)"></a>变量的静态和动态(static&#x2F;automatic)</h4><p>动态：局部的变量<br>静态：全局共享</p>
<p>task 和 function默认是静态的。</p>
<h4 id="SV-的参数传递"><a href="#SV-的参数传递" class="headerlink" title="SV 的参数传递"></a>SV 的参数传递</h4><p>1.<strong>传值</strong><br>    例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add (<span class="keyword">byte</span> a , b );</span><br><span class="line"><span class="keyword">return</span> a + b ;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>2.<strong>传引用</strong><br>    被传递的参数可以在函数中修改（类似C语言的&amp;augment)  </p>
<p>在变量名前面加上关键字<code>ref</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> argument_passing1;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> sum(<span class="keyword">ref</span> <span class="keyword">int</span> x,y);</span><br><span class="line">    x = x+y;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    y = <span class="number">30</span>;</span><br><span class="line">    z = sum(x,y);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;\tValue of x = %0d&quot;</span>,x);<span class="comment">//50</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;\tValue of y = %0d&quot;</span>,y);<span class="comment">//30</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;\tValue of z = %0d&quot;</span>,z);<span class="comment">//80</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>3.<strong>默认参数</strong></p>
<p>例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> add ( <span class="keyword">int</span> a =<span class="number">1</span>; <span class="keyword">int</span> b; <span class="keyword">int</span> c=<span class="number">3</span>);</span><br><span class="line">… …</span><br><span class="line">    add ( ,<span class="number">2</span>, ); <span class="comment">//equivalent to add (1,2,3);</span></span><br><span class="line">    add ( <span class="number">4</span>,<span class="number">2</span>, ); <span class="comment">//equivalent to add (4,2,3);</span></span><br><span class="line">    add ( ); <span class="comment">//error ; b value missing !</span></span><br></pre></td></tr></table></figure>


<h3 id="quiz-1"><a href="#quiz-1" class="headerlink" title="quiz"></a>quiz</h3><ol>
<li>Why a function cannot call a task?</li>
</ol>
<p>• Because of the timing delays allowed in task; Non-Zero time !</p>
<ol start="2">
<li><p>Tasks not synthesizable ?<br>• Timing delays ! However THEY ARE SYNTHESIZABLE if no timing<br>delays inferred</p>
</li>
<li><p>A function should return a value?<br>• Not necessarily !</p>
</li>
<li><p>Why a task cannot return a value?<br>• Same reason, Timing Delays.</p>
</li>
<li><p>Why a function cannot have delays?<br>• Function caller is waiting for a Zero time event</p>
</li>
<li><p>Why disable statements are not allowed in functions?<br>• A prior disable statement may by-pass return statements at the end of<br>function</p>
</li>
</ol>
<h2 id="System-Verilog-Programming-Basic-II"><a href="#System-Verilog-Programming-Basic-II" class="headerlink" title="System Verilog Programming Basic II"></a>System Verilog Programming Basic II</h2><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>主要用途：用作端口通信。可以在其中实现一些比较复杂的通信协议。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-8.png" alt="Alt text"></p>
<p>driver:驱动端，负责数据的产生</p>
<p>传统方法:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> arb_port (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] grant,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] request,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> reset,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk</span><br><span class="line">    );</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] grant,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] request,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> reset,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk</span><br><span class="line">    );</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] grant,request;</span><br><span class="line">    <span class="keyword">logic</span> clk, reset;</span><br><span class="line">    arb_port a1(<span class="variable">.grant</span>(grant), <span class="variable">.request</span>(request), <span class="variable">.reset</span>(reset), <span class="variable">.clk</span>(clk));</span><br><span class="line">    test t1(<span class="variable">.grant</span>(grant), <span class="variable">.request</span>(request), <span class="variable">.reset</span>(reset), <span class="variable">.clk</span>(clk));</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>


<h3 id="使用interface"><a href="#使用interface" class="headerlink" title="使用interface:"></a>使用interface:</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> simple_bus;</span><br><span class="line">    <span class="keyword">logic</span> req,gnt,start,rdy ;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] mode;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] addr,data;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mem_mod ( <span class="keyword">input</span> <span class="keyword">bit</span> clk,simple_bus busa);</span><br><span class="line"><span class="comment">//注意，此时module的输入不止是单一的信号，而是可以包含整个interface</span></span><br><span class="line">    <span class="keyword">logic</span> sel_mem = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        busa<span class="variable">.gnt</span> &lt;= busa<span class="variable">.req</span> &amp; sel_mem;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cpu_mod ( <span class="keyword">input</span> <span class="keyword">bit</span> clk,simple_bus busa);</span><br><span class="line">    <span class="keyword">logic</span> sel_cpu;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        busa<span class="variable">.mode</span> &lt;= &#123;busa<span class="variable">.gnt</span>, busa<span class="variable">.gnt</span>&#125;;</span><br><span class="line">        busa<span class="variable">.req</span> &lt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top_mod1;</span><br><span class="line">    <span class="keyword">logic</span> clk = <span class="number">0</span>;</span><br><span class="line">    simple_bus sb( );</span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line">    cpu_mod1 cpu (clk, sb);</span><br><span class="line">    mem_mod1 mem (clk, sb);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Interface-可以包含端口。"><a href="#Interface-可以包含端口。" class="headerlink" title="Interface 可以包含端口。"></a>Interface 可以包含端口。</h3><h3 id="Modport-对Interface的端口方向进行限制"><a href="#Modport-对Interface的端口方向进行限制" class="headerlink" title="Modport:对Interface的端口方向进行限制"></a>Modport:对Interface的端口方向进行限制</h3><p>modport 同时还可以对信号进行分组。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> simple_bus (<span class="keyword">input</span> <span class="keyword">bit</span> clk) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> req, gnt, start, rdy ; <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] mode;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] addr; <span class="keyword">logic</span> [<span class="number">16</span>:<span class="number">0</span>] data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">modport</span> master ( <span class="keyword">input</span>,req,gnt,clk,mode,addr,<span class="keyword">output</span> data, start,</span><br><span class="line">rdy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">modport</span> slave (<span class="keyword">output</span> req,gnt,mode,addr,<span class="keyword">input</span> data, start, rdy);</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mem (simple_bus mbus);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cpu (simple_bus sbus);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top;</span><br><span class="line">    simple_bus busa();</span><br><span class="line">    mem mem_i (<span class="variable">.mbus</span> (busa<span class="variable">.master</span>));</span><br><span class="line">    cpu cpu_i (<span class="variable">.sbus</span> (busa<span class="variable">.slave</span>));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>


<h3 id="Interface中可以申明或调用task-和-function"><a href="#Interface中可以申明或调用task-和-function" class="headerlink" title="Interface中可以申明或调用task 和 function"></a>Interface中可以申明或调用task 和 function</h3><p>使用<code>import</code>,<code>export</code>来调用task。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-9.png" alt="Alt text"></p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-10.png" alt="Alt text"></p>
<p>区分：<br>import: module调用Interface中的task;<br>export: Interface中调用module中的task.  </p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tlm_sender (tlm_intf<span class="variable">.sender_mp</span> send_port);</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    send_port<span class="variable">.put</span>(<span class="string">&quot;n&quot;</span>);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tlm_receiver (tlm_intf<span class="variable">.receiver_mp</span> receive_port);</span><br><span class="line">    <span class="keyword">task</span> receive_port<span class="variable">.put</span>(<span class="keyword">input</span> <span class="keyword">byte</span> b);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;i got data =%0d&quot;</span>,b);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> tlm_intf();</span><br><span class="line">    <span class="keyword">modport</span> sender_mp(<span class="keyword">import</span> <span class="keyword">task</span> put(<span class="keyword">input</span> <span class="keyword">byte</span> b));<span class="comment">//注意import和export的用法。</span></span><br><span class="line">    <span class="keyword">modport</span> receiver_mp(<span class="keyword">export</span> <span class="keyword">task</span> put(<span class="keyword">input</span> <span class="keyword">byte</span> b));</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line">tlm_intf tlm_int0();</span><br><span class="line">tlm_sender tlm_sender0(tlm_int0<span class="variable">.sender_mp</span>);</span><br><span class="line">tlm_receiver tlm_receiver0(tlm_int0<span class="variable">.receiver_mp</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="带参数的Interface"><a href="#带参数的Interface" class="headerlink" title="带参数的Interface"></a>带参数的Interface</h3><p>Interface中可包含参数，用法和module中的参数一样。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> simple_bus <span class="variable">#(dwidth =32, awidth = 8) ( input bit clk )</span>;</span><br><span class="line">    <span class="keyword">logic</span> req,gnt,start,rdy ;</span><br><span class="line">    <span class="keyword">logic</span> [dwidth :<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">logic</span> [awidth:<span class="number">0</span>] addr;</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>


<h3 id="Virtual-Interface"><a href="#Virtual-Interface" class="headerlink" title="Virtual Interface"></a>Virtual Interface</h3><p>Interface作为一个特殊的类，无法在其他类的定义中进行例化。当在一个类中使用interface时，该interface必须被申明为virtual。<br><img src="/2024/02/12/System-Verilog-Notes/image-21.png" alt="Alt text"><br>virtual interface可以看作指向模块中实例化的interface的一个指针。</p>
<p>用法举例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个interface</span></span><br><span class="line"><span class="keyword">interface</span> my_if(<span class="keyword">input</span> clk, <span class="keyword">input</span> rst_n);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line">   <span class="keyword">logic</span> valid;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个UVM driver.</span></span><br><span class="line"><span class="keyword">class</span> my_driver <span class="keyword">extends</span> uvm_driver;</span><br><span class="line">    <span class="comment">//申明一个virtual interface</span></span><br><span class="line">   <span class="keyword">virtual</span> my_if vif;</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_driver)</span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">      `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;new is called&quot;</span>, UVM_LOW);</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">      `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;build_phase is called&quot;</span>, UVM_LOW);</span><br><span class="line">      <span class="comment">//virtual interface使用前必须被设置，类似指针必须赋值后使用</span></span><br><span class="line">      <span class="comment">//使用get函数，进程在调用时，将&quot;vif&quot;的值赋值给vif。</span></span><br><span class="line">      <span class="keyword">if</span>(!uvm_config_db<span class="variable">#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span></span><br><span class="line">         `uvm_fatal(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;virtual interface must be set for vif!!!&quot;</span>)</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> main_phase(uvm_phase phase);</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   phase<span class="variable">.raise_objection</span>(<span class="keyword">this</span>);</span><br><span class="line">   `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;main_phase is called&quot;</span>, UVM_LOW);</span><br><span class="line">   vif<span class="variable">.data</span> &lt;= <span class="number">8&#x27;b0</span>; </span><br><span class="line">   vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!vif<span class="variable">.rst_n</span>)</span><br><span class="line">      @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)<span class="keyword">begin</span></span><br><span class="line">      @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">      vif<span class="variable">.data</span> &lt;= $urandom_range(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">      vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">      `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;data is drived&quot;</span>, UVM_LOW);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">   vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">   phase<span class="variable">.drop_objection</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_if.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_driver.sv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top_tb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"><span class="keyword">reg</span> rst_n;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] rxd;</span><br><span class="line"><span class="keyword">reg</span> rx_dv;</span><br><span class="line"><span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] txd;</span><br><span class="line"><span class="keyword">wire</span> tx_en;</span><br><span class="line"><span class="comment">//例化两个interface</span></span><br><span class="line">my_if input_if(clk, rst_n);</span><br><span class="line">my_if output_if(clk, rst_n);</span><br><span class="line"></span><br><span class="line">dut my_dut(<span class="variable">.clk</span>(clk),</span><br><span class="line">           <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">           <span class="variable">.rxd</span>(input_if<span class="variable">.data</span>),</span><br><span class="line">           <span class="variable">.rx_dv</span>(input_if<span class="variable">.valid</span>),</span><br><span class="line">           <span class="variable">.txd</span>(output_if<span class="variable">.data</span>),</span><br><span class="line">           <span class="variable">.tx_en</span>(output_if<span class="variable">.valid</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">   clk = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">      #<span class="number">100</span> clk = ~clk;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">   rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">   #<span class="number">1000</span>;</span><br><span class="line">   rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//通过run_test例化了一个&quot;my driver&quot;</span></span><br><span class="line">   run_test(<span class="string">&quot;my_driver&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//设置虚拟端口的指向。使用的是UMV中的config_db操作，通过进程间通信的方式，将&quot;vif&quot;指向input_if</span></span><br><span class="line">   uvm_config_db<span class="variable">#(virtual my_if)::set(null, &quot;uvm_test_top&quot;, &quot;vif&quot;, input_if)</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h3><p>在设计中，顶层模块是一个module,在验证中，为了构建某种仿真环境，设计出program。program的目的是将testbench与DUT独立开来。</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test (<span class="keyword">input</span> clk, <span class="keyword">input</span> [<span class="number">16</span>:<span class="number">1</span>]</span><br><span class="line">    addr, <span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data);</span><br><span class="line">    <span class="keyword">initial</span> ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p>program与module的关系：<br>module中可以例化program,反之program不能例化module</p>
<p>program中不需要always块，例化module，申明interface,或申明其他program。只有initial和methods是允许的。</p>
<h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h3><p>目的：通过Package在不同module之间来共享代码。</p>
<p>example:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pack;</span><br><span class="line">    <span class="keyword">integer</span> global_counter ;</span><br><span class="line">    <span class="keyword">task</span> incr ;</span><br><span class="line">    … …</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endpackage</span> : pack</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mod1;</span><br><span class="line">    <span class="keyword">import</span> pack::* ;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    global_counter = <span class="number">567</span> ;</span><br><span class="line">    incr(); <span class="comment">// use as if it is locally</span></span><br><span class="line">    declared</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> : mod1</span><br></pre></td></tr></table></figure>

<h3 id="Clocking-block"><a href="#Clocking-block" class="headerlink" title="Clocking block"></a>Clocking block</h3><p>目的：调整数据和时钟的关系，使其满足建立时间和保持时间</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">clocking</span> cb1 @(<span class="keyword">posedge</span> clk); <span class="comment">// clocking block with clocking event</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">10</span>ns <span class="comment">//输入信号在翻转前10ns进行采样</span></span><br><span class="line">    <span class="keyword">output</span> #<span class="number">2</span>ns ; <span class="comment">// default timing skew for input/output，</span></span><br><span class="line">    <span class="comment">//输出信号在翻转后2ns开始输出</span></span><br><span class="line">    <span class="keyword">output</span> data; <span class="comment">// output from the clocking block</span></span><br><span class="line">    <span class="keyword">output</span> sel;</span><br><span class="line"><span class="keyword">endclocking</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-50.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] a0,a2, a3, a4; <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] a1;</span><br><span class="line"><span class="keyword">logic</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">clk=<span class="number">0</span>; <span class="keyword">for</span>( <span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) clk = #<span class="number">5</span> ~clk;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">for</span>( <span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) a1 = #<span class="number">2</span> ~a1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clocking</span> cb @(<span class="keyword">posedge</span> clk);</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">2</span> <span class="keyword">output</span> #<span class="number">3</span>;</span><br><span class="line"><span class="keyword">input</span> #<span class="number">2</span> a1;</span><br><span class="line"><span class="keyword">output</span> a0,a2 , a3 ;</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">negedge</span> a4;</span><br><span class="line"><span class="keyword">endclocking</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    @(cb);</span><br><span class="line">    cb<span class="variable">.a2</span> &lt;= <span class="number">3&#x27;b11</span>;</span><br><span class="line">    cb<span class="variable">.a4</span> &lt;= <span class="number">3&#x27;b10</span>;</span><br><span class="line">    cb<span class="variable">.a3</span> &lt;= a1;</span><br><span class="line">    cb<span class="variable">.a0</span> &lt;= cb<span class="variable">.a1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Race"><a href="#Race" class="headerlink" title="Race"></a>Race</h3><p>Two expressions scheduled to execute at same time, if order<br>of the execution is not determined, race condition occurs !</p>
<p>使用串行仿真器处理并行语言时遇到的困境。</p>
<p>想要避免race,需要理解仿真器对不同操作的<strong>调度顺序</strong></p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-12.png" alt="Alt text"></p>
<h2 id="LEC-8-面向对象设计"><a href="#LEC-8-面向对象设计" class="headerlink" title="LEC 8 面向对象设计"></a>LEC 8 面向对象设计</h2><p>为什么采用面向对象来构建testbench？</p>
<p>1.用于集成一些不同的数据类型。<br>2.提高可重用性，提升效率。<br>3.UVM&#x2F;OVM是基于OOP的。</p>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>类：包含一组数据类型和对应的操作方法(task和function)<br>对象：对象是类的一个例化。</p>
<p>类在定义时不占用内存。当对应的对象被例化时才占用。</p>
<h4 id="HDL与OOP的比较："><a href="#HDL与OOP的比较：" class="headerlink" title="HDL与OOP的比较："></a>HDL与OOP的比较：</h4><p><img src="/2024/02/12/System-Verilog-Notes/image-13.png" alt="Alt text"></p>
<h4 id="一个class的例子："><a href="#一个class的例子：" class="headerlink" title="一个class的例子："></a>一个class的例子：</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet ;</span><br><span class="line"><span class="comment">//data or class properties</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] command;</span><br><span class="line">    <span class="keyword">integer</span> time_requested;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; ERR_OVERFLOW= <span class="number">10</span>, ERR_UNDERFLOW = <span class="number">1123</span>&#125; PCKT_TYPE;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">integer</span> buffer_size = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        command = <span class="number">4&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="comment">// methods</span></span><br><span class="line">    <span class="keyword">task</span> clean();</span><br><span class="line">        command = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> issue_request( <span class="keyword">int</span> delay );</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">integer</span> current_status();</span><br><span class="line">        current_status = status;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h4 id="null类型"><a href="#null类型" class="headerlink" title="null类型"></a>null类型</h4><p>未被初始化的类型默认为null值(类似C++)</p>
<p>对象名被看作是对所分配内存的指针(或句柄(handle))</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> BusTran;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, crc, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">function</span> calc_crc;</span><br><span class="line">        calc_crc=addr^data;</span><br><span class="line">        endfuntion: calc_crc</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> display;</span><br><span class="line">        <span class="built_in">$display</span>(“BusTran: %h”, addr);</span><br><span class="line">    <span class="keyword">endfunction</span>:  display</span><br><span class="line"><span class="keyword">endclass</span>: BusTran</span><br><span class="line"></span><br><span class="line">BusTran b1,b2;</span><br><span class="line">    b1= <span class="keyword">new</span>();<span class="comment">//开辟新的空间</span></span><br><span class="line">    b2=b1;  <span class="comment">//b2指向上一步开辟的空间</span></span><br><span class="line">    b1 = <span class="keyword">new</span>(); <span class="comment">//b1指向新的空间</span></span><br><span class="line">    b1<span class="variable">.addr</span>=<span class="number">32</span>’h42;</span><br><span class="line">    b1<span class="variable">.display</span>();</span><br><span class="line">b2 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>


<p>class 中的方法只有<strong>function</strong>和<strong>task</strong></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line"><span class="keyword">integer</span> command;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">    command = IDLE;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>内建的构造函数命名为new。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> my_class;</span><br><span class="line">    <span class="keyword">integer</span> count ;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span> ();</span><br><span class="line">        count = <span class="number">5</span> ;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">my_class c1 = <span class="keyword">new</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my_class;</span><br><span class="line">    <span class="keyword">integer</span> count ;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">input</span> <span class="keyword">int</span> temp);</span><br><span class="line">        count = temp ;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line">my_class c1 = <span class="keyword">new</span> (<span class="number">44</span>) ;</span><br></pre></td></tr></table></figure>
<p>区分new()和new[]:<br>分别用于类和数组。</p>
<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>用途：在不同对象之间建立联系。相当于class中的公共空间。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        id = count++;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction b1,b2;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    b1=<span class="keyword">new</span>; <span class="comment">//first instance, id=0</span></span><br><span class="line">    b2=<span class="keyword">new</span>; <span class="comment">//second instance, id=1</span></span><br><span class="line">    <span class="built_in">$display</span>(b2<span class="variable">.id</span>, b2<span class="variable">.count</span>);<span class="comment">//1,2;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>也可以定义 static的方法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">function</span> <span class="keyword">int</span> next_id();</span><br><span class="line">        next_id = ++current; <span class="comment">// OK to access static class property</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>对static方法的每次调用都会独立的执行一次该方法。example:</p>
<p>static 方法中的变量仍然是动态的。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> A ;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">task</span> incr();</span><br><span class="line">        <span class="keyword">int</span> j; <span class="comment">//automatic variable</span></span><br><span class="line">        j++;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;J is %d&quot;</span>,j);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> main ;</span><br><span class="line">    A obj_1;</span><br><span class="line">    A obj_2;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;static task with automatic variables&quot;</span>);</span><br><span class="line">        obj_1 = <span class="keyword">new</span>();</span><br><span class="line">        obj_2 = <span class="keyword">new</span>();</span><br><span class="line">        obj_1<span class="variable">.incr</span>();</span><br><span class="line">        obj_2<span class="variable">.incr</span>();</span><br><span class="line">        obj_1<span class="variable">.incr</span>();</span><br><span class="line">        obj_2<span class="variable">.incr</span>();</span><br><span class="line">        A::incr();</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Each call to task will create a separate</span></span><br><span class="line"><span class="string">        copy of &#x27;j&#x27; and increment it&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p>result：<img src="/2024/02/12/System-Verilog-Notes/image-14.png" alt="Alt text">  </p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>内建语句，用于表示当前的对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>使用关键词 <code>extends</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">1024</span>], crc;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BadTr <span class="keyword">extends</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> bad_crc;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">BadTr bt;</span><br><span class="line">bt = <span class="keyword">new</span>;</span><br><span class="line">bt<span class="variable">.src</span> = <span class="number">42</span>;</span><br><span class="line">bt<span class="variable">.bad_crc</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>继承使得一个类可以在父类的基础特性上增加新的特性。<br><img src="/2024/02/12/System-Verilog-Notes/image-51.png" alt="Alt text"></p>
<p>使用关键词<code>super</code>调用父类的方法。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data[<span class="number">1024</span>], crc;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> calc_crc();</span><br><span class="line">        crc = src ^ dst ^ data<span class="variable">.xor</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BadTr <span class="keyword">extends</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> bad_crc;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> calc_crc();</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.calc_crc</span>();</span><br><span class="line">    <span class="keyword">if</span> (bad_crc) crc = ~crc;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h3 id="虚函数和虚方法-virtual"><a href="#虚函数和虚方法-virtual" class="headerlink" title="虚函数和虚方法(virtual)"></a>虚函数和虚方法(virtual)</h3><p>用途:用于构建模板，只有被继承时才可以例化。</p>
<p>虚函数在被重构后产生多态，不同继承对象调用同一函数时，产生不同的效果。</p>
<p>使用虚函数的好处</p>
<ol>
<li>灵活性：允许在运行时根据对象的实际类型调用正确的方法。</li>
<li>可扩展性：可以在不修改现有代码的情况下，通过添加新的派生类来扩展功能。</li>
<li>封装：允许派生类修改或扩展基类的行为，而不影响使用基类引用的代码。</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> BasePacket;</span><br><span class="line">    <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> B = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> printA;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;BasePacket::A is %d&quot;</span>, A);</span><br><span class="line">    <span class="keyword">endfunction</span> : printA</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> printB;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;BasePacket::B is %d&quot;</span>, B);</span><br><span class="line">    <span class="keyword">endfunction</span> : printB</span><br><span class="line"><span class="keyword">endclass</span> : BasePacket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> My_Packet <span class="keyword">extends</span> BasePacket;</span><br><span class="line">    <span class="keyword">int</span> A = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> B = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> printA;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;My_Packet::A is %d&quot;</span>, A);</span><br><span class="line">    <span class="keyword">endfunction</span>: printA</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> printB;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;My_Packet::B is %d&quot;</span>, B);</span><br><span class="line">    <span class="keyword">endfunction</span> : printB</span><br><span class="line"><span class="keyword">endclass</span> : My_Packet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Program test_virtual_method()</span><br><span class="line"></span><br><span class="line">BasePacket P1 = <span class="keyword">new</span>;</span><br><span class="line">My_Packet P2 = <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    P1<span class="variable">.printA</span>; <span class="comment">// displays &#x27;BasePacket::A is 1&#x27;</span></span><br><span class="line">    P1<span class="variable">.printB</span>; <span class="comment">// displays &#x27;BasePacket::B is 2&#x27;</span></span><br><span class="line">    P1 = P2; <span class="comment">// P1 has a handle to a My_packet object ，一个upcasting操作</span></span><br><span class="line">    P1<span class="variable">.printA</span>; <span class="comment">// displays &#x27;BasePacket::A is 1&#x27;</span></span><br><span class="line">    P1<span class="variable">.printB</span>; <span class="comment">// displays &#x27;My_Packet::B is 4&#x27; – latest derived method</span></span><br><span class="line">    P2<span class="variable">.printA</span>; <span class="comment">// displays &#x27;My_Packet::A is 3&#x27;</span></span><br><span class="line">    P2<span class="variable">.printB</span>; <span class="comment">// displays &#x27;My_Packet::B is 4&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理解：虚函数运行多态，当基类被upcasting给派生类后，可以调用派生类的方法。相反，如果不是虚函数，则还是调用原来自己有的方法。</p>
<h3 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h3><p>upcasting: 将子类的对象赋值给父类</p>
<p>downcasting: 不合法的操作。子类被看作是独立于父类的对象。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> father_class;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] fsrc=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">input</span> <span class="keyword">string</span> prefix=<span class="string">&quot;f* &quot;</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%sfather_class:fsrc=%d&quot;</span>,prefix,fsrc);</span><br><span class="line">    <span class="keyword">endfunction</span> </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> child_class <span class="keyword">extends</span> father_class;</span><br><span class="line">    <span class="keyword">bit</span> csrc=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">input</span> <span class="keyword">string</span> prefix=<span class="string">&quot;c* &quot;</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%schild_class:csrc=%b&quot;</span>,prefix,csrc);</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.display</span>(prefix);</span><br><span class="line">    <span class="keyword">endfunction</span> </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> test_cast();</span><br><span class="line">    father_class fhandler;</span><br><span class="line">    child_class chandler;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//Construct childclass extended object</span></span><br><span class="line">        chandler=<span class="keyword">new</span>(); </span><br><span class="line">        <span class="comment">//Base handle points to extended obj </span></span><br><span class="line">        fhandler=chandler;  <span class="comment">//父给子是合法的。</span></span><br><span class="line">        <span class="comment">// Display variable in base classCalls</span></span><br><span class="line">        <span class="built_in">$display</span>(fhandler<span class="variable">.fsrc</span>); </span><br><span class="line">        fhandler<span class="variable">.display</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_cast();</span><br><span class="line">    father_class fhandler;</span><br><span class="line">    child_class chandler;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//Construct childclass extended object</span></span><br><span class="line">        fhandler =<span class="keyword">new</span>(); </span><br><span class="line">        <span class="comment">//Base handle points to extended obj </span></span><br><span class="line">        Chandler= fhandler; </span><br><span class="line">        <span class="comment">// Display variable in base classCalls</span></span><br><span class="line">        <span class="built_in">$display</span>(fhandler<span class="variable">.fsrc</span>); </span><br><span class="line">        fhandler<span class="variable">.display</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>产生编译错误：</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-52.png" alt="Alt text"></p>
<h2 id="LEC9-跨进程同步与通信"><a href="#LEC9-跨进程同步与通信" class="headerlink" title="LEC9 跨进程同步与通信"></a>LEC9 跨进程同步与通信</h2><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>与进程类似，不同之处在于线程是进程的一个更小单位。线程共享内存资源。</p>
<h3 id="SV中的过程："><a href="#SV中的过程：" class="headerlink" title="SV中的过程："></a>SV中的过程：</h3><p>一个过程块中的代码可以被独立看作一个线程。<br>如：</p>
<p>initial<br>always<br>final<br>fork … join  (创建并行语句)<br>task&#x2F;function<br>assign </p>
<h4 id="begin-…-end"><a href="#begin-…-end" class="headerlink" title="begin … end"></a>begin … end</h4><p> 两种赋值方式：阻塞赋值和非阻塞赋值。非阻塞赋值可以看作是并行的。</p>
<h4 id="fork-join"><a href="#fork-join" class="headerlink" title="fork join"></a>fork join</h4><p> example:<br> <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">module</span> inline_ tb;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>: <span class="number">0</span>] data_ bus;</span><br><span class="line"><span class="comment">// instance of DUT</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">        data_bus = <span class="number">8&#x27;b00</span>;</span><br><span class="line">        #<span class="number">10</span> data_bus = <span class="number">8&#x27;h45</span>;</span><br><span class="line">        #<span class="number">20</span> <span class="keyword">repeat</span> (<span class="number">10</span>) #<span class="number">10</span> data_bus = data_bus + <span class="number">1</span>;</span><br><span class="line">        #<span class="number">25</span> <span class="keyword">repeat</span> (<span class="number">5</span>) #<span class="number">20</span> data_bus = data_bus &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        #<span class="number">140</span> data_bus = <span class="number">8&#x27;h0f</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>SV中新增的特性：<br>fork join_any 和 fork join_none<br><img src="/2024/02/12/System-Verilog-Notes/image-16.png" alt="Alt text"></p>
<p>join_any:父进程阻塞，直到fork中的任意一个线程结束(exit(0));</p>
<p>join_none:父进程不管子进程是否结束，继续执行。<br>需要注意的是：fork join_none创建的子进程只会被调度，而不会被执行。除非下一个事件发生。</p>
<p>如:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_fork_joinnone;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;First Block \n&quot;</span>);<span class="comment">//不会被执行</span></span><br><span class="line">    # <span class="number">20</span>ns;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Second Block \n&quot;</span>);<span class="comment">//不会被执行</span></span><br><span class="line">    # <span class="number">30</span>ns;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join_none</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;continue main process&quot;</span>);</span><br><span class="line">    <span class="comment">//#0 $display(&quot;finish for_join&quot;); 除非加上这句。</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p>使用fork join创建多线程时，需要注意变量的值的变化：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_join_none_var;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; <span class="number">3</span>;j++ )</span><br><span class="line">        <span class="comment">//automatic int k=j;</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">automatic</span> <span class="keyword">int</span> k=j;</span><br><span class="line">            <span class="built_in">$display</span>(k);</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">        #<span class="number">0</span> <span class="built_in">$display</span>(<span class="string">&quot;finish_forjoin&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-17.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_join_none_var;</span><br><span class="line">    <span class="keyword">int</span> k,j;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; <span class="number">3</span>;j++ ) <span class="keyword">begin</span></span><br><span class="line">            k=j;</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="built_in">$display</span>(k);</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">0</span> <span class="built_in">$display</span>(<span class="string">&quot;finish_forjoin&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-55.png" alt="Alt text"><br>    二者的区别在于automic关键字</p>
<p>辨析：任务或函数被声明为 automatic 时，每次调用都会在堆栈上创建新的存储空间。这意味着每个调用都有自己的局部变量副本，这些变量在调用之间是独立的。这种行为对于递归调用和在并发进程中调用任务或函数非常重要，因为它防止了不同调用之间的数据冲突。</p>
<p>SV中，线程是被动态构造出来的。</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="wait-事件触发。"><a href="#wait-事件触发。" class="headerlink" title="wait: 事件触发。"></a>wait: 事件触发。</h4><p>使用<strong>wait fork</strong>确保所有的子进程都被执行完毕:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> do_test;</span><br><span class="line"><span class="comment">//begin</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        exec1();</span><br><span class="line">        exec2();</span><br><span class="line">        <span class="keyword">join_any</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        exec3();</span><br><span class="line">        exec4();</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    <span class="keyword">wait</span> <span class="keyword">fork</span>;</span><br><span class="line"><span class="comment">//end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>


<p><strong>wait_order()</strong>:指定事件的发生顺序。</p>
<h4 id="disable"><a href="#disable" class="headerlink" title="disable"></a>disable</h4><p>使用disable结束特定的线程。</p>
<h4 id="EVENTS"><a href="#EVENTS" class="headerlink" title="EVENTS"></a>EVENTS</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">event</span> e1;</span><br></pre></td></tr></table></figure>
<p>event被看作是一种<strong>数据类型</strong>，但其本身没有数据值，仅用作同步信号。可以用作进程或线程之间通信的手段。一个进程可以<strong>等待（wait）</strong>一个事件，而另一个进程可以<strong>触发（trigger）</strong>这个事件。</p>
<p><code>@</code>操作符用于<strong>等待</strong>某个事件发生，当使用<code>@</code>操作符后的进程被阻塞，直到相应的event被触发。</p>
<p><code>-&gt;</code>和<code>-&gt;&gt;</code>用于触发事件，其区别在于前者是阻塞的，后者是非阻塞的。<br>使用 <code>-&gt; </code>触发事件时，事件会立即被触发。这意味着在当前时间点，所有等待该事件的进程都会被唤醒。<br>使用 <code>-&gt;&gt;</code> 时，事件的触发会被安排在当前时间点之后的最近的未来时间点。这是一种非阻塞触发，它允许当前进程继续执行，而不是立即切换到等待该事件的进程。</p>
<p>需要注意的是，某个事件的触发必须在等待之后，而不是之前。否则对应的进程无法被调度。</p>
<h5 id="example"><a href="#example" class="headerlink" title="example:"></a>example:</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> p_event;</span><br><span class="line"><span class="keyword">event</span> ev;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">fork</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">wait</span>(ev<span class="variable">.triggered</span>)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            @(ev)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block2&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            -&gt;ev;</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;trigger ev&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            @(ev)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block3&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">wait</span>(ev<span class="variable">.triggered</span>)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;ev state is observed at block4&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">join</span> </span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-18.png" alt="Alt text"></p>
<h5 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h5><p>block2触发但是1没触发。说明@的机制是串行的，虽然写在fork中，但是并不能真的并行。实际上，同一个fork制造的并行语句<code>@(ev)</code>和<code>-&gt;ev;</code>构成了一种竞争(race)，同一个时刻内事件到底是先触发还是先观测，构成了一种<strong>冲突</strong>。</p>
<p>在 SystemVerilog 或任何并发编程环境中，”race condition”（竞争条件）是指两个或多个进程（或线程）在访问共享资源时，最终结果依赖于进程执行的精确时序或顺序。当进程以不可预测的方式相互干扰时，就会发生竞争条件，这可能导致不一致或错误的行为。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享变量</span></span><br><span class="line"><span class="keyword">int</span> shared_var;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 1</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    shared_var = shared_var + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 2</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    shared_var = shared_var + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，最终 shared_var 的值取决于两个进程执行的相对时序，这就是一个竞争条件。使用同步机制（如信号量）可以解决这个问题。(见下节)</p>
<h5 id="triggered机制"><a href="#triggered机制" class="headerlink" title="triggered机制"></a>triggered机制</h5><p> SystemVerilog 中，每个 event 类型的对象都有一个名为 triggered 的内置属性。这个属性用于检查事件是否已经被触发。</p>
<p>triggered 属性的作用：</p>
<ol>
<li>状态检查：triggered 属性返回一个布尔值，指示自上次检查以来事件是否被触发。如果事件被触发，它返回 true；否则返回 false。</li>
<li>重置行为：一旦 triggered 属性被读取，事件的触发状态就会被重置。这意味着如果你再次检查 triggered 属性，除非事件在此期间再次被触发，否则它将返回 false。</li>
</ol>
<h5 id="event之间可以相互赋值。"><a href="#event之间可以相互赋值。" class="headerlink" title="event之间可以相互赋值。"></a>event之间可以相互赋值。</h5><p>当一个事件被赋值给另一个时，原来的事件不会再被触发执行。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_merge_event;</span><br><span class="line">    <span class="keyword">event</span> E1,E2,E3;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        E2 = E1;</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            T1: <span class="keyword">begin</span></span><br><span class="line">                @ E1;</span><br><span class="line">                <span class="built_in">$display</span>(“unblock T1”);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            T2: <span class="keyword">begin</span></span><br><span class="line">                @ E2;</span><br><span class="line">                <span class="built_in">$display</span>(“unblock T2”);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            T3: <span class="keyword">begin</span> </span><br><span class="line">                @ E3;</span><br><span class="line">                <span class="built_in">$display</span>(“unblock T3”);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            T4: <span class="keyword">begin</span> </span><br><span class="line">                E2 = E3;</span><br><span class="line">                -&gt; E3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>理解：当一个进程被阻塞，等待某个event被触发时，如果原本的envent被赋值给了另一个event，则原来的envent永远不会被触发，对应的进程一直处于阻塞状态。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-19.png" alt="Alt text"></p>
<h4 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore  信号量"></a>Semaphore  信号量</h4><p>信号量（semaphores）是一种同步机制，用于控制对共享资源的访问，特别是在并发环境中。信号量主要用于解决竞争条件，确保在任何给定时间只有一个特定数量的进程可以访问共享资源。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>互斥访问：信号量可以确保对共享资源的互斥访问，防止多个进程同时修改同一资源。<br>控制资源访问：可以限制同时访问某个资源的进程数量，这对于管理有限资源（如内存、文件句柄等）非常有用。</p>
<h5 id="SV中信号量的定义："><a href="#SV中信号量的定义：" class="headerlink" title="SV中信号量的定义："></a>SV中信号量的定义：</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> semaphore;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> keyCount = <span class="number">0</span>);</span><br><span class="line"><span class="comment">//keycount specifies number of keys initially allocated</span></span><br><span class="line"><span class="comment">//default 0</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> put(<span class="keyword">int</span> keyCount = <span class="number">1</span>);</span><br><span class="line"><span class="comment">//returns specified number of keys to semaphore waiting</span></span><br><span class="line"><span class="comment">//process can grab these keys,</span></span><br><span class="line"><span class="comment">//default 1</span></span><br><span class="line"><span class="keyword">task</span> get(<span class="keyword">int</span> keyCount = <span class="number">1</span>);</span><br><span class="line"><span class="comment">//if specified number of keys are not available, process blocks !</span></span><br><span class="line"><span class="comment">//default 1</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> try_get(<span class="keyword">int</span> keyCount = <span class="number">1</span>);</span><br><span class="line"><span class="comment">//if specified number of keys available, method returns 1 and</span></span><br><span class="line"><span class="comment">//execution continues, if not, method returns 0.</span></span><br><span class="line"><span class="comment">//default 1</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>new用于构造一个新的信号量。<br>get相当于C语言中的semwait()<br>put相当于C语言中的semsignal()</p>
<h5 id="example-1"><a href="#example-1" class="headerlink" title="example:"></a>example:</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> semaphore_ex;</span><br><span class="line">    semaphore semBus = <span class="keyword">new</span>(<span class="number">1</span>);<span class="comment">//构造一个新的信号量，初始值为1，代表只有一个资源。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">fork</span></span><br><span class="line">                agent(<span class="string">&quot;AGENT 0&quot;</span>,<span class="number">5</span>);</span><br><span class="line">                agent(<span class="string">&quot;AGENT 1&quot;</span>,<span class="number">20</span>);</span><br><span class="line">            <span class="comment">// 使用fork 构造并行，使2个函数抢占同一个资源。</span></span><br><span class="line">            <span class="keyword">join</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> <span class="keyword">automatic</span> agent(<span class="keyword">string</span> name, <span class="keyword">integer</span> nwait);</span><br><span class="line">        <span class="keyword">integer</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">4</span>; i ++ ) <span class="keyword">begin</span></span><br><span class="line">            semBus<span class="variable">.get</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;[%0d] Lock semBus for %s&quot;</span>, <span class="built_in">$time</span>,name);</span><br><span class="line">            <span class="variable">#(nwait)</span>;</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;[%0d] Release semBus for %s&quot;</span>, <span class="built_in">$time</span>,name);</span><br><span class="line">            semBus<span class="variable">.put</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="variable">#(nwait)</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-20.png" alt="Alt text"></p>
<h4 id="Mailbox"><a href="#Mailbox" class="headerlink" title="Mailbox"></a>Mailbox</h4><p>邮箱，用于进行进程中的数据通信。相当于C中的pipe。  邮箱（Mailbox）是一种用于进程间通信的同步机制。它允许一个进程向邮箱发送（put）消息，而另一个或多个进程可以从邮箱接收（get）这些消息。邮箱在并发编程中非常有用，特别是当需要在不同进程间安全地传递数据时。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-56.png" alt="Alt text"><br>可以看作是一个FIFO。</p>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> mailbox <span class="variable">#(type T = dynamic_singular_type)</span> ;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> bound = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// mail box constructor, optionally specifies the max size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> num();</span><br><span class="line">    <span class="comment">// returns the number of messages currently in mailbox</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> put( T message);</span><br><span class="line">    <span class="comment">// places a message in mailbox; blocks if mailbox full</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> try_put( T message);</span><br><span class="line">    <span class="comment">// places a message in mailbox; returns 0 if mailbox full</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> get( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">// retrieves message from mailbox; blocks if mailbox empty; error if type mismatch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> try_get( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">// retrieves message from mailbox; returns 0/+1/-1; empty/success/type mismatch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> peek( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">// copies message from mailbox; blocks if mailbox empty; error if type mismatch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> try_peek( <span class="keyword">ref</span> T message );</span><br><span class="line">    <span class="comment">//copies message from mailbox; returns 0/+1/-1; empty/success/type mismatch</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h5 id="example-2"><a href="#example-2" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> test_mailbox1 ;</span><br><span class="line">    mailbox <span class="variable">#(string) my_mailbox = new(4)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (my_mailbox) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">fork</span></span><br><span class="line">                put_data();</span><br><span class="line">                get_data();</span><br><span class="line">            <span class="keyword">join</span> </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> get_data();</span><br><span class="line">        <span class="keyword">string</span> rdata;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) <span class="keyword">begin</span></span><br><span class="line">                #<span class="number">2</span>;</span><br><span class="line">                my_mailbox<span class="variable">.get</span> (rdata);</span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">&quot;Reading Data %s @time %d&quot;</span>,rdata, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> put_data();</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">string</span> t;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) <span class="keyword">begin</span></span><br><span class="line">                #<span class="number">2</span>;</span><br><span class="line">                <span class="built_in">$sformat</span>(t,<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">                my_mailbox<span class="variable">.put</span>(t);</span><br><span class="line">                my_mailbox<span class="variable">.put</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;Writing Data %d @time %d&quot;</span>,i, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-57.png" alt="Alt text"></p>
<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><ol>
<li>阻塞行为：get 方法在等待消息时会阻塞进程。如果需要非阻塞行为，可以使用 try_get 或 get_nb 方法。</li>
<li>数据类型：邮箱可以传递任何类型的数据，但发送者和接收者必须对如何解释数据达成一致。</li>
<li>同步和异步：邮箱提供了一种同步机制，但它也可以用于异步通信，取决于如何使用 get 和 put 方法。</li>
</ol>
<h4 id="Semaphore和Mailbox的比较"><a href="#Semaphore和Mailbox的比较" class="headerlink" title="Semaphore和Mailbox的比较"></a>Semaphore和Mailbox的比较</h4><pre><code>1. 目的：信号量用于控制资源访问（主要是互斥），而邮箱用于数据传递。
2. 机制：信号量通过计数来控制资源访问，邮箱通过存储和传递消息来实现通信。
3. 数据处理：信号量不处理数据，邮箱则用于具体的数据传递。
4. 阻塞条件：在信号量中，进程阻塞是因为没有可用资源；在邮箱中，进程阻塞是因为没有消息可读。
</code></pre>
<h2 id="Assertions-断言"><a href="#Assertions-断言" class="headerlink" title="Assertions 断言"></a>Assertions 断言</h2><h3 id="什么是assertion"><a href="#什么是assertion" class="headerlink" title="什么是assertion?"></a>什么是assertion?</h3><p>一些检查性的代码，可以用于检测代码的功能覆盖率，做形式化验证等。assertion用于验证设计的行为是否符合预期。断言主要用于动态验证，即在仿真运行时检查特定的条件或属性。它们是确保设计符合其规范的关键组成部分，特别是在复杂的硬件设计和验证过程中。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-22.png" alt="Alt text"></p>
<h4 id="断言的用途"><a href="#断言的用途" class="headerlink" title="断言的用途"></a>断言的用途</h4><pre><code>1. 检测错误：在设计早期发现错误，如逻辑错误、时序问题。例如FIFO的读空写满，FSM一些非法状态的跳转，协议的握手等。
2.文档化设计意图：断言可以作为设计意图的一部分，帮助其他工程师理解代码的预期行为。
2. 提高验证覆盖率：使用断言可以更全面地验证设计，确保覆盖各种边缘情况。
3. 减少调试时间：当断言失败时，它们提供了关于错误位置和原因的即时反馈。
</code></pre>
<h4 id="example-3"><a href="#example-3" class="headerlink" title="example:"></a>example:</h4><p>检查a的上升沿的3个时钟周期内，b是否到达上升沿。<br><strong>verilog 的写法：</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> a) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">repeat</span> (<span class="number">1</span>) @(<span class="keyword">posedge</span> clk);</span><br><span class="line">    <span class="keyword">fork</span>： a_to_b</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> b)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;SUCCESS： b arrived in time\n&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">disable</span> a_to_b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">repeat</span> (<span class="number">3</span>) @(<span class="keyword">posedge</span> clk);</span><br><span class="line">            <span class="built_in">$display</span></span><br><span class="line">            (<span class="string">&quot;ERROR：b did not arrive in time\n&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">disable</span> a_to_b;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">join</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>assertion的写法：</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a_to_b_chk：</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span></span><br><span class="line">@(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(a) |-&gt; ##[<span class="number">1</span>：<span class="number">3</span>] <span class="built_in">$rose</span>(b);</span><br></pre></td></tr></table></figure>

<h3 id="Assertion-Based-Verification"><a href="#Assertion-Based-Verification" class="headerlink" title="Assertion Based Verification"></a>Assertion Based Verification</h3><p>对于时序检查很有用 ，同时可以检查功能覆盖率</p>
<p>例，宏定义</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test();</span><br><span class="line">…</span><br><span class="line"><span class="meta">`<span class="keyword">ifndef</span> NO_INLINED_ASSERTION</span></span><br><span class="line">    st_hold: <span class="keyword">assert</span> <span class="keyword">property</span>( @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    (!reset &amp;&amp; (!st_in &amp;&amp; ready_in))</span><br><span class="line">    |-&gt; ##<span class="number">1</span> (st_in [*<span class="number">1</span>:$]) ##<span class="number">0</span> accepted_in)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">$display</span>(“st_in did <span class="keyword">not</span> hold till accepted_in”);</span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Assertion-库"><a href="#Assertion-库" class="headerlink" title="Assertion 库"></a>Assertion 库</h3><p>Open Verification Library (OVL)<br>Formal Property Language Sugar<br>OpenVera<br>SystemVerilog Assertions  </p>
<p>Assertion优缺点：</p>
<p>1.更容易DEBUG<br>2.可以和C联用<br>3.设计意图可以更好体现</p>
<p>会降低仿真速度。</p>
<h3 id="Assertion的分类："><a href="#Assertion的分类：" class="headerlink" title="Assertion的分类："></a>Assertion的分类：</h3><p><strong>即时断言（Immediate Assertions）：</strong><br>    类似组合逻辑<br>    在表达式求值后立即检查条件。<br>    如果条件为假，则断言失败。<br>    通常用于检查在特定代码点必须为真的条件。</p>
<p><strong>并发断言（Concurrent Assertions）:</strong><br>    类似时序逻辑<br>    在仿真过程中连续检查条件。<br>    使用序列（sequence）和属性（property）来描述复杂的时序行为。<br>    适用于验证设计的时序特性。<br><img src="/2024/02/12/System-Verilog-Notes/image-23.png" alt="Alt text"></p>
<h4 id="Immediate-Assertions举例："><a href="#Immediate-Assertions举例：" class="headerlink" title="Immediate Assertions举例："></a>Immediate Assertions举例：</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">assertion_label : <span class="keyword">assert</span> (expression)</span><br><span class="line">    pass block code;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fail block code;<span class="comment">//0,x,z</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> assert_immediate();</span><br><span class="line">    <span class="keyword">reg</span> clk, grant, request;</span><br><span class="line">    <span class="keyword">time</span> current_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        grant = <span class="number">0</span>;</span><br><span class="line">        request = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">4</span> request = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">4</span> grant = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">4</span> request = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">4</span> <span class="built_in">$finish</span>; </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">1</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (grant == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            CHECK_REQ_WHEN_GNT : <span class="keyword">assert</span> (grant &amp;&amp; request) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">&quot;Seems to be working as expected&quot;</span>);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                current_time = <span class="built_in">$time</span>;</span><br><span class="line">                #<span class="number">1</span> <span class="built_in">$error</span>(<span class="string">&quot;assert failed at time %0t&quot;</span>, current_time);</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-24.png" alt="Alt text"><br>绿色三角：assertion通过<br>红色三角：assertion失败</p>
<h5 id="SV的调度顺序"><a href="#SV的调度顺序" class="headerlink" title="SV的调度顺序"></a>SV的调度顺序</h5><p><img src="/2024/02/12/System-Verilog-Notes/image-25.png" alt="Alt text">  </p>
<p><strong>preponed</strong>: 这个阶段发生在仿真时间步的最开始，进行变量的取值。<br><strong>observed</strong>:在这个阶段，可以观察到所有信号和变量的状态，但不应该产生任何新的活动或更改状态。这主要用于监控和检查目的。<br><strong>reactive</strong>:在这个阶段，可以根据之前阶段的观察结果做出反应。(pass&#x2F;fail)</p>
<p><strong>Active Phase</strong>：在这个阶段执行大部分代码，包括非阻塞赋值的右侧表达式和大多数程序语句。</p>
<p><strong>Inactive Phase</strong>：在这个阶段，非阻塞赋值的左侧被更新。</p>
<p><strong>NBA (Non-Blocking Assignment) Update Phase</strong>：在这个阶段，所有非阻塞赋值的更新发生。</p>
<p><strong>Preponed Phase</strong>：这是一个特殊的阶段，用于处理一些特殊的建模需求，如在所有其他活动之前读取信号的最终值。</p>
<p><strong>Observed Phase</strong>：在这个阶段，可以观察到所有赋值的结果，但不允许更改任何状态。</p>
<p><strong>Reactive Phase</strong>：在这个阶段，可以根据之前阶段的观察结果来做出反应，如调整内部状态或发出新的输出。</p>
<p><strong>Postponed Phase</strong>：这是仿真时间步的最后阶段，通常用于处理仿真结束等特殊情况。</p>
<h4 id="并发断言-Concurrent-assertions："><a href="#并发断言-Concurrent-assertions：" class="headerlink" title="并发断言 Concurrent assertions："></a>并发断言 Concurrent assertions：</h4><h5 id="example-4"><a href="#example-4" class="headerlink" title="example:"></a>example:</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> request</span><br><span class="line">    Req;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> acknowledge</span><br><span class="line">    ##[<span class="number">1</span>:<span class="number">2</span>] Ack;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> handshake;</span><br><span class="line">    @(<span class="keyword">posedge</span> Clock) request |-&gt; acknowledge;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span> (handshake);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-58.png" alt="Alt text"><br>构造sequence和property,之后用assert来检查。</p>
<h3 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> name_of_sequence;</span><br><span class="line">    &lt;test expression&gt;;</span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>
<p>sequence 用于描述一系列事件发生的顺序。它定义了一组在时间上相关的条件，这些条件必须按特定的顺序发生。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> seq_A_before_B;</span><br><span class="line">    A ##<span class="number">1</span> B;</span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>

<h4 id="时序检查"><a href="#时序检查" class="headerlink" title="时序检查"></a>时序检查</h4><p>两个井号代表一个时钟周期。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">##<span class="number">3</span> <span class="comment">//3个clock</span></span><br><span class="line"></span><br><span class="line">req ##<span class="number">1</span> gnt ##<span class="number">1</span> !req</span><br><span class="line"><span class="comment">//req should be trueon the current clock tick</span></span><br><span class="line"><span class="comment">//gnt should be true on the subsequent clock tick,</span></span><br><span class="line"><span class="comment">//req shall be false on the next clock tick after that</span></span><br></pre></td></tr></table></figure>

<h5 id="example-5"><a href="#example-5" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_clk_dly;</span><br><span class="line">    <span class="keyword">reg</span> a,b,clk;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">        clk=<span class="number">1&#x27;b0</span>; a=<span class="number">1&#x27;b0</span>;b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">1</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">3</span> <span class="keyword">begin</span></span><br><span class="line">            a=<span class="number">1&#x27;b0</span>; b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        #<span class="number">5</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">7</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">9</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">11</span> b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">13</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">15</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">17</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">21</span> b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">23</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">25</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">27</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">29</span> b=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">31</span> b=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">1</span> clk=!clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sequence</span> s1;</span><br><span class="line">        @(<span class="keyword">posedge</span> clk) a ##<span class="number">2</span> b;</span><br><span class="line">    <span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">property</span> p1;</span><br><span class="line">        s1;</span><br><span class="line">    <span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">    assertion1: <span class="keyword">assert</span> <span class="keyword">property</span>(p1);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-59.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:<span class="number">3</span>] c;</span><br><span class="line">    <span class="comment">//The sequence requires that c occurs 0,1,2 or 3 cycles after b</span></span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:$] c;</span><br><span class="line">    <span class="comment">//The sequence requires that c occurs 0,1,2… or infinite cycles after b</span></span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>

<h4 id="重复-repetition"><a href="#重复-repetition" class="headerlink" title="重复(repetition)"></a>重复(repetition)</h4><h5 id="consecutive-repetition"><a href="#consecutive-repetition" class="headerlink" title="consecutive repetition"></a>consecutive repetition</h5><p>consecutive 重复指的是事件必须连续发生，没有间隔。<br>用法：使用简单的重复操作符（如 [*n]）表示连续重复。</p>
<h6 id="example-6"><a href="#example-6" class="headerlink" title="example"></a>example</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a ##<span class="number">1</span> b ##<span class="number">1</span> b ##<span class="number">1</span> b ##<span class="number">1</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment">//can be writen as:</span></span><br><span class="line">a ##<span class="number">1</span> b[*<span class="number">3</span>] ##<span class="number">1</span> c</span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p21;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(start) |-&gt; ##<span class="number">2</span> (a[*<span class="number">3</span>]) ##<span class="number">2</span> stop ##<span class="number">1</span> !stop;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a21:<span class="keyword">assert</span> <span class="keyword">property</span>(p21);</span><br></pre></td></tr></table></figure>
<h5 id="Goto-Repetition"><a href="#Goto-Repetition" class="headerlink" title="Goto Repetition"></a>Goto Repetition</h5><p>goto 重复允许在重复的事件之间有间隔，但一旦开始，后续事件必须连续发生。<br>用法：使用 -&gt; 操作符表示 goto 重复。<br><img src="/2024/02/12/System-Verilog-Notes/image-28.png" alt="Alt text"><br>中间会有2到10个b的高电平，但不要求这些电平连续。但b的最后一个高电平一定和c连续。</p>
<h6 id="example-7"><a href="#example-7" class="headerlink" title="example"></a>example</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p25;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(start) |-&gt; ##<span class="number">2</span> (a[-&gt;<span class="number">3</span>]) ##<span class="number">1</span> stop;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a25: <span class="keyword">assert</span> <span class="keyword">property</span>(p25);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-63.png" alt="Alt text"><br>a的3个上升沿后，stop没有在下一个周期立刻上升，故断言失败。</p>
<h5 id="Nonconsecutive-Repetition"><a href="#Nonconsecutive-Repetition" class="headerlink" title="Nonconsecutive Repetition"></a>Nonconsecutive Repetition</h5><p>nonconsecutive 重复允许事件之间有任意数量的时钟周期间隔。相当于Goto Repetition最后一个重复周期与后面的信号序列不用连续。<br><img src="/2024/02/12/System-Verilog-Notes/image-62.png" alt="Alt text"><br>用法：使用 &#x3D; 操作符表示 nonconsecutive 重复。</p>
<h6 id="example-8"><a href="#example-8" class="headerlink" title="example"></a>example</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p26;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(start) |-&gt; ##<span class="number">2</span> (a[=<span class="number">3</span>]) ##<span class="number">1</span> stop ##<span class="number">1</span> !stop;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a26:<span class="keyword">assert</span> <span class="keyword">property</span>(p26);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-64.png" alt="Alt text"><br>与p25一样的信号，使用Nonconsecutive Repetition可以断言成功。</p>
<h4 id="throughout-持续"><a href="#throughout-持续" class="headerlink" title="throughout 持续"></a>throughout 持续</h4><p>在 SystemVerilog 的序列（sequence）中，throughout 是一个关键字，用于描述一种强制性的关系，即一个事件在另一个事件发生的整个持续时间内必须为真。这种构造在描述复杂的时序关系时非常有用，特别是当一个条件必须在另一个条件的整个持续期间内持续成立时。</p>
<h5 id="example-9"><a href="#example-9" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> burst_rule1;</span><br><span class="line">    @(<span class="keyword">posedge</span> mclk)</span><br><span class="line">        <span class="built_in">$fell</span>(burst_mode) ##<span class="number">0</span>(!burst_mode) <span class="keyword">throughout</span> (##<span class="number">2</span> ((trdy==<span class="number">0</span>)&amp;&amp;(irdy==<span class="number">0</span>)) [*<span class="number">7</span>]);</span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-65.png" alt="Alt text"></p>
<h4 id="within"><a href="#within" class="headerlink" title="within"></a>within</h4><p>在 SystemVerilog 的序列（sequence）中，within 是一个关键字，用于描述一个序列必须完全发生在另一个序列的持续时间内的关系。(注意和throughout的区别)</p>
<h5 id="example-10"><a href="#example-10" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s32a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        ((!a&amp;&amp;!b) ##<span class="number">1</span> (c[-&gt;<span class="number">3</span>]) ##<span class="number">1</span> (a&amp;&amp;b));</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s32b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        <span class="built_in">$fell</span>(start) ##[<span class="number">5</span>:<span class="number">10</span>] <span class="built_in">$rose</span>(start);</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s32;</span><br><span class="line">@(<span class="keyword">posedge</span> clk) s32a <span class="keyword">within</span> s32b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p32;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$fell</span>(start) |-&gt; s32;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">a32: <span class="keyword">assert</span> <span class="keyword">property</span>(p32);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-66.png" alt="Alt text"></p>
<h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p>在 SystemVerilog 的序列（sequence）中，and 关键字用于描述两个或多个序列必须同时发生的关系。两个seq必须同时开始,但不必同时结束。</p>
<h5 id="example-11"><a href="#example-11" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s27a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##[<span class="number">1</span>:<span class="number">2</span>] b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s27b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c ##[<span class="number">2</span>:<span class="number">3</span>] d;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p27;</span><br><span class="line">    s27a <span class="keyword">and</span> s27b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a27: <span class="keyword">assert</span> <span class="keyword">property</span>(p27);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-67.png" alt="Alt text"></p>
<h4 id="intersect-交集"><a href="#intersect-交集" class="headerlink" title="intersect 交集"></a>intersect 交集</h4><p>在 SystemVerilog 的序列（sequence）中，intersect 关键字用于描述两个序列在某个时间点上有重叠的关系。intersect 用于指定两个序列在某个时间点上必须有重叠。这意味着这些序列中的事件或条件必须在某个时刻同时为真，它们的开始和结束时间相同。</p>
<h5 id="example-12"><a href="#example-12" class="headerlink" title="example"></a>example</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s28a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a##[<span class="number">1</span>:<span class="number">2</span>] b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s28b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c##[<span class="number">2</span>:<span class="number">3</span>] d;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p28;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) s28a <span class="keyword">intersect</span> s28b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a28:<span class="keyword">assert</span> <span class="keyword">property</span>(p28);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-68.png" alt="Alt text"></p>
<h5 id="和throughout的区别"><a href="#和throughout的区别" class="headerlink" title="和throughout的区别"></a>和throughout的区别</h5><p>throughout 要求一个序列在另一个序列的整个时间范围内持续为真。<br>intersect 只要求两个序列在某个时间点上有重叠，而不需要覆盖整个时间范围。</p>
<h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p>在 SystemVerilog 的序列（sequence）中，or 关键字用于描述两个或多个序列中的任意一个满足条件即可的关系。</p>
<h5 id="example-13"><a href="#example-13" class="headerlink" title="example"></a>example</h5><p><img src="/2024/02/12/System-Verilog-Notes/image-69.png" alt="Alt text"></p>
<h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>property 用于表达更复杂的断言条件，它可以包含一个或多个 sequence，并支持逻辑运算（如 AND、OR、NOT）和其他控制结构（如 if-then-else）。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> name_of_property;</span><br><span class="line">    &lt;test expression&gt;;</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">    &lt;complex <span class="keyword">sequence</span> expressions&gt;;</span><br><span class="line"><span class="keyword">endproperty</span></span><br></pre></td></tr></table></figure>


<h4 id="example-14"><a href="#example-14" class="headerlink" title="example:"></a>example:</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test_sequence1;</span><br><span class="line">    <span class="keyword">reg</span> a,clk;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">        clk=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">1</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">13</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">15</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">19</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">21</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">25</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">27</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">29</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">31</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        #<span class="number">33</span> a=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">35</span> a=<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> #<span class="number">1</span> clk=!clk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断每个时钟上升沿，a是否为1</span></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p1;</span><br><span class="line">    s1;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">assertion1: <span class="keyword">assert</span> <span class="keyword">property</span>(p1);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-26.png" alt="Alt text"></p>
<h4 id="系统函数："><a href="#系统函数：" class="headerlink" title="系统函数："></a>系统函数：</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$rose</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否从低到高跳变（0到1）。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$fell</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否从高到低跳变（1到0）。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$stable</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否保持不变。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$changed</span>(signal)<span class="comment">//检测 signal 在上一个时钟周期到当前时钟周期之间是否发生了变化。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$past</span>(signal[, n])<span class="comment">//返回 n 个时钟周期之前 signal 的值。如果 n 省略，默认为1。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$countones</span>(expression)<span class="comment">//计算表达式中值为1的位数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$onehot</span>(expression)<span class="comment">//检测表达式是否恰好只有一个位为1（独热编码）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$onehot0</span>(expression)<span class="comment">//检测表达式是否为零或恰好只有一个位为1。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">first_match</span>()<span class="comment">//用于在一系列可能的事件中识别第一个匹配特定条件的事件。</span></span><br></pre></td></tr></table></figure>

<h4 id="property-的否定"><a href="#property-的否定" class="headerlink" title="property 的否定"></a>property 的否定</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s6;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">2</span> b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p6;</span><br><span class="line">    <span class="keyword">not</span> s6;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a6 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p6);</span><br></pre></td></tr></table></figure>


<h4 id="蕴含操作："><a href="#蕴含操作：" class="headerlink" title="蕴含操作："></a>蕴含操作：</h4><p>等同于逻辑学中的蕴含。真值表：</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>a-&gt;b</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>a|-&gt;b &#x3D; a&amp;b | ~a</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p8;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; b;<span class="comment">//a发生后b也发生</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">a8 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p8);</span><br></pre></td></tr></table></figure>




<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p9;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |=&gt; b;<span class="comment">//a发生一个周期后b发生</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a9 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p9);</span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p10;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; ##<span class="number">2</span> b;<span class="comment">//a发生2个周期后b发生</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a10 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p10);</span><br></pre></td></tr></table></figure>


<h4 id="ended关键词控制断言检查的时间"><a href="#ended关键词控制断言检查的时间" class="headerlink" title="ended关键词控制断言检查的时间"></a>ended关键词控制断言检查的时间</h4><p>ended 关键词用于检测一个序列是否已经到达了其结束点。这对于确定某个特定的时序模式是否已经完整地发生非常有用。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> sl5a;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> sl5b;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c ##<span class="number">1</span> d;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> pl5a;</span><br><span class="line">    sl5a |=&gt; sl5b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> pl5b;</span><br><span class="line">    sl5a<span class="variable">.ended</span> |-&gt; ##<span class="number">2</span> sl5b<span class="variable">.ended</span>; <span class="comment">//终点的对齐，p15a与p15b起点不同，结果一致</span></span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line">al5a: <span class="keyword">assert</span> <span class="keyword">property</span>(@(<span class="keyword">posedge</span> clk) pl5a);</span><br><span class="line">al5b: <span class="keyword">assert</span> <span class="keyword">property</span>(@(<span class="keyword">posedge</span> clk) pl5b);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-60.png" alt="Alt text"></p>
<h4 id="disable-iff"><a href="#disable-iff" class="headerlink" title="disable iff"></a>disable iff</h4><p>iff:if and only if<br>disable iff（如果…则禁用）是一个关键的构造，用于定义在某些特定条件下断言不应该被评估或应该被禁用的情况。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> p34;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">disable</span> <span class="keyword">iff</span> (reset) </span><br><span class="line">        <span class="built_in">$rose</span>(start) |=&gt; a[=<span class="number">2</span>] ##<span class="number">1</span> b[=<span class="number">2</span>] ##<span class="number">1</span> !start ;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a34： <span class="keyword">assert</span> <span class="keyword">property</span>(p34);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-70.png" alt="Alt text"></p>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>assert 语句用于实际应用断言。它将 property 应用于设计中的特定点，以验证在那个点上 property 是否为真。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span> (prop_X_implies_Y) <span class="keyword">else</span> <span class="built_in">$error</span>(<span class="string">&quot;Assertion failed&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="sequence-property-assert的关系："><a href="#sequence-property-assert的关系：" class="headerlink" title="sequence,property,assert的关系："></a>sequence,property,assert的关系：</h4><pre><code>sequence 提供了描述事件顺序的基础。
property 利用 sequence（可能是多个）来表达更复杂的逻辑条件。
assert 将 property 应用于实际的硬件设计，以确保在运行时满足这些条件。
</code></pre>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>理解以下sequence,property和assert的作用：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sequence</span> s4;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">2</span> b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s2;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) <span class="built_in">$rose</span>(a);</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s3_lib (a，b);</span><br><span class="line">    a || b;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##<span class="number">1</span> c;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:<span class="number">3</span>] c;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sequence</span> s1;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a ##<span class="number">1</span> b ##[<span class="number">0</span>:$] c;</span><br><span class="line"><span class="keyword">endsequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p6;</span><br><span class="line">    <span class="keyword">not</span> s6;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p8;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a8 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p9;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |=&gt; b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a9 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p9);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p12;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) (a &amp;&amp; b) |-&gt; ##[<span class="number">1</span>:<span class="number">3</span>] c;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a12 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p12);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p10;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; ##<span class="number">2</span> b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a10 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p10);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p13;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) (a &amp;&amp; b) |-&gt; ##[<span class="number">0</span>：<span class="number">2</span>] c;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a13 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p13);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p14;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) a |-&gt; ##[<span class="number">1</span>：$] b ##[<span class="number">0</span>：$] c;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a14 ： <span class="keyword">assert</span> <span class="keyword">property</span>(p14);</span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p17;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) c ? d == a：d == b;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a17： <span class="keyword">assert</span> <span class="keyword">property</span>(p17);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">property</span> p19;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk) (c &amp;&amp; d) |-&gt; (<span class="built_in">$past</span>((a&amp;&amp;b)，<span class="number">2</span>) == <span class="number">1&#x27;b1</span>);</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line">a19： <span class="keyword">assert</span> <span class="keyword">property</span>(p19);</span><br></pre></td></tr></table></figure>


<h3 id="如何在仿真中加入assertion"><a href="#如何在仿真中加入assertion" class="headerlink" title="如何在仿真中加入assertion"></a>如何在仿真中加入assertion</h3><p>命令行：<br><img src="/2024/02/12/System-Verilog-Notes/image-61.png" alt="Alt text"><br>gui界面：<br><img src="/2024/02/12/System-Verilog-Notes/image-27.png" alt="Alt text"></p>
<h3 id="如何在testbench中绑定assertion模块"><a href="#如何在testbench中绑定assertion模块" class="headerlink" title="如何在testbench中绑定assertion模块"></a>如何在testbench中绑定assertion模块</h3><h2 id="Random-coverage"><a href="#Random-coverage" class="headerlink" title="Random coverage"></a>Random coverage</h2><h3 id="使用ramdom的原因"><a href="#使用ramdom的原因" class="headerlink" title="使用ramdom的原因"></a>使用ramdom的原因</h3><p>传统的directed test case无法覆盖所有情况，同时，directed test case只能验证设计时的预期功能。</p>
<p>因此需要引入随机。</p>
<p>random应用场景：<br>1.devices configuration<br>2.sequence order<br>3.environment config<br>4.delays within a constrained range<br>5.dynamic config<br>6.protocol exceptions,error and violations<br>…</p>
<h3 id="sv-中的random"><a href="#sv-中的random" class="headerlink" title="sv 中的random"></a>sv 中的random</h3><h4 id="关键字rand"><a href="#关键字rand" class="headerlink" title="关键字rand"></a>关键字rand</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> [<span class="number">3</span>:<span class="number">0</span>]  data</span><br></pre></td></tr></table></figure>

<h4 id="randc-random-cycle"><a href="#randc-random-cycle" class="headerlink" title="randc (random cycle)"></a>randc (random cycle)</h4><p><img src="/2024/02/12/System-Verilog-Notes/image-31.png" alt="Alt text"></p>
<p>每个循环调用时，自动变更为与上一个值不同的随机数，并且遍历取值范围。</p>
<h4 id="constraint-block"><a href="#constraint-block" class="headerlink" title="constraint block"></a>constraint block</h4><p>在 SystemVerilog 中，约束块（Constraint Block）是一种用于随机化测试中的强大机制，它允许你为类的成员变量指定特定的约束条件。这些约束用于控制随机生成的数据，以满足特定的测试需求或设计规范。</p>
<p>constraint 可以定义在class 之外。例：  </p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> XYPair;</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="comment">// external constraint body declaration</span></span><br><span class="line"><span class="keyword">constraint</span> XYPair::c &#123; x &lt; y; &#125;</span><br></pre></td></tr></table></figure>

<p>constraint 可以被继承，例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> A;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">integer</span> x;</span><br><span class="line">    <span class="keyword">constraint</span> c &#123; x &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">class</span> B <span class="keyword">extends</span> A;</span><br><span class="line">    <span class="keyword">constraint</span> c &#123; x &gt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h4 id="求解器randomize"><a href="#求解器randomize" class="headerlink" title="求解器randomize()"></a>求解器randomize()</h4><p>randomize() 方法用于随机化类中标记为 rand 或 randc 的成员变量。它根据定义在类中的约束（如果有的话）生成随机值。</p>
<p>randomize()是一个虚函数，每当constraint被继承时，原函数被重载。</p>
<h4 id="pre-randomize-和post-randomize"><a href="#pre-randomize-和post-randomize" class="headerlink" title="pre_randomize()和post_randomize()"></a>pre_randomize()和post_randomize()</h4><p>如其名，是在randomize()前后执行的2个函数。可以被重载。<br>pre_randomize() 方法在每次调用 randomize() 方法之前自动执行。<br>用途：它用于设置随机化操作之前需要的任何状态或条件，比如初始化变量、清除状态、设置默认值等。</p>
<p>post_randomize() 方法在每次调用 randomize() 方法之后自动执行。<br>用途：它用于在随机化之后执行任何必要的操作，比如校验或调整随机化结果、更新依赖于随机值的状态等。</p>
<p>在被重载时，pre_randomize()和post_randomize()都会先执行父类的方法，然后执行重载的内容。<br>The pre_randomize() and post_randomize() methods are not virtual. However, because they are automatically called by the randomize() method, which is virtual, they appear to behave as virtual method.</p>
<h4 id="inside-指定表达式的范围"><a href="#inside-指定表达式的范围" class="headerlink" title="inside 指定表达式的范围"></a>inside 指定表达式的范围</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Bus</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">15</span>:<span class="number">0</span>] addr;</span><br><span class="line"><span class="keyword">randc</span> <span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line"><span class="keyword">constraint</span> range1</span><br><span class="line">&#123;</span><br><span class="line">    addr <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">100</span>],[<span class="number">1024</span>:<span class="number">16384</span>]&#125;;</span><br><span class="line">    data &gt; <span class="number">1000</span>;</span><br><span class="line">    data &lt; <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h4 id="dist-指定权重分布"><a href="#dist-指定权重分布" class="headerlink" title="dist 指定权重分布"></a>dist 指定权重分布</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">int</span> src, dst;</span><br><span class="line">costraint c1 &#123;</span><br><span class="line">    src <span class="keyword">dist</span> &#123;<span class="number">0</span>:=<span class="number">40</span>, [<span class="number">1</span>:<span class="number">3</span>]:=<span class="number">60</span>&#125;;</span><br><span class="line">    dst <span class="keyword">dist</span> &#123;<span class="number">0</span>:=<span class="number">40</span>, [<span class="number">1</span>:<span class="number">3</span>]:/<span class="number">60</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-32.png" alt="Alt text"></p>
<p>:&#x3D; 用于相同分布<br>:&#x2F;用于均匀分布</p>
<h4 id="多维约束"><a href="#多维约束" class="headerlink" title="多维约束"></a>多维约束</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] b,c,d;</span><br><span class="line">costraint c1 &#123;</span><br><span class="line">    b&lt;d;</span><br><span class="line">    c==b;</span><br><span class="line">    d&lt;<span class="number">30</span>;</span><br><span class="line">    c&gt;=<span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件约束"><a href="#条件约束" class="headerlink" title="条件约束"></a>条件约束</h4><p>可以包含蕴含操作：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] a,b;</span><br><span class="line"><span class="keyword">constraint</span> c &#123;(a==<span class="number">0</span>)-&gt;(b==<span class="number">1</span>);&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="约束的概率问题"><a href="#约束的概率问题" class="headerlink" title="约束的概率问题"></a>约束的概率问题</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Unconstrained;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> x;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] y;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-33.png" alt="Alt text"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Imp1;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> x;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] y;</span><br><span class="line">    <span class="keyword">constraint</span> c_xy &#123; (x==<span class="number">0</span>)-&gt;y==<span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-34.png" alt="Alt text"></p>
<h4 id="迭代约束"><a href="#迭代约束" class="headerlink" title="迭代约束"></a>迭代约束</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Class C;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">byte</span> A[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">constraint</span> C1&#123; <span class="keyword">foreach</span> (A[i]) A[i]<span class="keyword">inside</span> &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>&#125;;&#125;</span><br><span class="line">    <span class="keyword">constraint</span> C2&#123; <span class="keyword">foreach</span> (A[j]) A[j]&gt; <span class="number">2</span>*j;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C1 constraints each element of an array to be in the set [2,4,8,16]</span></span><br><span class="line"><span class="comment">//C2 constraints each element of an array to be greater than twice its index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h4 id="solve-before-控制求解顺序"><a href="#solve-before-控制求解顺序" class="headerlink" title="solve before :控制求解顺序"></a>solve before :控制求解顺序</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> B;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> s;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] d;</span><br><span class="line">    <span class="keyword">constraint</span> c &#123; s -&gt; d == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">constraint</span> order &#123; <span class="keyword">solve</span> s <span class="keyword">before</span> d; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-35.png" alt="Alt text"></p>
<h4 id="function-in-constraints"><a href="#function-in-constraints" class="headerlink" title="function in constraints"></a>function in constraints</h4><p>用途：使用function来表示一些复杂的分布情况。<br>例：编码中1的个数。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> count_ones ( <span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>] w );</span><br><span class="line">    <span class="keyword">for</span>( count_ones = <span class="number">0</span>; w != <span class="number">0</span>; w = w &gt;&gt; <span class="number">1</span> )</span><br><span class="line">        count_ones += w &amp; <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> C1 &#123; length == count_ones( v ) ; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="constraint-mode-控制约束的开启和关闭"><a href="#constraint-mode-控制约束的开启和关闭" class="headerlink" title="constraint mode: 控制约束的开启和关闭"></a>constraint mode: 控制约束的开启和关闭</h4><p>内建函数：constraint_mode()，默认0 为inactive,1为activate</p>
<h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><p>2个方面：<strong>代码覆盖率</strong>和<strong>功能覆盖率</strong>。</p>
<p>代码覆盖率可以被自动收集量化。<br>功能覆盖率需要一定的方法学评估。<br><img src="/2024/02/12/System-Verilog-Notes/image-36.png" alt="Alt text"></p>
<h4 id="代码覆盖率的类型："><a href="#代码覆盖率的类型：" class="headerlink" title="代码覆盖率的类型："></a>代码覆盖率的类型：</h4><ol>
<li><p>行覆盖率（Line Coverage&#x2F;Statement Coverage）：<br> 测量测试用例是否执行了设计中的每一行代码。<br> 用于确保代码的每一行至少被执行一次。  </p>
</li>
<li><p>块覆盖率(Block Coverage)<br> 通常指的是测试用例是否执行了代码中的每个基本块。一个基本块是一个直线代码序列，没有分支，只有入口和出口。<br> 确保每个代码块至少被执行一次。</p>
</li>
<li><p>表达式覆盖率（Expression Coverage）：<br> 检查是否测试了代码中的每个表达式的所有可能结果。<br> 用于确保所有的逻辑表达式都被充分测试。</p>
</li>
<li><p>分支覆盖率（Branch Coverage）：<br> 测量是否测试了代码中的每个决策点（如 if、case 语句）的每个可能分支。<br> 用于确保每个决策点的每个分支都至少被执行一次。</p>
</li>
<li><p>条件覆盖率（Condition Coverage）：<br> 检查是否测试了决策点中每个单独条件的所有可能结果。<br> 用于确保复合条件（如逻辑与&#x2F;或）中的每个单独条件都被充分测试。</p>
</li>
<li><p>切换覆盖率（Toggle Coverage）：<br>测量是否测试了设计中每个数据位的翻转（从0到1和从1到0）。<br>用于确保寄存器、线网等的每个位至少翻转一次。</p>
</li>
<li><p>状态机覆盖率（FSM Coverage）：<br>检查是否测试了状态机的所有状态和转换。<br>用于确保状态机的每个状态和状态转换都被测试。</p>
</li>
<li><p>路径覆盖率（Path Coverage）：<br>测量是否测试了代码中所有可能的执行路径。<br>用于确保从函数入口到出口的每个可能路径都被执行。</p>
</li>
<li><p>断言覆盖率（Assertion Coverage）：<br>检查是否测试了代码中的每个断言。<br>用于确保设计中的每个断言都被验证。</p>
</li>
</ol>
<p>代码覆盖率不关心具体功能的实现。因此无法保证功能的正确性。</p>
<h4 id="功能覆盖率Functional-Coverage）："><a href="#功能覆盖率Functional-Coverage）：" class="headerlink" title="功能覆盖率Functional Coverage）："></a>功能覆盖率Functional Coverage）：</h4><p>功能覆盖率是衡量测试用例是否覆盖了设计的所有功能方面的度量。它关注于设计的功能需求是否得到了充分的测试。</p>
<p>功能覆盖率需要人工定义。根据对设计的理解设计不同的功能模块。Based on the DUT spec and test plan, define what needs to be covered.</p>
<p>步骤：<br>Define coverage group (sampling points)<br>Define when to sample</p>
<h4 id="cover-group"><a href="#cover-group" class="headerlink" title="cover group"></a>cover group</h4><p>覆盖组是一组相关的覆盖点和&#x2F;或交叉覆盖点的集合。它用于组织和封装相关的覆盖点，以便于管理和分析。<br>特点：覆盖组可以包含一个或多个覆盖点，以及可选的交叉覆盖点（cross coverage）。它还可以包含用于控制采样时机和条件的方法。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> cg;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line">cg cg_inst = <span class="keyword">new</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mem(simple_bus sb);</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data, addr;</span><br><span class="line"><span class="keyword">event</span> write_event;</span><br><span class="line">    <span class="keyword">cover</span> <span class="keyword">property</span></span><br><span class="line">        (@(<span class="keyword">posedge</span> sb<span class="variable">.clock</span>) sb<span class="variable">.write_ena</span>==<span class="number">1</span>)</span><br><span class="line">    -&gt; write_event;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 cover property 定义了一个覆盖属性，该属性监视 simple_bus 上的 write_ena 信号。当 write_ena 在时钟上升沿为 1 时，触发 write_event 事件。</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test(simple_bus sb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> Write_cg @($root<span class="variable">.top</span><span class="variable">.m1</span><span class="variable">.write_event</span>);</span><br><span class="line">        <span class="keyword">coverpoint</span> $root<span class="variable">.top</span><span class="variable">.m1</span><span class="variable">.data</span>;</span><br><span class="line">        <span class="keyword">coverpoint</span> $root<span class="variable">.top</span><span class="variable">.m1</span><span class="variable">.addr</span>;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    Write_cg wcg;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        wcg = <span class="keyword">new</span>;</span><br><span class="line">        sb<span class="variable">.write_ena</span> &lt;= <span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">        #<span class="number">10000</span> <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//est 是一个程序，它也接收一个名为 sb 的 simple_bus 类型的参数。</span></span><br><span class="line"><span class="comment">//覆盖组：定义了一个名为 Write_cg 的覆盖组，该覆盖组在 write_event 事件发生时被采样。</span></span><br><span class="line"><span class="comment">//覆盖点：覆盖组包含两个覆盖点，分别监视 mem 模块中的 data 和 addr 变量。</span></span><br><span class="line"><span class="comment">//覆盖组实例化：在初始块中创建了 Write_cg 的一个实例 wcg。</span></span><br><span class="line"><span class="comment">//测试逻辑：设置 simple_bus 的 write_ena 为 1，并执行一些未详细说明的测试操作。</span></span><br><span class="line"><span class="comment">//仿真结束：在 10000 个时间单位后结束仿真。</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<h4 id="coverage-point"><a href="#coverage-point" class="headerlink" title="coverage point"></a>coverage point</h4><p>覆盖点是对单个变量或表达式的覆盖度量。<br>用途：它用于捕捉和度量特定变量或表达式在测试中的行为。<br>特点：覆盖点可以定义为变量的特定值、范围或者是基于表达式的条件。它通常包含一组覆盖桶（bins），每个桶对应于特定的值或值范围。</p>
<p><img src="/2024/02/12/System-Verilog-Notes/image-71.png" alt="Alt text"></p>
<h4 id="bin-：对功能点分组"><a href="#bin-：对功能点分组" class="headerlink" title="bin ：对功能点分组"></a>bin ：对功能点分组</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] y;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] values[$]= &#x27;&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">covergroup</span> cg;</span><br><span class="line">cover_point_y : <span class="keyword">coverpoint</span> y &#123;</span><br><span class="line">    <span class="keyword">bins</span> a = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">bins</span> b = &#123;<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">bins</span> c = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">bins</span> d = &#123;<span class="number">6</span>,<span class="number">7</span>&#125;; &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">foreach</span>(values[i])</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        y = values[i];</span><br><span class="line">        cg_inst<span class="variable">.sample</span>();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<h5 id="Transitional-functional-point-bin"><a href="#Transitional-functional-point-bin" class="headerlink" title="Transitional functional point bin"></a>Transitional functional point bin</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">3</span>] y;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] values[$]= &#x27;&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">    cover_point_y : <span class="keyword">coverpoint</span> y &#123;</span><br><span class="line">        <span class="keyword">bins</span> tran_34 = (<span class="number">3</span>=&gt;<span class="number">4</span>);<span class="comment">//捕捉从3到4的切换</span></span><br><span class="line">        <span class="keyword">bins</span> tran_56 = (<span class="number">5</span>=&gt;<span class="number">6</span>);<span class="comment">//捕捉从5到6的切换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">foreach</span>(values[i])<span class="keyword">begin</span></span><br><span class="line">            y = values[i];</span><br><span class="line">            cg_inst<span class="variable">.sample</span>();</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-74.png" alt="Alt text"></p>
<h5 id="wildcard-bin-通配分组"><a href="#wildcard-bin-通配分组" class="headerlink" title="wildcard bin:通配分组"></a>wildcard bin:通配分组</h5><p>分组中的x,z,?会和0,1产生通配。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">3</span>] y;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">3</span>] values[$]= &#x27;&#123; <span class="number">4&#x27;b1100</span>,<span class="number">4&#x27;b1101</span>,<span class="number">4&#x27;b1110</span>,<span class="number">4&#x27;b1111</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">        cover_point_y : <span class="keyword">coverpoint</span> y &#123;</span><br><span class="line">        <span class="keyword">wildcard</span> <span class="keyword">bins</span> g12_15 = &#123; <span class="number">4&#x27;b11</span>?? &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">foreach</span>(values[i])<span class="keyword">begin</span></span><br><span class="line">            y = values[i];</span><br><span class="line">            cg_inst<span class="variable">.sample</span>();</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/02/12/System-Verilog-Notes/image-72.png" alt="Alt text"></p>
<h5 id="ignore-bin-忽略的分组"><a href="#ignore-bin-忽略的分组" class="headerlink" title="ignore_bin 忽略的分组"></a>ignore_bin 忽略的分组</h5><p>ignore_bin 用于在覆盖率分析中排除特定的值或值范围。它有助于简化覆盖模型，专注于关键的、有意义的值或状态。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] y;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">2</span>] values[$]= &#x27;&#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">        cover_point_y : <span class="keyword">coverpoint</span> y &#123;<span class="comment">//0,1,2,3,4,5,6,7</span></span><br><span class="line">        <span class="keyword">ignore_bins</span> ig = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">foreach</span>(values[i])<span class="keyword">begin</span></span><br><span class="line">        y = values[i];</span><br><span class="line">        cg_inst<span class="variable">.sample</span>();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/12/System-Verilog-Notes/image-73.png" alt="Alt text"><br>0没有被覆盖到。</p>
<h5 id="illegal-bins"><a href="#illegal-bins" class="headerlink" title="illegal_bins"></a>illegal_bins</h5><p>定义不合法的部分，如果出现这些值直接报错。</p>
<h5 id="cross"><a href="#cross" class="headerlink" title="cross"></a>cross</h5><p>在 SystemVerilog 的功能覆盖率（Functional Coverage）中，cross 关键字用于定义交叉覆盖（Cross Coverage）。交叉覆盖是一种分析技术，用于度量两个或多个覆盖点（coverpoints）之间的组合情况。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> main;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] y;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] y_values[$]= &#x27;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] z;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">0</span>:<span class="number">1</span>] z_values[$]= &#x27;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cg;</span><br><span class="line">        cover_point_y : <span class="keyword">coverpoint</span> y ;</span><br><span class="line">        cover_point_z : <span class="keyword">coverpoint</span> z ;</span><br><span class="line">        cross_yz : <span class="keyword">cross</span> cover_point_y,cover_point_z ;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    cg cg_inst = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">foreach</span>(y_values[i])<span class="keyword">begin</span></span><br><span class="line">            y = y_values[i];</span><br><span class="line">            z = z_values[i];</span><br><span class="line">            cg_inst<span class="variable">.sample</span>();</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<h5 id="conditional-Coverage"><a href="#conditional-Coverage" class="headerlink" title="conditional Coverage"></a>conditional Coverage</h5><p>条件覆盖</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> CoverPort;</span><br><span class="line">    <span class="keyword">coverpoint</span> port <span class="keyword">iff</span> (!bus_if<span class="variable">.reset</span>);</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>

<p>当且仅当满足某种条件时才收集sample.</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>ICer</tag>
      </tags>
  </entry>
</search>
